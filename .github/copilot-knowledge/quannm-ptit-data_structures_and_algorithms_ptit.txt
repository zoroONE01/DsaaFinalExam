Directory structure:
└── quannm-ptit-data_structures_and_algorithms_ptit/
    ├── README.md
    ├── Algorithms/
    │   ├── DISJOIN SET UNION (DSU).cpp
    │   ├── KOSARAJU ALGORITHM.cpp
    │   └── KRUSKAL ALGORITHM.cpp
    ├── Backtracking/
    │   ├── DSA01024 - ĐẶT TÊN - 1.cpp
    │   ├── DSA02001 - DÃY SỐ 1.cpp
    │   ├── DSA02002 - DÃY SỐ 2.cpp
    │   ├── DSA02003 - DI CHUYỂN TRONG MÊ CUNG 1.cpp
    │   ├── DSA02004 - DI CHUYỂN TRONG MÊ CUNG 2.cpp
    │   ├── DSA02005 - HOÁN VỊ XÂU KÝ TỰ.cpp
    │   ├── DSA02006 - DÃY CON TỔNG BẰNG K.cpp
    │   ├── DSA02007 - ĐỔI CHỖ CÁC CHỮ SỐ.cpp
    │   ├── DSA02009 - CHIA MẢNG.cpp
    │   ├── DSA02010 - TỔ HỢP SỐ CÓ TỔNG BẰNG X.cpp
    │   ├── DSA02011 - MÁY ATM.cpp
    │   ├── DSA02012 - DI CHUYỂN TRONG MA TRẬN.cpp
    │   ├── DSA02013 - SỐ NGUYÊN TỐ.cpp
    │   ├── DSA02014 - TỪ ĐIỂN.cpp
    │   ├── DSA02015 - LOẠI BỎ DẤU NGOẶC.cpp
    │   ├── DSA02016 - SẮP XẾP QUÂN HẬU 1.cpp
    │   ├── DSA02017 - SẮP XẾP QUÂN HẬU 2.cpp
    │   ├── DSA02018 - BIỂU THỨC TOÁN HỌC.cpp
    │   ├── DSA02019 - ĐƯỜNG ĐI DÀI NHẤT.cpp
    │   ├── DSA02020 - SỐ NHỎ NHẤT CÓ N ƯỚC SỐ.cpp
    │   ├── DSA02021 - KÝ TỰ ĐẶC BIỆT.cpp
    │   ├── DSA02022 - NGÀY ĐẶC BIỆT.cpp
    │   ├── DSA02023 - ĐẶT TÊN.cpp
    │   ├── DSA02024 - DÃY CON TĂNG DẦN.cpp
    │   ├── DSA02025 - KÝ TỰ LẶP.cpp
    │   ├── DSA02026 - PHÉP TOÁN CƠ BẢN.cpp
    │   ├── DSA02027 - NGƯỜI DU LỊCH.cpp
    │   ├── DSA02028 - CHIA ĐỀU.cpp
    │   ├── DSA02029 - THÁP HÀ NỘI.cpp
    │   ├── DSA02030 - LIỆT KÊ XÂU KÝ TỰ.cpp
    │   ├── DSA02031 - GHÉP CHỮ CÁI.cpp
    │   ├── DSA02032 - TỔ HỢP SỐ CÓ TỔNG BẰNG X.cpp
    │   ├── DSA02033 - SỐ XA CÁCH.cpp
    │   ├── DSA02034 - TRÒ CHƠI VỚI CÁC CON SỐ.cpp
    │   ├── DSA02035 - HOÁN VỊ CÁC CHỮ SỐ.cpp
    │   ├── DSA02036 - DÃY CON CÓ TỔNG LẺ.cpp
    │   ├── DSA02037 - DÃY CON CÓ TỔNG NGUYÊN TỐ.cpp
    │   ├── DSA02038 - DÃY CON CÓ K PHẦN TỬ TĂNG DẦN.cpp
    │   ├── DSA02039 - PHÂN TÍCH SỐ 2.cpp
    │   ├── DSA02041 - BIẾN ĐỔI VỀ 1.cpp
    │   ├── DSA02045 - TẬP CON CỦA XÂU KÝ TỰ.cpp
    │   ├── DSA05009 - TẬP CON BẰNG NHAU.cpp
    │   └── DSAKT012 - ĐỔI TIỀN.cpp
    ├── Divide and Conquer/
    │   ├── DSA04001 - LŨY THỪA.cpp
    │   ├── DSA04002 - LŨY THỪA ĐẢO.cpp
    │   ├── DSA04003 - ĐẾM DÃY.cpp
    │   ├── DSA04004 - GẤP ĐÔI DÃY SỐ.cpp
    │   ├── DSA04005 - DÃY XÂU FIBONACI.cpp
    │   ├── DSA04006 - ĐẾM SỐ BÍT 1.cpp
    │   ├── DSA04007 - HỆ CƠ SỐ K.cpp
    │   ├── DSA04009 - LŨY THỪA MA TRẬN 1.cpp
    │   ├── DSA04010 - DÃY CON LIÊN TIẾP CÓ TỔNG LỚN NHẤT.cpp
    │   ├── DSA04011 - TÍCH HAI SỐ NHỊ PHÂN.cpp
    │   ├── DSA04012 - TÍCH ĐA THỨC.cpp
    │   ├── DSA04013 - SẮP XẾP KANGURU.cpp
    │   ├── DSA04014 - CẶP NGHỊCH THẾ.cpp
    │   ├── DSA04015 - TÍNH FLOOR(X).cpp
    │   ├── DSA04016 - PHẦN TỬ THỨ K.cpp
    │   ├── DSA04017 - PHẦN TỬ KHÁC NHAU.cpp
    │   ├── DSA04018 - ĐẾM SỐ 0.cpp
    │   ├── DSA04019 - CẶP ĐIỂM GẦN NHẤT.cpp
    │   ├── DSA04020 - TÌM KIẾM NHỊ PHÂN.cpp
    │   ├── DSA04021 - DÃY XÂU NHỊ PHÂN.cpp
    │   ├── DSA04022 - KÝ TỰ THỨ K TRONG XÂU.cpp
    │   ├── DSA04024 - LŨY THỪA MA TRẬN 2.cpp
    │   ├── DSA04025 - DÃY SỐ VÔ HẠN.cpp
    │   ├── DSA04030 - SỐ TRIBONACCI.cpp
    │   └── DSA04035 - TÍNH LŨY THỪA.cpp
    ├── Dynamic Programming/
    │   ├── DSA05001 - XÂU CON CHUNG DÀI NHẤT.cpp
    │   ├── DSA05003 - DÃY CON CHUNG DÀI NHẤT CỦA BA XÂU.cpp
    │   ├── DSA05004 - DÃY CON TĂNG DÀI NHẤT.cpp
    │   ├── DSA05005 - SỐ BƯỚC ÍT NHẤT.cpp
    │   ├── DSA05006 - TỔNG LỚN NHẤT CỦA DÃY CON TĂNG DẦN.cpp
    │   ├── DSA05007 - TỔNG LỚN NHẤT CỦA DÃY CON KHÔNG KỀ NHAU.cpp
    │   ├── DSA05008 - DÃY CON CÓ TỔNG BẰNG S.cpp
    │   ├── DSA05010 - DÃY CON DÀI NHẤT CÓ TỔNG CHIA HẾT CHO K.cpp
    │   ├── DSA05011 - SỐ CÓ TỔNG CHỮ SỐ BẰNG K.cpp
    │   ├── DSA05012 - TỔ HỢP C(n, k).cpp
    │   ├── DSA05013 - BẬC THANG.cpp
    │   ├── DSA05014 - CATALAN NUMBER.cpp
    │   ├── DSA05015 - TÍNH P(N,K).cpp
    │   ├── DSA05016 - SỐ UGLY.cpp
    │   ├── DSA05017 - DÃY SỐ BI-TONIC.cpp
    │   ├── DSA05018 - XÂU CON ĐỐI XỨNG DÀI NHẤT.cpp
    │   ├── DSA05019 - HÌNH VUÔNG LỚN NHẤT.cpp
    │   ├── DSA05020 - ĐƯỜNG ĐI NHỎ NHẤT.cpp
    │   ├── DSA05021 - CẶP SỐ.cpp
    │   ├── DSA05022 - KÝ TỰ GIỐNG NHAU.cpp
    │   ├── DSA05023 - TỔNG CÁC XÂU CON.cpp
    │   ├── DSA05024 - TỔNG BẰNG K.cpp
    │   ├── DSA05025 - CON ẾCH.cpp
    │   ├── DSA05026 - XEM PHIM.cpp
    │   ├── DSA05027 - CÁI TÚI.cpp
    │   ├── DSA05028 - BIẾN ĐỔI XÂU.cpp
    │   ├── DSA05029 - GIẢI MÃ.cpp
    │   ├── DSA05030 - DI CHUYỂN VỀ GỐC TỌA ĐỘ.cpp
    │   ├── DSA05031 - TỔNG BÌNH PHƯƠNG.cpp
    │   ├── DSA05032 - XÂU ĐỐI XỨNG 1.cpp
    │   ├── DSA05033 - XÂU ĐỐI XỨNG 2.cpp
    │   ├── DSA05034 - TỔNG SỐ CÁCH DI CHUYỂN.cpp
    │   ├── DSA05035 - CHỮ SỐ SẮP XẾP TĂNG DẦN.cpp
    │   ├── DSA05036 - TĂNG - GIẢM.cpp
    │   ├── DSA05037 - CHỮ SỐ SẮP XẾP TĂNG DẦN.cpp
    │   ├── DSA05038 - DÃY CON TĂNG DÀI NHẤT 2 CHIỀU.cpp
    │   ├── DSA05039 - TỔNG CHỮ SỐ.cpp
    │   ├── DSA05040 - DÃY TAM GIÁC DÀI NHẤT.cpp
    │   ├── DSA05042 - DÃY CON LIÊN TIẾP TỔNG BẰNG K.cpp
    │   ├── DSA05043 - SỐ THUẬN NGHỊCH.cpp
    │   ├── DSA05045 - BÀI TOÁN CÁI TÚI KHÔNG NGUYÊN.cpp
    │   ├── DSA05046 - LŨY THỪA BẬC K.cpp
    │   ├── DSA05047 - CHỌN Ô.cpp
    │   ├── DSAKT053 - SỐ NGUYÊN LỚN.cpp
    │   ├── DSAKT055 - BÀI TOÁN CÁI TÚI 0-1.cpp
    │   └── DSAKT110 - NHÀ KHÔNG KỀ NHAU.cpp
    ├── Generation/
    │   ├── CTDL_001 - THUẬT TOÁN SINH.cpp
    │   ├── CTDL_002 - Tổng dãy con = K.cpp
    │   ├── CTDL_003 - PHƯƠNG ÁN TỐI ƯU.cpp
    │   ├── CTDL_004 - DÃY CON TĂNG DẦN BẬC K.cpp
    │   ├── DSA01001 - XÂU NHỊ PHÂN KẾ TIẾP.cpp
    │   ├── DSA01002 - TẬP CON KẾ TIẾP.cpp
    │   ├── DSA01003 - HOÁN VỊ KẾ TIẾP.cpp
    │   ├── DSA01004 - SINH TỔ HỢP.cpp
    │   ├── DSA01004 - SINH TỔ HỢP.java
    │   ├── DSA01005 - SINH HOÁN VỊ.cpp
    │   ├── DSA01006 - HOÁN VỊ NGƯỢC.cpp
    │   ├── DSA01007 - XÂU AB CÓ ĐỘ DÀI N.cpp
    │   ├── DSA01007 - XÂU AB CÓ ĐỘ DÀI N.java
    │   ├── DSA01008 - XÂU NHỊ PHÂN CÓ K BIT 1.cpp
    │   ├── DSA01009 - XÂU AB ĐẶC BIỆT.cpp
    │   ├── DSA01010 - TẬP QUÂN SỰ.cpp
    │   ├── DSA01011 - HOÁN VỊ TIẾP THEO CỦA CHUỖI SỐ.cpp
    │   ├── DSA01012 - MÃ GRAY 1.cpp
    │   ├── DSA01013 - MÃ GRAY 2.cpp
    │   ├── DSA01014 - TẬP HỢP.cpp
    │   ├── DSA01015 - TÌM BỘI SỐ.cpp
    │   ├── DSA01016 - PHÂN TÍCH SỐ 1.cpp
    │   ├── DSA01017 - MÃ GRAY 3.cpp
    │   ├── DSA01018 - TẬP CON LIỀN KỀ PHÍA TRƯỚC.cpp
    │   ├── DSA01019 - HAHAHA.cpp
    │   ├── DSA01020 - XÂU NHỊ PHÂN TRƯỚC.cpp
    │   ├── DSA01021 - TỔ HỢP TIẾP THEO.cpp
    │   ├── DSA01022 - SỐ THỨ TỰ HOÁN VỊ.cpp
    │   ├── DSA01023 - SỐ THỨ TỰ TỔ HỢP.cpp
    │   ├── DSA01025 - ĐẶT TÊN - 2.cpp
    │   ├── DSA01026 - PHÁT LỘC.cpp
    │   ├── DSA01027 - HOÁN VỊ DÃY SỐ.cpp
    │   ├── DSA01028 - LIỆT KÊ TỔ HỢP.cpp
    │   └── DSA02008 - CHỌN SỐ TỪ MA TRẬN VUÔNG CẤP N.cpp
    ├── Graph/
    │   ├── DSA09001 - CHUYỂN DANH SÁCH CẠNH SANG DANH SÁCH KỀ.cpp
    │   ├── DSA09002 - CHUYỂN TỪ DANH SÁCH KỀ SANG DANH SÁCH CẠNH.cpp
    │   ├── DSA09003 - BIỂU DIỄN ĐỒ THỊ CÓ HƯỚNG..cpp
    │   ├── DSA09004 - DFS TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
    │   ├── DSA09005 - BFS TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
    │   ├── DSA09006 - ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ VÔ HƯỚNG.cpp
    │   ├── DSA09007 - ĐƯỜNG ĐI THEO BFS TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
    │   ├── DSA09008 - ĐẾM SỐ THÀNH PHẦN LIÊN THÔNG.cpp
    │   ├── DSA09009 - TÌM SỐ THÀNH PHẦN LIÊN THÔNG VỚI BFS.cpp
    │   ├── DSA09010 - KIỂM TRA TÍNH LIÊN THÔNG MẠNH.cpp
    │   ├── DSA09011 - SỐ LƯỢNG HÒN ĐẢO.cpp
    │   ├── DSA09012 - LIỆT KÊ ĐỈNH TRỤ.cpp
    │   ├── DSA09013 - LIỆT KÊ CẠNH CẦU.cpp
    │   ├── DSA09014 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
    │   ├── DSA09015 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
    │   ├── DSA09016 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG VỚI DFS.cpp
    │   ├── DSA09017 - KIỂM TRA ĐỒ THỊ CÓ PHẢI LÀ CÂY HAY KHÔNG.cpp
    │   ├── DSA09018 - LIỆT KÊ ĐỈNH TRỤ.cpp
    │   ├── DSA09019 - KIỂM TRA CHU TRÌNH.cpp
    │   ├── DSA09020 - CHUYỂN DANH SÁCH KỀ SANG MA TRẬN KỀ.cpp
    │   ├── DSA09021 - CHUYỂN MA TRẬN KỀ SANG DANH SÁCH KỀ.cpp
    │   ├── DSA09022 - DFS TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
    │   ├── DSA09024 - BFS TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
    │   ├── DSA09025 - ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ CÓ HƯỚNG.cpp
    │   ├── DSA09026 - ĐƯỜNG ĐI THEO BFS TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
    │   ├── DSA09027 - KIỂM TRA ĐƯỜNG ĐI.cpp
    │   ├── DSA09028 - TÔ MÀU ĐỒ THỊ.cpp
    │   ├── DSA09029 - ĐƯỜNG ĐI HAMILTON.cpp
    │   ├── DSA09030 - ĐỒ THỊ HAI PHÍA.cpp
    │   ├── DSA09031 - CHÚ CỪU XA CÁCH.cpp
    │   ├── DSA09032 - KẾT BẠN.cpp
    │   ├── DSA09033 - MẠNG XÃ HỘI.cpp
    │   ├── DSA09034 - ĐẾM SỐ AO.cpp
    │   ├── DSA09037 - HỌP MẶT.cpp
    │   ├── DSA09049 - LAN TRUYỀN DINH DƯỠNG.cpp
    │   ├── DSA10001 - TÌM ĐƯỜNG.cpp
    │   ├── DSA10003 - KIỂM TRA CHU TRÌNH SỬ DỤNG DISJOIN SET.cpp
    │   ├── DSA10004 - ĐƯỜNG ĐI VÀ CHU TRÌNH EULER VỚI ĐỒ THỊ VÔ HƯỚNG.cpp
    │   ├── DSA10005 - CHU TRÌNH EULER TRONG ĐỒ THỊ CÓ HƯỚNG.cpp
    │   ├── DSA10006 - CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN DFS.cpp
    │   ├── DSA10007 - CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN BFS.cpp
    │   ├── DSA10008 - DIJKSTRA.cpp
    │   ├── DSA10009 - FLOYD.cpp
    │   ├── DSA10011 - DI CHUYỂN TRÊN BẢNG SỐ.cpp
    │   ├── DSA10012 - ĐƯỜNG ĐI TRUNG BÌNH.cpp
    │   ├── DSA10015 - KRUSKAL.cpp
    │   ├── DSA10016 - NỐI ĐIỂM.cpp
    │   ├── DSA10017 - CHU TRÌNH ÂM.cpp
    │   └── TN05009 - CHU TRÌNH THEO DFS.cpp
    ├── Greedy/
    │   ├── DSA03001 - ĐỔI TIỀN.cpp
    │   ├── DSA03002 - NHẦM CHỮ SỐ.cpp
    │   ├── DSA03003 - TÌM MAX.cpp
    │   ├── DSA03004 - TỔNG NHỎ NHẤT.cpp
    │   ├── DSA03005 - CHIA MẢNG THÀNH HAI MẢNG CON CÓ TỔNG LỚN NHẤT.cpp
    │   ├── DSA03006 - SẮP XẾP THAM LAM.cpp
    │   ├── DSA03007 - GIÁ TRỊ NHỎ NHẤT CỦA BIỂU THỨC.cpp
    │   ├── DSA03008 - SẮP XẾP CÔNG VIỆC 1.cpp
    │   ├── DSA03009 - SẮP XẾP CÔNG VIỆC 2.cpp
    │   ├── DSA03010 - NỐI DÂY 1.cpp
    │   ├── DSA03011 - NỐI DÂY 2.cpp
    │   ├── DSA03012 - SẮP ĐẶT XÂU KÝ TỰ 1.cpp
    │   ├── DSA03013 - SẮP ĐẶT XÂU KÝ TỰ 2.cpp
    │   ├── DSA03014 - SỐ KHỐI LẬP PHƯƠNG.cpp
    │   ├── DSA03015 - MUA LƯƠNG THỰC.cpp
    │   ├── DSA03016 - SỐ NHỎ NHẤT.cpp
    │   ├── DSA03017 - GIÁ TRỊ NHỎ NHẤT CỦA XÂU.cpp
    │   ├── DSA03018 - SỐ MAY MẮN.cpp
    │   ├── DSA03019 - PHÂN SỐ ĐƠN VỊ.cpp
    │   ├── DSA03020 - BIỂU THỨC ĐÚNG.cpp
    │   ├── DSA03021 - TÌM DÃY SỐ.cpp
    │   ├── DSA03022 - TÍCH LỚN NHẤT.cpp
    │   ├── DSA03023 - SẮP XẾP VIÊN BI.cpp
    │   ├── DSA03024 - LỰA CHỌN TỐI ƯU.cpp
    │   ├── DSA03025 - TRỤC TỌA ĐỘ.cpp
    │   ├── DSA03026 - LỰA CHỌN THAM LAM.cpp
    │   ├── DSA03027 - GIÁ TRỊ LỚN NHẤT.cpp
    │   ├── DSA03033 - ATM THẾ HỆ MỚI.cpp
    │   ├── DSA03034 - DÃY CON CHUNG.cpp
    │   └── DSA03035 - SẮP XẾP ĐƠN GIẢN.cpp
    ├── Linked list/
    │   ├── CTDL_005 - XÓA DỮ LIỆU TRONG DSLK ĐƠN.cpp
    │   ├── CTDL_006 - LỌC DỮ LIỆU TRÙNG TRONG DSLK ĐƠN.cpp
    │   └── DSA07018 - TỔNG ĐA THỨC.cpp
    ├── Queue/
    │   ├── DSA08001 - CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 1.cpp
    │   ├── DSA08002 - CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 2.cpp
    │   ├── DSA08003 - HÀNG ĐỢI HAI ĐẦU (DEQUEUE).cpp
    │   ├── DSA08004 - GIÁ TRỊ NHỎ NHẤT CỦA XÂU.cpp
    │   ├── DSA08005 - SỐ NHỊ PHÂN TỪ 1 ĐẾN N.cpp
    │   ├── DSA08006 - SỐ 0 VÀ SỐ 9.cpp
    │   ├── DSA08007 - SỐ BDN 1.cpp
    │   ├── DSA08008 - SỐ BDN 2.cpp
    │   ├── DSA08009 - BIẾN ĐỔI S – T.cpp
    │   ├── DSA08010 - BIẾN ĐỔI SỐ TỰ NHIÊN.cpp
    │   ├── DSA08011 - KHOẢNG CÁCH XÂU KÝ TỰ.cpp
    │   ├── DSA08012 - TÌM SỐ K THỎA MÃN ĐIỀU KIỆN.cpp
    │   ├── DSA08013 - DI CHUYỂN TRÁNH VẬT CẢN.cpp
    │   ├── DSA08014 - GIEO MẦM.cpp
    │   ├── DSA08015 - DI CHUYỂN TRONG KHÔNG GIAN.cpp
    │   ├── DSA08016 - HEXGAME.cpp
    │   ├── DSA08017 - SỐ LỘC PHÁT 1.cpp
    │   ├── DSA08018 - SỐ LỘC PHÁT 2.cpp
    │   ├── DSA08019 - SỐ LỘC PHÁT 3.cpp
    │   ├── DSA08020 - BIẾN ĐỔI SỐ NGUYÊN TỐ.cpp
    │   ├── DSA08021 - DI CHUYỂN TRONG MA TRẬN.cpp
    │   ├── DSA08022 - BỘI SỐ LỚN NHẤT CỦA 3.cpp
    │   ├── DSA08025 - QUÂN MÃ.cpp
    │   ├── DSA08029 - QUAY HÌNH VUÔNG.cpp
    │   └── DSA08045 - HÀNG RÀO.cpp
    ├── Sort and Search/
    │   ├── CTDL_005 - XÓA DỮ LIỆU TRONG DSLK ĐƠN.cpp
    │   ├── CTDL_006 - LỌC DỮ LIỆU TRÙNG TRONG DSLK ĐƠN.cpp
    │   ├── DSA06001 - SẮP XẾP XEN KẼ.cpp
    │   ├── DSA06002 - SẮP XẾP THEO GIÁ TRỊ TUYỆT ĐỐI.cpp
    │   ├── DSA06003 - ĐỔI CHỖ ÍT NHẤT.cpp
    │   ├── DSA06004 - HỢP VÀ GIAO CỦA HAI DÃY SỐ 1.cpp
    │   ├── DSA06005 - HỢP VÀ GIAO CỦA HAI DÃY SỐ 2.cpp
    │   ├── DSA06006 - SẮP XẾP [0 1 2].cpp
    │   ├── DSA06007 - SẮP XẾP DÃY CON LIÊN TỤC.cpp
    │   ├── DSA06008 - ĐẾM CẶP.cpp
    │   ├── DSA06009 - CẶP SỐ TỔNG BẰNG K.cpp
    │   ├── DSA06010 - SẮP XẾP CHỮ SỐ.cpp
    │   ├── DSA06011 - TỔNG GẦN 0 NHẤT.cpp
    │   ├── DSA06012 - PHẦN TỬ LỚN NHẤT.cpp
    │   ├── DSA06013 - SỐ LẦN XUẤT HIỆN.cpp
    │   ├── DSA06014 - TỔNG CẶP SỐ NGUYÊN TỐ.cpp
    │   ├── DSA06015 - MERGE SORT.cpp
    │   ├── DSA06016 - TÍCH LỚN NHẤT - NHỎ NHẤT.cpp
    │   ├── DSA06017 - TRỘN HAI DÃY.cpp
    │   ├── DSA06018 - BỔ SUNG PHẦN TỬ.cpp
    │   ├── DSA06019 - SẮP XẾP THEO SỐ LẦN XUẤT HIỆN.cpp
    │   ├── DSA06020 - TÌM KIẾM.cpp
    │   ├── DSA06021 - TÌM KIẾM TRONG DÃY SẮP XẾP VÒNG.cpp
    │   ├── DSA06022 - SỐ NHỎ NHẤT VÀ NHỎ THỨ HAI.cpp
    │   ├── DSA06023 - SẮP XẾP ĐỔI CHỖ TRỰC TIẾP.cpp
    │   ├── DSA06024 - SẮP XẾP CHỌN.cpp
    │   ├── DSA06025 - SẮP XẾP CHÈN.cpp
    │   ├── DSA06026 - SẮP XẾP NỔI BỌT.cpp
    │   ├── DSA06027 - SẮP XẾP ĐỔI CHỖ TRỰC TIẾP - LIỆT KÊ NGƯỢC.cpp
    │   ├── DSA06028 - SẮP XẾP CHỌN - LIỆT KÊ NGƯỢC.cpp
    │   ├── DSA06029 - SẮP XẾP CHÈN - LIỆT KÊ NGƯỢC.cpp
    │   ├── DSA06030 - SẮP XẾP NỔI BỌT - LIỆT KÊ NGƯỢC.cpp
    │   ├── DSA06031 - PHẦN TỬ LỚN NHẤT TRONG DÃY CON.cpp
    │   ├── DSA06032 - BỘ BA SỐ CÓ TỔNG NHỎ HƠN K.cpp
    │   ├── DSA06033 - KHOẢNG CÁCH XA NHẤT.cpp
    │   ├── DSA06034 - CẶP SỐ CÓ TỔNG BẰNG K.cpp
    │   ├── DSA06035 - DÃY TAM GIÁC DÀI NHẤT.cpp
    │   ├── DSA06036 - BỘ BA SỐ BẰNG K.cpp
    │   ├── DSA06037 - SẮP XẾP ĐOẠN CON.cpp
    │   ├── DSA06038 - CẶP SỐ.cpp
    │   ├── DSA06039 - SỐ ĐẦU TIÊN BỊ LẶP.cpp
    │   ├── DSA06040 - GIAO CỦA BA DÃY SỐ.cpp
    │   ├── DSA06041 - SỐ XUẤT HIỆN NHIỀU NHẤT.cpp
    │   ├── DSA06043 - ĐIỂM CÂN BẰNG.cpp
    │   ├── DSA06044 - SẮP XẾP CHẴN LẺ.cpp
    │   ├── DSA06045 - XÂU TỐT.cpp
    │   ├── DSA06046 - CHÊNH LỆCH NHỎ NHẤT.cpp
    │   ├── DSA06047 - BỘ BA SỐ PYTAGO.cpp
    │   ├── DSA06048 - SỐ LẦN QUAY VÒNG.cpp
    │   └── DSA06049 - ĐẾM CẶP.cpp
    ├── Stack/
    │   ├── DSA07001 - NGĂN XẾP 1.cpp
    │   ├── DSA07002 - NGĂN XẾP 2.cpp
    │   ├── DSA07003 - KIỂM TRA BIỂU THỨC SỐ HỌC.cpp
    │   ├── DSA07004 - ĐẾM SỐ DẤU NGOẶC ĐỔI CHIỀU.cpp
    │   ├── DSA07005 - BIỂU THỨC TƯƠNG ĐƯƠNG.cpp
    │   ├── DSA07006 - XÓA DẤU NGOẶC.cpp
    │   ├── DSA07007 - SO SÁNH BIỂU THỨC.cpp
    │   ├── DSA07008 - BIẾN ĐỔI TRUNG TỐ - HẬU TỐ.cpp
    │   ├── DSA07009 - BIẾN ĐỔI TIỀN TỐ - TRUNG TỐ.cpp
    │   ├── DSA07010 - BIẾN ĐỐI TIỀN TỐ - HẬU TỐ.cpp
    │   ├── DSA07011 - BIẾN ĐỔI HẬU TỐ - TIỀN TỐ.cpp
    │   ├── DSA07012 - BIẾN ĐỔI HẬU TỐ - TRUNG TỐ.cpp
    │   ├── DSA07013 - TÍNH GIÁ TRỊ BIỂU THỨC HẬU TỐ.cpp
    │   ├── DSA07014 - TÍNH GIÁ TRỊ BIỂU THỨC TIỀN TỐ.cpp
    │   ├── DSA07015 - TÍNH TOÁN GIÁ TRỊ BIỂU THỨC TRUNG TỐ.cpp
    │   ├── DSA07016 - BIỂU THỨC TĂNG GIẢM.cpp
    │   ├── DSA07017 - PHẦN TỬ BÊN PHẢI NHỎ HƠN.cpp
    │   ├── DSA07018 - TỔNG ĐA THỨC.cpp
    │   ├── DSA07019 - HÌNH CHỮ NHẬT LỚN NHẤT.cpp
    │   ├── DSA07021 - DÃY NGOẶC ĐÚNG DÀI NHẤT.cpp
    │   ├── DSA07022 - PHẦN TỬ CÓ SỐ LẦN XUẤT HIỆN NHIỀU HƠN BÊN PHẢI.cpp
    │   ├── DSA07023 - ĐẢO TỪ.cpp
    │   ├── DSA07024 - GHÉP VÁN GỖ.cpp
    │   ├── DSA07027 - PHẦN TỬ BÊN PHẢI ĐẦU TIÊN LỚN HƠN.cpp
    │   ├── DSA07028 - NHỊP CHỨNG KHOÁN.cpp
    │   ├── DSA07029 - GIẢI MÃ XÂU KÝ TỰ.cpp
    │   ├── DSA07030 - HÌNH CHỮ NHẬT 0-1.cpp
    │   ├── DSA07041 - BIỂU THỨC ĐÚNG DÀI NHẤT.cpp
    │   ├── DSA07045 - GÕ BÀN PHÍM.cpp
    │   ├── DSA07110 - KIỂM TRA DÃY NGOẶC ĐÚNG.cpp
    │   └── .DS_Store
    ├── Thực hành/
    │   ├── BIẾN ĐỔI DÃY SỐ.cpp
    │   ├── BIẾN ĐỔI VỀ XÂU ĐỐI XỨNG.cpp
    │   ├── BIỂU THỨC ĐÚNG.cpp
    │   ├── CHIA CẮT ĐỒ THỊ.cpp
    │   ├── CHÊNH LỆCH NHỎ NHẤT.cpp
    │   ├── DI CHUYỂN TRONG MÊ CUNG.cpp
    │   ├── DUYỆT CÂY THEO MỨC ĐẢO NGƯỢC.cpp
    │   ├── DÃY CON CÓ TỔNG BẰNG S.cpp
    │   ├── DÃY CON LIÊN TIẾP.cpp
    │   ├── DÃY CON TĂNG DẦN.cpp
    │   ├── DÃY SỐ ĐẸP.cpp
    │   ├── HOÁN VỊ NGƯỢC.cpp
    │   ├── HÌNH CHỮ NHẬT ĐƠN SẮC.cpp
    │   ├── KIỂM TRA CÂU VIẾT ĐÚNG QUY TẮC.cpp
    │   ├── KIỂM TRA LIÊN THÔNG MẠNH.cpp
    │   ├── LIÊN THÔNG MẠNH.cpp
    │   ├── LŨY THỪA BẬC K.cpp
    │   ├── LŨY THỪA MA TRẬN 4.cpp
    │   ├── LŨY THỪA MA TRẬN 5.cpp
    │   ├── LŨY THỪA MA TRẬN.cpp
    │   ├── MIN VÀ MAX.cpp
    │   ├── MÃ SỐ.cpp
    │   ├── NGƯỜI DU LỊCH.cpp
    │   ├── PHẦN TỬ LỚN NHẤT TRONG DÃY CON.cpp
    │   ├── QUÂN VUA TRÊN BÀN CỜ.cpp
    │   ├── SẮP XẾP CHẴN LẺ.cpp
    │   ├── SẮP XẾP QUÂN HẬU.cpp
    │   ├── SỐ 2 ƯU THẾ.cpp
    │   ├── SỐ CẶP BẠN TỐT.cpp
    │   ├── SỐ LƯỢNG DẤU NGOẶC VUÔNG LỚN NHẤT.cpp
    │   ├── SỐ LỘC PHÁT ĐỐI XỨNG CHẴN.cpp
    │   ├── SỐ LỘC PHÁT.cpp
    │   ├── SỐ MAY MẮN TIẾP THEO.cpp
    │   ├── SỐ NGUYÊN THỦY.cpp
    │   ├── SỐ THUẬN NGHỊCH.cpp
    │   ├── TRÒ CHƠI CARO "NGANG".cpp
    │   ├── TÍCH CHỮ SỐ.cpp
    │   ├── TỔ HỢP “NGƯỢC”.cpp
    │   ├── TỔNG CHỮ SỐ.cpp
    │   ├── TỔNG CÁC SỐ TỰ NHIÊN.cpp
    │   ├── TỔNG SỐ CÁCH DI CHUYỂN.cpp
    │   ├── TỔNG ƯỚC SỐ.cpp
    │   ├── XÂU AB.cpp
    │   ├── XÂU CON NHỎ NHẤT.cpp
    │   ├── ĐOẠN LIÊN TIẾP.cpp
    │   ├── ĐÁNH SỐ THỨ TỰ CẶP DẤU NGOẶC.cpp
    │   ├── ĐƯỜNG ĐI CÓ HƯỚNG.cpp
    │   ├── ĐẢO TỬ.cpp
    │   ├── ĐẾM SỐ VẬT CẢN TRÊN MÊ CUNG.cpp
    │   ├── ĐỈNH THẮT.cpp
    │   └── ĐỈNH TRỤ VÀ CẠNH CẦU.cpp
    ├── Tree/
    │   ├── DSA11001 - CÂY BIỂU THỨC 1.cpp
    │   ├── DSA11002 - CÂY BIỂU THỨC 2.cpp
    │   ├── DSA11003 - DUYỆT CÂY 1.cpp
    │   ├── DSA11004 - DUYỆT CÂY THEO MỨC.cpp
    │   ├── DSA11005 - DUYỆT CÂY 2.cpp
    │   ├── DSA11006 - DUYỆT CÂY KIỂU XOẮN ỐC.cpp
    │   ├── DSA11008 - KIỂM TRA NODE LÁ.cpp
    │   ├── DSA11010 - CÂY NHỊ PHÂN HOÀN HẢO.cpp
    │   ├── DSA11011 - CÂY NHỊ PHÂN ĐỦ.cpp
    │   ├── DSA11012 - CÂY NHỊ PHÂN BẰNG NHAU.cpp
    │   ├── DSA11014 - TỔNG NODE LÁ BÊN PHẢI.cpp
    │   ├── DSA11015 - TỔNG LỚN NHẤT.cpp
    │   ├── DSA11017 - DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 1.cpp
    │   ├── DSA11018 - XÂY DỰNG LẠI CÂY NHỊ PHÂN TÌM KIẾM.cpp
    │   ├── DSA11019 - DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 2.cpp
    │   ├── DSA11020 - KIỂM TRA CÂY NHỊ PHÂN TÌM KIẾM.cpp
    │   ├── DSA11021 - NODE LÁ CỦA CÂY NHỊ PHÂN TÌM KIẾM.cpp
    │   ├── DSA11022 - NODE TRUNG GIAN CỦA CÂY NHỊ PHÂN TÌM KIẾM.cpp
    │   ├── DSA11023 - ĐỘ SÂU CÂY NHỊ PHÂN TÌM KIẾM.cpp
    │   ├── DSA11024 - CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 1.cpp
    │   ├── DSA11025 - CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 2.cpp
    │   ├── DSA11026 - DUYỆT SAU CÂY TÌM KIẾM CÂN BẰNG.cpp
    │   ├── DSA11027 - ĐẾM SỐ NODE LÁ CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG.cpp
    │   ├── DSA11028 - ĐỘ CAO CỦA CÂY.cpp
    │   ├── DSA11029 - ĐƯỜNG ĐI TỚI NODE LÁ.cpp
    │   ├── DSA11030 - KHOẢNG CÁCH GIỮA HAI NODE.cpp
    │   └── DSAKT060 - TRUY VẤN ĐỐI XỨNG.cpp
    └── Đề bài/
        └── README.md

================================================
FILE: README.md
================================================
# Data_Structures_and_Algorithms_PTIT
Source code DSA on code.ptit.edu.vn
> Thấy hay thì đừng quên để lại 1 sao và 1 follow nhé 😉



================================================
FILE: Algorithms/DISJOIN SET UNION (DSU).cpp
================================================
// Cấu trúc dữ liệu Disjoin Set Union
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int Root[1005]; // Root[i]: Gốc của đỉnh i
int Size[1005]; // Size[i]: Số con của gốc i

// Tìm gốc
int findRoot(int x)
{
    if(x == Root[x])
        return x;
    return Root[x] = findRoot(Root[x]);
}

// Hợp 2 tập hợp
void Union(int x, int y)
{
    int rootX = findRoot(x), rootY = findRoot(y);
    if(rootX != rootY)
    {
        if(Size[rootX] < Size[rootY])
            swap(rootX, rootY);
        Root[rootY] = rootX;
        Size[rootX] += Size[rootY];
    }
}

int main()
{
    faster();
    int n;
    // Ban đầu khởi tạo gốc của đỉnh i là chính nó
    for(int i = 1; i <= n; ++i)
        Root[i] = i;
    return 0;
}



================================================
FILE: Algorithms/KOSARAJU ALGORITHM.cpp
================================================
// Thuật toán Kosaraju tìm số thành phần liên thông mạnh
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

// B1: DFS trên G => Lưu vào stack
// B2: Lấy các đỉnh trong stack lần lượt ra và DFS trên TG (Đảo chiều của G)
/* Đồ thị G có hướng:
     9
     1 2
     2 3
     3 4
     4 1
     3 5
     5 6
     6 7
     7 8
     8 6
*/

vector<int> a[100]; // Danh sách cạnh của G
vector<int> b[100]; // Danh sách cạnh của TG
stack<int> st;
bitset<100> bs;

void DFS(int x)
{
    bs[x] = 1;
    for(int i : a[x])
        if(!bs[i])
            DFS(i);
    st.push(x);
}

void DFS2(int x)
{
    cout << x << ' ';
    bs[x] = 1;
    for(int i : b[x])
        if(!bs[i])
            DFS2(i);
}

int main()
{
    faster();
    int n, x, y;
    cin >> n;
    while(n--)
    {
        cin >> x >> y;
        a[x].pb(y);
        b[y].pb(x);
    }
    DFS(1);
    bs.reset();
    // Tìm số thành phần liên thông mạnh
    while(st.sz)
    {
        if(!bs[st.top()])
        {
            DFS2(st.top());
            cout << endl;
        }
        st.pop();
    }
    return 0;
}



================================================
FILE: Algorithms/KRUSKAL ALGORITHM.cpp
================================================
// Thuật toán Kruskal tìm cây khung nhỏ nhất của đồ thị
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

/*
    Cho đồ thị vô hướng G, có V đỉnh và E cạnh. Xây dựng cây khung nhỏ nhất của đồ thị.

    B1: Nhập danh sách kề và sort theo trọng số tăng dần.
    B2: Sử dụng DSU kiểm tra xem nếu nối 2 cạnh đó vào cây khung hiện tại có tạo thành 1 chu trình hay không?
        - Nếu tạo thành 1 chu trình, bỏ qua.
        - Nếu không tạo thành 1 chu trình, ta thêm cạnh đó vào cây khung.
*/

int v, e;
int Root[105], Size[105];
vector<pair<pair<int, int>, int>> vp;
int val;

// Tìm gốc
inline int findRoot(int x)
{
    if(x == Root[x])
        return x;
    return Root[x] = findRoot(Root[x]);
}

inline void Union(int x, int y, pair<pair<int, int>, int> p)
{
    int rootX = findRoot(x), rootY = findRoot(y);
    if(rootX != rootY)
    {
        val += p.se;
        if(Size[rootX] < Size[rootY])
            swap(rootX, rootY);
        Root[rootY] = rootX;
        Size[rootX] += Size[rootY];
    }
}

inline bool cmp(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b)
{
    return a.se < b.se;
}

int main()
{
    faster();
    int x, y, z;
    cin >> v >> e;
    while(e--)
    {
        cin >> x >> y >> z;
        vp.pb({{x, y}, z});
    }
    sort(all(vp), cmp);
    val = 0;
    for(pair<pair<int, int>, int> &i : vp)
        Union(i.fi.fi, i.fi.se, i);
    cout << val;
    return 0;
}



================================================
FILE: Backtracking/DSA01024 - ĐẶT TÊN - 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
vector<string> vs, ans;
int b[35];

void print()
{
    for(int i = 1; i <= k; ++i) cout << vs[b[i] - 1] << ' ';
    cout << endl;
}

void Try(int i)
{
    for(int j = b[i - 1] + 1; j <= vs.sz - k + i; ++j)
    {
        b[i] = j;
        if(i == k) print();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        string s;
        map<string, bool> m;
        for(int i = 0; i < n; ++i)
        {
            cin >> s;
            m[s] = 1;
        }
        for(auto &i : m) vs.pb(i.fi);
        Try(1);
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02001 - DÃY SỐ 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        queue<int> q;
        for(int i = 0; i < n; ++i)
        {
            cin >> x;
            q.push(x);
        }
        for(int i = 1; i <= n; ++i)
        {
            cout << '[';
            for(int j = n - i; j >= 0; --j)
            {
                x = q.front();
                cout << x;
                if(j) cout << ' ';
                q.pop();
                x += q.front();
                if(j) q.push(x);
            }
            cout << "]\n";
        }
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02002 - DÃY SỐ 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        queue<int> q;
        stack<string> st;
        for(int i = 0; i < n; ++i)
        {
            cin >> x;
            q.push(x);
        }
        for(int i = 1; i <= n; ++i)
        {
            string s = "";
            s += '[';
            for(int j = n - i; j >= 0; --j)
            {
                x = q.front();
                s += to_string(x);
                if(j) s += ' ';
                q.pop();
                x += q.front();
                if(j) q.push(x);
            }
            s += "] ";
            st.push(s);
        }
        while(st.sz)
        {
            cout << st.top();
            st.pop();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02003 - DI CHUYỂN TRONG MÊ CUNG 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool a[25][25], check;
int n;
string s;
 
void Try(int i, int j)
{
    if(i == n && j == n)
    {
        cout << s << ' ';
        check = 1;
        return;
    }
    if(a[i+1][j])
    {
        s += 'D';
        Try(i + 1, j);
        s.erase(s.length() - 1, 1);
    }
    if(a[i][j+1])
    {
        s += 'R';
        Try(i, j + 1);
        s.erase(s.length() - 1, 1);
    }
}
 
int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        check = 0;
        cin >> n;
        FOR(i, 1, n) FOR(j, 1, n) cin >> a[i][j];
        if(!a[1][1]) cout << -1;
        else
        {
            Try(1, 1);
            if(!check) cout << -1;
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02004 - DI CHUYỂN TRONG MÊ CUNG 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
bool a[100][100];
bool check[100][100];
vector<string> res;

void Try(int i, int j, string s = "")
{
    if(!a[1][1] or !a[n][n]) return;
    if(i == n && j == n)
    {
        res.pb(s);
        return;
    }
    if(a[i + 1][j] and i != n and !check[i + 1][j])
    {
        check[i][j] = 1;
        Try(i + 1, j, s + "D");
        check[i][j] = 0;
    }
    if(a[i][j - 1] and j != 1 and !check[i][j - 1])
    {
        check[i][j] = 1;
        Try(i, j - 1, s + "L");
        check[i][j] = 0;
    }
    if(a[i][j + 1] and j != n and !check[i][j + 1])
    {
        check[i][j] = 1;
        Try(i, j + 1, s + "R");
        check[i][j] = 0;
    }
    if(a[i - 1][j] and i != 1 and !check[i - 1][j])
    {
        check[i][j] = 1;
        Try(i - 1, j, s + "U");
        check[i][j] = 0;
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        res.clear();
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                cin >> a[i][j];
                check[i][j] = 0;
            }
        }
        Try(1, 1);
        if(res.empty()) cout << -1 << endl;
        else
        {
            for(string &i : res) cout << i << ' ';
            cout << endl;
        }
    }
    return 0;
}




================================================
FILE: Backtracking/DSA02005 - HOÁN VỊ XÂU KÝ TỰ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int calc(int n)
{
    int res = 1;
    for(int i = 2; i <= n; ++i) res *= i;
    return res;
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        string s;
        cin >> s;
        int cnt = calc((int) s.sz);
        while(cnt--)
        {
            cout << s << ' ';
            next_permutation(all(s));
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02006 - DÃY CON TỔNG BẰNG K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
vector<int> v;
vector<bool> f;
vector<vector<bool>> ans;

void check()
{
    int sum = 0;
    for(int i = 1; i <= n; ++i) sum += v[i] * f[i];
    if(sum == k) ans.pb(f);
}

void Try(int i)
{
    for(int j = 1; j >= 0; --j)
    {
        f[i] = j;
        if(i == n) check();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        v.resize(n + 1);
        f.resize(n + 1);
        for(int i = 1; i <= n; ++i) cin >> v[i];
        sort(v.begin() + 1, v.end());
        Try(1);
        if(ans.empty())
        {
            cout << -1 << endl;
            continue;
        }
        for(vector<bool> &i : ans)
        {
            cout << '[';
            vi tmp;
            for(int j = 1; j <= n; ++j) if(i[j]) tmp.pb(v[j]);
            for(int j = 0; j < tmp.sz - 1; ++j) cout << tmp[j] << ' ';
            cout << tmp.back();
            cout << "] ";
        }
        cout << endl;
        ans.clear();
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02007 - ĐỔI CHỖ CÁC CHỮ SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string s;
int k;

void findMax(string &res, int cnt)
{
    if(!k) return;
    char tmp = s[cnt];
    F(i, cnt, s.length()) if(tmp < s[i]) tmp = s[i];
    if(tmp != s[cnt]) --k;
    FORD(i, s.length() - 1, cnt)
    {
        if (s[i] == tmp)
        {
            swap(s[cnt], s[i]);
            if(s.compare(res) > 0) res = s;
            findMax(res, cnt + 1);
            swap(s[cnt], s[i]);
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> k >> s;
        string res = s;
        findMax(res, 0);
        cout << res << endl;
    }
    return 0;
}





================================================
FILE: Backtracking/DSA02009 - CHIA MẢNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k, a[25], sum;
bool check;

void Try(int cnt = 0, int cur = 0)
{
    if(check) return;
    if(cnt == k)
    {
        check = 1;
        return;
    }
    for(int j = 1; j <= n; ++j)
    {
        if(cur == sum) Try(cnt + 1);
        else
        {
            if(cur > sum) return;
            Try(cnt, cur + a[j]);
        }
    }
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        sum = 0;
        cin >> n >> k;
        for(int i = 1; i <= n; ++i)
        {
            cin >> a[i];
            sum += a[i];
        }
        if(sum % k) cout << 0 << endl;
        else
        {
            sum /= k;
            check = 0;
            Try();
            cout << check << endl;
        }
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02010 - TỔ HỢP SỐ CÓ TỔNG BẰNG X.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check;
vector<int> res;
int n, sum;

void Try(vector<int> &a, int i = 0, int cur = 0)
{
    if(cur > sum) return;
    if(cur == sum)
    {
        check = 1;
        cout << "[";
        int s = res.sz - 1;
        for(int j = 0; j < s; ++j) cout << res[j] << ' ';
        cout << res.back() << "]";
        return;
    }
    for(int j = i; j < a.sz; ++j)
    {
        res.pb(a[j]);
        Try(a, j, cur + a[j]);
        res.pop_back();
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        check = 0;
        cin >> n >> sum;
        vector<int> a(n);
        for(int i = 0; i < n; i++) cin >> a[i];
        sort(a.begin(), a.end());
        Try(a);
        if(!check) cout << -1;
        cout << endl;
        res.clear();
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02011 - MÁY ATM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int b[35], n, s;
bool flag;

void Try(int i, int cur = 0, int cnt = 0)
{
    if(flag) return;
    if(cur > s) return;
    if(cur == s)
    {
        flag = 1;
        cout << cnt << endl;
        return;
    }
    for(int j = i; j <= n; ++j) Try(j + 1, cur + b[j], cnt + 1);
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> s;
        for(int i = 1; i <= n; ++i) cin >> b[i];
        sort(b + 1, b + 1 + n, greater<ll>());
        flag = 0;
        Try(1);
        if(!flag) cout << -1 << endl;
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02012 - DI CHUYỂN TRONG MA TRẬN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int cnt, n, m;
int a[105][105];

void Try(int i, int j)
{
    if(i == n && j == m) ++cnt;
    if(i < n) Try(i + 1, j);
    if(j < m) Try(i, j + 1);
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                cin >> a[i][j];
        cnt = 0;
        Try(1, 1);
        cout << cnt << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02013 - SỐ NGUYÊN TỐ.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool notPrime[205] = {};
int N = 200, n, s, p, st;
vi prime, tmp;
vector<vector<int>> res;

void sieve()
{
    int sqr = sqrt(N);
    for(int i = 2; i <= sqr; ++i)
        if(!notPrime[i])
            for(int j = i * i; j <= N; j += i)
                notPrime[j] = 1;
    for(int i = 2; i <= N; ++i) if(!notPrime[i]) prime.pb(i);
}

void Try(int i, int sum = 0)
{
    if(sum > s) return;
    if(sum == s)
    {
        if(tmp.sz == n) res.pb(tmp);
        return;
    }
    for(int j = i; j < prime.sz; ++j)
    {
        tmp.pb(prime[j]);
        Try(j + 1, sum + prime[j]);
        tmp.pop_back();
    }
}

int main()
{
    faster();
    sieve();
    int t;
    cin >> t;
    while(t--)
    {
        cin >> n >> p >> s;
        st = upper_bound(all(prime), p) - prime.begin();
        Try(st);
        cout << res.sz << endl;
        for(vector<int> &i : res)
        {
            for(int &j : i) cout << j << ' ';
            cout << endl;
        }
        tmp.clear();
        res.clear();
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02014 - TỪ ĐIỂN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<string> res;
set<string> dic;
vector<bitset<10>> f;
vector<vector<string>> a;
int k, n, m;
int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};
string tmp;

void DFS(int i, int j, string s)
{
    if(dic.find(s) != dic.end()) res.pb(s);
    for(int x = 0; x < 8; ++x)
    {
        int u = i + dx[x];
        int v = j + dy[x];
        if (u >= 0 and u < n and v >= 0 and v < m and !f[u][v])
        {
            f[u][v] = 1;
            DFS(u, v, s + a[u][v]);
            f[u][v] = 0;
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> k >> n >> m;
        a.resize(n, vector<string> (m));
        for(int i = 0; i < k; ++i)
        {
            cin >> tmp;
            dic.insert(tmp);
        }
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
                cin >> a[i][j];
        for(int i = 0; i < n; i++)
            for(int j = 0; j < m; j++)
            {
                f.clear();
                f.resize(n);
                f[i][j] = 1;
                DFS(i, j, "" + a[i][j]);
            }
        if(res.empty()) cout << -1;
        else for(string &s : res) cout << s << ' ';
        cout << endl;
        dic.clear();
        res.clear();
        a.clear();
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02015 - LOẠI BỎ DẤU NGOẶC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check(string s)
{
    if(s.empty()) return 0;
    if(s.sz == 1 && isalpha(s[0])) return 0;
    int cnt = 0;
    for(char i : s)
    {
        if(i == '(') ++cnt;
        else if(i == ')') --cnt;
        if(cnt < 0) return 0;
    }
    return !cnt;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s, tmp;
    cin.ignore();
    while(t--)
    {
        cin >> s;
        vector<string> ans;
        unordered_map<string, bool> m;
        queue<string> q;
        m[s] = 1;
        q.push(s);
        bool ok = 0;
        while(q.sz)
        {
            string s = q.front();
            q.pop();
            if(check(s))
            {
                ans.pb(s);
                ok = 1;
            }
            if(ok) continue;
            for(int i = 0; i < s.sz; ++i)
            {
                if(isalnum(s[i])) continue;
                tmp = s.substr(0, i) + s.substr(i + 1);
                if(!m[tmp])
                {
                    m[tmp] = 1;
                    q.push(tmp);
                }
            }
        }
        if(!ok) cout << -1;
        else
        {
            sort(all(ans));
            for(string i : ans) cout << i << ' ';
        }
        cout << endl;
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02016 - SẮP XẾP QUÂN HẬU 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, x[20], cnt;
bool col[100], a[100], b[100];

void Try(int i)
{
    for(int j = 1; j < n + 1; ++j)
    {
        if(!col[j] and !a[i - j + n] and !b[i + j -1])
        {
            col[j] = 1;
            a[i - j + n] = 1;
            b[i + j - 1] = 1;
            if (i == n) ++cnt;
            else Try(i + 1);
            col[j] = 0;
            a[i - j + n] = 0;
            b[i + j - 1] = 0;
        }
    }
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cnt = 0;
        Try(1);
        cout << cnt << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02017 - SẮP XẾP QUÂN HẬU 2.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int ans, n = 8;
bitset<16> x, y;
bitset<9> f;
vector<vi> a(9, vi (9));

void Try(int i, int sum = 0)
{
    if(i > n)
    {
        ans = max(ans, sum);
        return;
    }
    for(int j = 1; j <= n; ++j)
        if(!f[j] and !x[j + i - 1] and !y[j - i + n])
        {
            f[j] = 1;
            x[j + i - 1] = 1;
            y[j - i + n] = 1;
            Try(i + 1, sum + a[i][j]);
            f[j] = 0;
            x[j + i - 1] = 0;
            y[j - i + n] = 0;
        }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        ans = 0;
        for(int i = 1; i <= 8; i++)
            for(int j = 1; j <= 8; j++)
                cin >> a[i][j];
        Try(1);
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02018 - BIỂU THỨC TOÁN HỌC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vi a = {0, 1, 2, 3, 4}, x(4);
int b[5];
vector<vector<int>> v1, v2;

void backtrack(int i = 0)
{
    for(int j = 0; j < 3; ++j)
    {
        x[i] = j;
        if(i == 3) v2.pb(x);
        else backtrack(i + 1);
    }
}

string solve()
{
    for(vector<int> &i : v1)
    {
        for(vector<int> &j : v2)
        {
            int res = b[i[0]];
            for(int z = 1; z < 5; ++z)
            {
                if(j[z - 1] == 0) res += b[i[z]];
                else if(j[z - 1] == 1) res -= b[i[z]];
                else res *= b[i[z]];
            }
            if(res == 23) return "YES\n";
        }
    }
    return "NO\n";
}

int main()
{
    faster();
    v1.pb(a);
    while(next_permutation(all(a))) v1.pb(a);
    backtrack();
    int t = 1;
    cin >> t;
    while(t--)
    {
        for(int i = 0; i < 5; ++i) cin >> b[i];
        cout << solve();
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02019 - ĐƯỜNG ĐI DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m, res = 0;
vector<vector<bool>> x;

void Try(int u, int sum = 0)
{
    res = max (res, sum);
    for(int v = 0; v < n; v++)
        if (x[u][v] == 1)
        {
            x[u][v] = x[v][u] = 0;
            Try(v, sum + 1);
            x[u][v] = x[v][u] = 1;
        }
}

int main()
{
    faster();
    int t = 1, a, b;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        x.resize(n + 5, vector<bool> (n + 5));
        res = 0;
        for(int i = 0; i < m; i++)
        {
            cin >> a >> b;
            x[a][b] = x[b][a] = 1;
        }
        for(int i = 1; i < n; i++) Try(i);
        cout << res << endl;
        x.clear();
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02020 - SỐ NHỎ NHẤT CÓ N ƯỚC SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll prime[] = {2, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31}, ans;
int n;

void Try(int i, ll a = 1, ll b = 1)
{
    if(b > n) return;
    if(b == n) ans = min(ans, a);
    ll j = 1;
    while(a * prime[i] <= ans)
    {
        a *= prime[i];
        Try(i + 1, a, b * (j + 1));
        ++j;
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ans = 1e18;
        Try(1);
        cout << ans << endl;
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02021 - KÝ TỰ ĐẶC BIỆT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    ll n, x, tmp;
    string s;
    while(t--)
    {
        cin >> s >> n;
        x = s.sz;
        while (x < n) x <<= 1;
        while(x > s.sz)
        {
            tmp = x >> 1;
            if(n > tmp)
            {
                n -= tmp;
                --n;
                if(!n) n = tmp;
            }
            x >>= 1;
        }
        cout << s[n - 1] << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02022 - NGÀY ĐẶC BIỆT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string s = "2000";
char a[2] = {'0', '2'};
vector<string> d, m, y;

void Try(int i)
{
    for(int j = 0; j < 2; ++j)
    {
        s[i] = a[j];
        if(i == 3) y.pb(s);
        else Try(i + 1);
    }
}

int main()
{
    faster();
    d.pb("02");
    d.pb("20");
    d.pb("22");
    m.pb("02");
    Try(1);
    for(string &i : d) for(string &j : y) cout << i << "/02/" << j << endl;
    return 0;
}




================================================
FILE: Backtracking/DSA02023 - ĐẶT TÊN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
vector<string> vs, ans;
int b[35];

void print()
{
    for(int i = 1; i <= k; ++i) cout << vs[b[i] - 1] << ' ';
    cout << endl;
}

void Try(int i)
{
    for(int j = b[i - 1] + 1; j <= vs.sz - k + i; ++j)
    {
        b[i] = j;
        if(i == k) print();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        string s;
        map<string, bool> m;
        for(int i = 0; i < n; ++i)
        {
            cin >> s;
            m[s] = 1;
        }
        for(auto &i : m) vs.pb(i.fi);
        Try(1);
    }
    return 0;
}





================================================
FILE: Backtracking/DSA02024 - DÃY CON TĂNG DẦN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
int a[35] = {};
vector<string> vs;
vector<int> tmp;

inline void print()
{
    string s = "";
    for(int &i : tmp) s += to_string(i) + ' ';
    vs.pb(s);
}

inline void Try(int i)
{
    for(int j = i + 1; j <= n; ++j)
    {
        if(a[j] > a[i])
        {
            tmp.pb(a[j]);
            if(tmp.sz > 1) print();
            Try(j);
            tmp.pop_back();
        }
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 1; i <= n; ++i) cin >> a[i];
        Try(0);
        sort(all(vs));
        for(string &i : vs) cout << i << endl;
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02025 - KÝ TỰ LẶP.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, cx[35], x[35], f[35][35] = {}, res = 1e9;
string s[35];
int p[125] = {};

void Update()
{
    int tmp = 0;
    FOR(i, 2, n) tmp += f[x[i - 1]][x[i]];
    if(res > tmp) res = tmp;
}

int count(string a,string b)
{
    memset(p, 0, sizeof(p));
    for(int i = 0; i < a.sz; ++i) ++p[a[i]];
    for(int i = 0; i < b.sz; ++i) ++p[b[i]];
    int d = 0;
    for(int i = 'A'; i <= 'Z'; ++i) d += p[i] > 1;
    return d;
}

void Try(int i)
{
    for(int j = 1; j <= n; ++j)
    {
        if (cx[j])
        {
            x[i] = j;
            cx[j] = 0;
            if (i == n) Update();
            else Try(i + 1);
            cx[j] = 1;
        }
    }
}

int main()
{
    faster();
    cin >> n;
    for(int i = 1; i <= n; ++i)
    {
        cin >> s[i];
        cx[i] = 1;
    }
    for(int i = 1; i <= n; ++i)
    {
        for(int j = i + 1; j <= n; ++j)
        {
            f[i][j] = count(s[i], s[j]);
            f[j][i] = f[i][j];
        }
    }
    Try(1);
    cout << res;
    return 0;
}



================================================
FILE: Backtracking/DSA02026 - PHÉP TOÁN CƠ BẢN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string ans;
char sign[] = {'+', '-'};
bool ok;

bool check(string &s)
{
    int a = stoi(s.substr(0, 2)), b = stoi(s.substr(5, 2)), check;
    if (s[3] == '+') check = a + b;
    else check = a - b;
    string tmp = to_string(check);
    string c = s.substr(10, 2);
    return tmp == c;
}

void Try(int i, string s)
{
    if(ok) return;
    if(i == s.sz)
    {
        if(check(s))
        {
            ans = s;
            ok = 1;
        }
        return;
    }
    if(s[i] != '?')
    {
        if(!ok) Try(i + 1, s);
        return;
    }
    if(i == 3)
    {
        for (char j : sign)
        {
            s[i] = j;
            if(!ok) Try(i + 1, s);
        }
    }
    else if(!i or i == 5 or i == 10)
    {
        for (char j = '1'; j <= '9'; ++j)
        {
            s[i] = j;
            if(!ok) Try(i + 1, s);
        }
    }
    else
    {
        for(char j = '0'; j <= '9'; ++j)
        {
            s[i] = j;
            if(!ok) Try(i + 1, s);
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    cin.ignore();
    while(t--)
    {
        ok = 0;
        ans = "";
        getline(cin, s);
        if (s[3] == '*' or s[3] == '/')
        {
            cout << "WRONG PROBLEM!\n";
            continue;
        }
        Try(0, s);
        if (ans.empty()) cout << "WRONG PROBLEM!\n";
        else cout << ans << endl;
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02027 - NGƯỜI DU LỊCH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[20][20], n, res = INT_MAX;
bool dd[20] = {};

void Try(int i, int sum = 0, int cnt = 1)
{
    if(sum > res) return;
    if(cnt == n)
    {
        res = min(res, sum + a[i][1]);
        return;
    }
    for(int j = 1; j <= n; ++j)
    {
        if(!dd[j])
        {
            dd[j] = 1;
            Try(j, sum + a[i][j], cnt + 1);
            dd[j] = 0;
        }
    }
}

int main()
{
    faster();
    cin >> n;
    for(int i = 1; i <= n; ++i) for(int j = 1; j <= n; ++j) cin >> a[i][j];
    dd[1] = 1;
    Try(1);
    cout << res;
    return 0;
}



================================================
FILE: Backtracking/DSA02028 - CHIA ĐỀU.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
int a[15], check, res = 0;
vi sum(15);

void Try(int i, int cnt = 0)
{
    if(cnt == k)
    {
        res += i == n;
        return;
    }
    for(int j = i + 1; j <= n; ++j) if(sum[j] - sum[i] == check) Try(j, cnt + 1);
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        for(int i = 1; i <= n; ++i)
        {
            cin >> check;
            sum[i] = sum[i - 1] + check;
        }
        if(sum[n] % k) return cout << 0, 0;
        check = sum[n] / k;
        Try(0);
        cout << res;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02029 - THÁP HÀ NỘI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

void Try(int n, char a, char b, char c)
{
    if(n==1)
    {
        cout << a << " -> " << c << endl;
        return;
    }
    Try(n - 1, a, c, b);
    Try(1, a, b, c);
    Try(n - 1, b, a, c);
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        Try(n, 'A', 'B', 'C');
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02030 - LIỆT KÊ XÂU KÝ TỰ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int k;
char n;

void Try(int i, string s = "", char c = 'A')
{
    if(i == k)
    {
        cout << s << endl;
        return;
    }
    for(char j = c; j <= n; ++j) Try(i + 1, s + j, j);
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        Try(0);
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02031 - GHÉP CHỮ CÁI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check(char c)
{
    return (c == 'A' or c == 'E');
}

bool ok(string s)
{
    for(int i = 0; i < s.sz; ++i)
    {
        if(check(s[i]))
        {
            if(i == 0 or i == s.sz - 1) continue;
            if(!check(s[i - 1]) and !check(s[i + 1])) return 0;
        }
    }
    return 1;
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        string s = "ABC";
        char c;
        cin >> c;
        for(char j = 'D'; j <= c; ++j) s += j;
        do
        {
            if(ok(s)) cout << s << endl;
        }
        while(next_permutation(all(s)));
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02032 - TỔ HỢP SỐ CÓ TỔNG BẰNG X.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check;
vector<int> res;
int n, sum;
vector<string> ans;

void Try(vector<int> &a, int i = 0, int cur = 0)
{
    if(cur > sum) return;
    if(cur == sum)
    {
        check = 1;
        string s = "{";
        int size = res.sz - 1;
        for(int j = 0; j < size; ++j) s += to_string(res[j]) + ' ';
        s += to_string(res.back()) + "}";
        ans.pb(s);
        return;
    }
    for(int j = i; j < a.sz; ++j)
    {
        res.pb(a[j]);
        Try(a, j, cur + a[j]);
        res.pop_back();
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        check = 0;
        cin >> n >> sum;
        vector<int> a(n);
        for(int i = 0; i < n; i++) cin >> a[i];
        sort(a.begin(), a.end());
        Try(a);
        if(!check)
        {
            cout << -1 << endl;
            continue;
        }
        cout << ans.sz << ' ';
        for(string &i : ans) cout << i << ' ';
        cout << endl;
        res.clear();
        ans.clear();
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02033 - SỐ XA CÁCH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check(vi &a, int n)
{
    for(int i = 2; i <= n; ++i) if(abs(a[i] - a[i - 1]) == 1) return 0;
    return 1;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        if(n < 4)
        {
            cout << endl;
            continue;
        }
        vi a(n + 1);
        for(int i = 1; i <= n; ++i) a[i] = i;
        while(next_permutation(a.begin() + 1, a.end()))
        {
            if(check(a, n))
            {
                for(int i = 1; i <= n; ++i) cout << a[i];
                cout << endl;
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02034 - TRÒ CHƠI VỚI CÁC CON SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check(vi &a, int n)
{
    for(int i = 2; i <= n; ++i) if(abs(a[i] - a[i - 1]) == 1) return 0;
    return 1;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        if(n < 4)
        {
            cout << endl;
            continue;
        }
        vi a(n + 1);
        for(int i = 1; i <= n; ++i) a[i] = i;
        while(next_permutation(a.begin() + 1, a.end()))
        {
            if(check(a, n))
            {
                for(int i = 1; i <= n; ++i) cout << a[i];
                cout << endl;
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02035 - HOÁN VỊ CÁC CHỮ SỐ.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int calc(vector<string> &vs, vi &a)
{
    int m = INT_MAX, M = INT_MIN, tmp;
    string s;
    for(string &i : vs)
    {
        s = "";
        for(int &j : a) s += i[j];
        tmp = stoi(s);
        m = min(m, tmp);
        M = max(M, tmp);
    }
    return M - m;
}

int main()
{
    faster();
    int t = 1, n, k;
    //cin >> t;
    string s;
    while(t--)
    {
        int res = INT_MAX;
        cin >> n >> k;
        vector<string> vs;
        while(cin >> s) vs.pb(s);
        vi a;
        for(int i = 0; i < k; ++i) a.pb(i);
        do
        {
            res = min(res, calc(vs, a));
        }
        while(next_permutation(all(a)));
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02036 - DÃY CON CÓ TỔNG LẺ.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
int a[20];
vector<vector<int>> res;
vi v;

void Try(int i, int sum = 0)
{
    if(sum & 1) res.pb(v);
    if(i > n) return;
    for(int j = i; j <= n; ++j)
    {
        v.pb(a[j]);
        Try(j + 1, sum + a[j]);
        v.pop_back();
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 1; i <= n; ++i) cin >> a[i];
        sort(a + 1, a + n + 1, greater<int>());
        Try(1);
        sort(all(res));
        for(vector<int> &i : res)
        {
            for(int &j : i) cout << j << ' ';
            cout << endl;
        }
        v.clear();
        res.clear();
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02037 - DÃY CON CÓ TỔNG NGUYÊN TỐ.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool notPrime[1505];
int N = 1500, sqr = sqrt(N), n;
int a[20];
vector<vector<int>> res;
vi v;

inline void Try(int i, int sum = 0)
{
    if(!notPrime[sum]) res.pb(v);
    if(i > n) return;
    for(int j = i; j <= n; ++j)
    {
        v.pb(a[j]);
        Try(j + 1, sum + a[j]);
        v.pop_back();
    }
}

int main()
{
    faster();
    notPrime[0] = notPrime[1] = 1;
    for(int i = 2; i <= sqr; ++i)
        if(!notPrime[i])
            for(int j = i * i; j <= N; j += i)
                notPrime[j] = 1;
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 1; i <= n; ++i) cin >> a[i];
        sort(a + 1, a + 1 + n, greater<int>());
        Try(1);
        vector<string> vs;
        sort(all(res));
        for(auto &i : res)
        {
            for(int &j : i) cout << j << ' ';
            cout << endl;
        }
        v.clear();
        res.clear();
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02038 - DÃY CON CÓ K PHẦN TỬ TĂNG DẦN.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
int a[20], x[20];

void print()
{
    for(int i = 1; i <= k; ++i) cout << x[a[i]] << ' ';
    cout << endl;
}

void Try(int i)
{
    for(int j = a[i - 1] + 1; j <= n - k + i; ++j)
    {
        a[i] = j;
        if(i == k) print();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        for(int i = 1; i <= n; ++i) cin >> x[i];
        sort(x + 1, x + 1 + n);
        Try(1);
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02039 - PHÂN TÍCH SỐ 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

void push(vector<int> &v1, vector<string> &ans)
{
    vi v = v1;
    sort(v.begin(), v.end(), greater<int>());
    string s = "(";
    int size = v.sz - 1;
    F(i, 0, size)
    {
        s += to_string(v[i]);
        s += " ";
    }
    s += to_string(v[size]) + ")";
    ans.pb(s);
}

void Try(vi &v, int i, int n, vector<string> &ans)
{
    if (!n) push(v, ans);
    for (int j = n; j >= i; --j)
    {
        v.push_back(j);
        Try(v, j, n - j, ans);
        v.pop_back();
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi v;
        vector<string> ans;
        Try(v, 1, n, ans);
        sort(ans.begin(), ans.end(), greater<string>());
        cout << ans.sz << endl;
        if(n == 10)
        {
            cout << "(10) ";
            ans.erase(ans.begin() + 40);
        }
        for(string i : ans) cout << i << ' ';
        cout << endl;
    }
    return 0;
}


================================================
FILE: Backtracking/DSA02041 - BIẾN ĐỔI VỀ 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int BFS(int n)
{
    queue<pair<int, int>> q;
    q.push({n, 0});
    int f, s;
    while(q.sz)
    {
        f = q.front().fi;
        s = q.front().se;
        q.pop();
        if(f == 1) return s;
        if(f % 3 == 0) q.push({f / 3, s + 1});
        if((f & 1) ^ 1) q.push({f >> 1, s + 1});
        q.push({f - 1, s + 1});
    }
    return 0;
}

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << BFS(n) << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA02045 - TẬP CON CỦA XÂU KÝ TỰ.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
string s;
char a[20];
bool check[20];

void print(int j)
{
    for(int i = 1; i <= j; ++i) cout << a[i];
    cout << ' ';
}

void Try(int i, int cnt = 1)
{
    for(int j = i; j <= n; ++j)
    {
        a[cnt] = s[j];
        if(!check[j])
        {
            check[j] = 1;
            print(cnt);
            Try(j + 1, cnt + 1);
            check[j] = 0;
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        memset(check, 0, 20);
        cin >> n >> s;
        s = "0" + s;
        Try(1);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Backtracking/DSA05009 - TẬP CON BẰNG NHAU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
int a[105];
int sum;
bool check;

void Try(int i, int cur = 0)
{
    if(check) return;
    if(cur == sum)
    {
        check = 1;
        cout << "YES\n";
        return;
    }
    if(cur > sum) return;
    for(int j = i; j <= n; ++j) Try(j + 1, cur + a[j]);
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        sum = 0;
        check = 0;
        for(int i = 1; i <= n; ++i)
        {
            cin >> a[i];
            sum += a[i];
        }
        if(sum & 1) cout << "NO\n";
        else
        {
            sum >>= 1;
            Try(1);
            if(!check) cout << "NO\n";
        }
    }
    return 0;
}



================================================
FILE: Backtracking/DSAKT012 - ĐỔI TIỀN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int b[35], n, s;
bool flag;

void Try(int i, int cur = 0, int cnt = 0)
{
    if(flag) return;
    if(cur > s) return;
    if(cur == s)
    {
        flag = 1;
        cout << cnt << endl;
        return;
    }
    for(int j = i; j <= n; ++j) Try(j + 1, cur + b[j], cnt + 1);
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> s;
        for(int i = 1; i <= n; ++i) cin >> b[i];
        sort(b + 1, b + 1 + n, greater<ll>());
        flag = 0;
        Try(1);
        if(!flag) cout << -1 << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04001 - LŨY THỪA.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline ll rev(ll n)
{
    ll res = 0;
    while(n)
    {
        res = res * 10 + n % 10;
        n /= 10;
    }
    return res;
}

const ll mod = 1e9 + 7;

inline ll binPow(ll n, ll p)
{
    if(p == 1) return n;
    ll res = binPow(n, p >> 1) % mod;
    res = (res * res) % mod;
    if(p & 1) res = (res * n) % mod;
    return res % mod;
}

int main()
{
    faster();
    int t = 1;
    ll n, p;
    cin >> t;
    while(t--)
    {
        cin >> n >> p;
        cout << binPow(n, p) << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04002 - LŨY THỪA ĐẢO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline ll rev(ll n)
{
    ll res = 0;
    while(n)
    {
        res = res * 10 + n % 10;
        n /= 10;
    }
    return res;
}

const ll mod = 1e9 + 7;

inline ll binPow(ll n, ll p)
{
    if(p == 1) return n;
    ll res = binPow(n, p >> 1) % mod;
    res = (res * res) % mod;
    if(p & 1) res = (res * n) % mod;
    return res % mod;
}

int main()
{
    faster();
    int t = 1;
    ll n, p;
    cin >> t;
    while(t--)
    {
        cin >> n;
        p = rev(n);
        cout << binPow(n, p) << endl;
    }
    return 0;
}


================================================
FILE: Divide and Conquer/DSA04003 - ĐẾM DÃY.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int mod = 123456789;

inline ll calc(ll n)
{
    if(n == 1) return 1;
    long long x = calc(n >> 1) % mod;
    if(n & 1) return (((x * x % mod) << 2) % mod) % mod;
    return (((x * x % mod) << 1) % mod) % mod;
}

int main()
{
    faster();
    int t = 1;
    ll n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << calc(n) << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04004 - GẤP ĐÔI DÃY SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline ll binPow(ll a, ll b)
{
    if(!b) return 1;
    ll res = binPow(2, b >> 1);
    res = res * res;
    if(b & 1) res = res << 1;
    return res;
}

inline ll findNum(ll n, ll k)
{
    ll x = binPow(2, n - 1);
    if(k == x) return n;
    if(k < x) return findNum(n - 1, k);
    return findNum(n - 1, k - x);
}

int main()
{
    faster();
    int t = 1;
    ll n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        cout << findNum(n, k) << endl;
    }
    return 0;
}

// Cách 2:

// #include <stdio.h>

// int main()
// {
//     int t, n;
//     long long k, cnt;
//     scanf("%d", &t);
//     while(t--)
//     {
//         scanf("%d", &n);
//         scanf("%lld", &k);
//         cnt = 0;
//         while((k & 1) ^ 1)
//         {
//             ++cnt;
//             k >>= 1;
//         }
//         printf("%lld\n", cnt + 1);
//     }
//     return 0;
// }



================================================
FILE: Divide and Conquer/DSA04005 - DÃY XÂU FIBONACI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    ll f[93];
    f[1] = f[2] = 1;
    for(int i = 3; i <= 92; ++i) f[i] = f[i - 1] + f[i - 2];
    int t = 1;
    ll n, k;
    string s = "AAB";
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        while(n > 2)
        {
            if(k <= f[n - 2]) n -= 2;
            else
            {
                k -= f[n - 2];
                --n;
            }
        }
        cout << s[n] << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04006 - ĐẾM SỐ BÍT 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll a[55];

inline int Find(int idx, ll n, ll i)
{
    if(idx == 1) return n & 1;
    ll tmp = a[idx - 1];
    if(i == tmp + 1) return n & 1;
    if(i < tmp + 1) return Find(idx - 1, n >> 1, i);
    return Find(idx - 1, n >> 1, i - tmp - 1);
}

int main()
{
    faster();
    int t = 1;
    ll n, l, r, tmp;
    cin >> t;
    while(t--)
    {
        cin >> n >> l >> r;
        memset(a, 0, sizeof(a));
        a[1] = 1;
        tmp = n;
        n >>= 1;
        int idx = 2;
        while(n > 0)
        {
            a[idx] = (a[idx - 1] << 1) + 1;
            n >>= 1;
            ++idx;
        }
        --idx;
        ll res = 0;
        for(ll i = l; i <= r; ++i) res += Find(idx, tmp, i);
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04007 - HỆ CƠ SỐ K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int cv(string &s, int &k)
{
    int res = 0;
    for(char &i : s) res = res * k + (i - '0');
    return res;
}

int main()
{
    faster();
    int t = 1, k;
    cin >> t;
    string a, b;
    while(t--)
    {
        cin >> k >> a >> b;
        int res = cv(a, k) + cv(b, k);
        stack<int> st;
        while(res)
        {
            st.push(res % k);
            res /= k;
        }
        while(st.sz)
        {
            cout << st.top();
            st.pop();
        }
        cout << endl;
    }
    return 0;
}




================================================
FILE: Divide and Conquer/DSA04009 - LŨY THỪA MA TRẬN 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll mod = 1e9 + 7;
int n, k;

struct matrix
{
    ll m[15][15];
    
    matrix operator * (matrix a)
    {
        matrix res, b = *this;
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                res.m[i][j] = 0;
                for(int z = 0; z < n; ++z)
                {
                    res.m[i][j] += (a.m[i][z] * b.m[z][j]) % mod;
                    res.m[i][j] %= mod;
                }
            }
        }
        return res;
    }
};

matrix binPow(matrix a, int b)
{
    if(b == 1) return a;
    matrix res = binPow(a, b >> 1);
    res = res * res;
    if(b & 1) res = res * a;
    return res;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        matrix a, res;
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                cin >> a.m[i][j];
        res = binPow(a, k);
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j) cout << res.m[i][j] << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04010 - DÃY CON LIÊN TIẾP CÓ TỔNG LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n);
        bool check = 0;
        for(int &i : a)
        {
            cin >> i;
            if(i > 0) check = 1;
        }
        int M = -101;
        if(!check) for(int &i : a) M = max(M, i);
        else
        {
            int sum = 0;
            for(int i = 0; i < n; ++i)
            {
                sum += a[i];
                if(sum < 0) sum = 0;
                M = max(sum, M);
            }
        }
        cout << M << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04011 - TÍCH HAI SỐ NHỊ PHÂN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline ll binPow(ll b)
{
    if(!b) return 1;
    if(b == 1) return 2;
    ll res = binPow(b >> 1);
    res *= res;
    if(b & 1) res <<= 1;
    return res;
}

inline ll change(string &s)
{
    ll res = 0;
    for(int i = 0, j = s.sz - 1; i < s.sz; ++i, --j) if(s[i] == '1') res += binPow(j);
    return res;
}

int main()
{
    faster();
    int t = 1;
    string s1, s2;
    cin >> t;
    while(t--)
    {
        cin >> s1 >> s2;
        cout << change(s1) * change(s2) << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04012 - TÍCH ĐA THỨC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m;
    cin >> t;
    int p[105], q[105];
    while(t--)
    {
        cin >> n >> m;
        vector<int> res(n + m, 0);
        for(int i = 0; i < n; ++i) cin >> p[i];
        for(int i = 0; i < m; ++i) cin >> q[i];
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                res[i + j] += p[i] * q[j];
        m += n - 1;
        for(int i = 0; i < m; ++i) cout << res[i] << ' ';
        cout << endl;
    }
    return 0;
}


================================================
FILE: Divide and Conquer/DSA04013 - SẮP XẾP KANGURU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, cnt;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        sort(a, a + n);
        cnt = n;
        int l = n >> 1, r = n - 1, mid = n >> 1;
        --l;
        while(~l and r >= mid)
        {
            if(a[r] >= a[l] << 1)
            {
                --cnt;
                --l;
                --r;
            }
            else --l;
        }
        cout << cnt << endl;
    }
    return 0;
}


================================================
FILE: Divide and Conquer/DSA04014 - CẶP NGHỊCH THẾ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline ll Merge(ll *a, ll l, ll r, ll mid)
{
    ll i, j, k;
    ll p1 = mid - l + 1, p2 = r - mid;
    ll L[p1], R[p2];
    for(i = 0; i < p1; ++i) L[i] = a[l + i];
    for(i = 0; i < p2; ++i) R[i] = a[mid + i + 1];
    ll res = 0;
    i = j = 0;
    k = l;
    while(i < p1 and j < p2)
    {
        if(L[i] <= R[j]) a[k++] = L[i++];
        else
        {
            a[k++] = R[j++];
            res += p1 - i;
        }
    }
    while(i < p1) a[k++] = L[i++];
    while(j < p2) a[k++] = R[j++];
    return res;
}

inline ll calc(ll *a, int l, int r)
{
    ll res = 0;
    int mid;
    if(l < r)
    {
        mid = (l + r) >> 1;
        res += calc(a, l, mid);
        res += calc(a, mid + 1, r);
        res += Merge(a, l, r, mid);
    }
    return res;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ll a[n];
        for(ll &i : a) cin >> i;
        cout << calc(a, 0, n - 1) << endl;
    }
    return 0;
}


================================================
FILE: Divide and Conquer/DSA04015 - TÍNH FLOOR(X).cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, idx;
    cin >> t;
    ll x;
    while(t--)
    {
        cin >> n >> x;
        vll v;
        v.resize(n);
        for(ll &i : v) cin >> i;
        idx = lower_bound(all(v), x) - v.begin();
        if(v[idx] != x) --idx;
        if(idx > 0) cout << idx + 1 << endl;
        else cout << -1 << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04016 - PHẦN TỬ THỨ K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> k;
        vi a(n), b(m), res(n + m);
        for(int &i : a) cin >> i;
        for(int &i : b) cin >> i;
        merge(all(a), all(b), res.begin());
        cout << res[k - 1] << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04017 - PHẦN TỬ KHÁC NHAU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int binSearch(vll &a, vll &b)
{
    int l = 0, r = a.sz - 2, mid, res;
    while(l <= r)
    {
        mid = (l + r) >> 1;
        if(a[mid] != b[mid])
        {
            res = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    return res;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vll a(n), b(n - 1);
        for(ll &i : a) cin >> i;
        for(ll &i : b) cin >> i;
        if(a[0] != b[0]) cout << 1 << endl;
        else if(a.back() != b.back()) cout << n << endl;
        else cout << binSearch(a, b) + 1 << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04018 - ĐẾM SỐ 0.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n);
        for(int &i : a) cin >> i;
        cout << lower_bound(all(a), 1) - a.begin() << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04019 - CẶP ĐIỂM GẦN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

double res;
vector<pair<double, double>> vp(100000), tmp(100000);

inline double dist(pair<double, double> &a, pair<double, double> &b)
{
    return sqrt((a.fi - b.fi) * (a.fi - b.fi) + (a.se - b.se) * (a.se - b.se));
}

inline bool cmp(pair<double, double> a, pair<double, double> b)
{
    return a.se < b.se;
}

inline void solve(int l, int r)
{
    if(r <= l) return;
    if(r == l + 1)
    {
        res = min(res, dist(vp[l], vp[r]));
        if(vp[l] >= vp[r]) swap(vp[l], vp[r]);
        return;
    }
    int mid = (l + r) >> 1;
    int midVal = vp[mid].fi;
    solve(l, mid);
    solve(mid + 1, r);
    merge(vp.begin() + l, vp.begin() + mid + 1, vp.begin() + mid + 1, vp.begin() + r + 1, tmp.begin(), cmp);
    copy(tmp.begin(), tmp.begin() + r - l + 1, vp.begin() + l);
    int idx = 0;
    for(int i = l; i <= r; ++i)
    {
        if(res > abs(midVal - vp[i].fi))
        {
            for(int j = idx - 1; tmp[j].se > vp[i].se - res and j >= 0; --j) res = min(res, dist(vp[i], tmp[j]));
            tmp[idx++] = vp[i];
        }
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i) cin >> vp[i].fi >> vp[i].se;
        sort(vp.begin(), vp.begin() + n);
        res = DBL_MAX;
        solve(0, n - 1);
        cout << setprecision(6) << fixed << res << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04020 - TÌM KIẾM NHỊ PHÂN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x, idx;
    cin >> t;
    while(t--)
    {
        cin >> n >> x;
        vi a(n);
        for(int &i : a) cin >> i;
        idx = lower_bound(all(a), x) - a.begin();
        if(idx > 0 and idx < n and a[idx] == x) cout << idx + 1;
        else cout << "NO";
        cout << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04021 - DÃY XÂU NHỊ PHÂN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    ll k;
    ll a[93];
    a[1] = a[2] = 1;
    for(int i = 3; i < 93; ++i) a[i] = a[i - 1] + a[i - 2];
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        while(n > 2)
        {
            if(k > a[n - 2])
            {
                k -= a[n - 2];
                --n;
            }
            else n -= 2;
        }
        cout << n - 1 << endl;
    }
    return 0;
}


================================================
FILE: Divide and Conquer/DSA04022 - KÝ TỰ THỨ K TRONG XÂU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[26];

inline int calc(int &n, int &k)
{
    for(int i = n; i; --i)
    {
        if(k == a[i]) return i;
        else if(k > a[i]) k -= a[i];
    }
    return 0;
}

int main()
{
    faster();
    a[1] = 1;
    for(int i = 2; i <= 26; ++i) a[i] = a[i - 1] << 1;
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        cout << (char) (calc(n, k) + 'A' - 1) << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04024 - LŨY THỪA MA TRẬN 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll mod = 1e9 + 7;
int n, k;

struct matrix
{
    ll m[15][15];
    
    matrix operator * (matrix a)
    {
        matrix res, b = *this;
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                res.m[i][j] = 0;
                for(int z = 0; z < n; ++z)
                {
                    res.m[i][j] += (a.m[i][z] * b.m[z][j]) % mod;
                    res.m[i][j] %= mod;
                }
            }
        }
        return res;
    }
};

inline matrix binPow(matrix a, int b)
{
    if(b == 1) return a;
    matrix res = binPow(a, b >> 1);
    res = res * res;
    if(b & 1) res = res * a;
    return res;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        matrix a, res;
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                cin >> a.m[i][j];
        res = binPow(a, k);
        ll ans = 0;
        for(int i = 0; i < n; ++i) ans = (ans + res.m[i][n - 1]) % mod;
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04025 - DÃY SỐ VÔ HẠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

unordered_map<ll, ll> F;
int mod = 1e9 + 7;

ll fibo(ll n)
{
    if(F[n]) return F[n];
    ll k = n >> 1;
    if(n & 1) return F[n] = (fibo(k) * fibo(k + 1) + fibo(k - 1) * fibo(k)) % mod;
    return F[n] = (fibo(k) * fibo(k) + fibo(k - 1) * fibo(k - 1)) % mod;
}

int main()
{
    faster();
    int t, n;
    F[0] = F[1] = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        if(!n) cout << 0 << endl;
        else cout << fibo(n - 1) << endl;
    }
    return 0;
}



================================================
FILE: Divide and Conquer/DSA04030 - SỐ TRIBONACCI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

// {Fn, Tn, Tn-1, Tn-2}

ll mod = 1e15 + 7;
int n;

inline ll binMul(ll a, ll b)
{
    if(b == 0) return 0;
    ll res = binMul(a, b >> 1) % mod;
    res = (res + res) % mod;
    if(b & 1) res = (res + a) % mod;
    return res;
}

struct matrix
{
    ll m[5][5];
    
    matrix operator * (matrix a)
    {
        matrix res, b = *this;
        for(int i = 0; i < 4; ++i)
        {
            for(int j = 0; j < 4; ++j)
            {
                res.m[i][j] = 0;
                for(int z = 0; z < 4; ++z)
                {
                    res.m[i][j] += binMul(a.m[i][z], b.m[z][j]) % mod;
                    res.m[i][j] %= mod;
                }
            }
        }
        return res;
    }
};

inline matrix binPow(matrix a, int b)
{
    if(b == 1) return a;
    matrix res = binPow(a, b >> 1);
    res = res * res;
    if(b & 1) res = res * a;
    return res;
}

ll x[] = {6, 3, 2, 1};

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        if(!n) cout << 0 << endl;
        else if(n == 1) cout << 1 << endl;
        else if(n == 2) cout << 3 << endl;
        else if(n == 3) cout << 6 << endl;
        else
        {
            matrix a, res;
            for(int i = 0; i < 4; ++i)
                for(int j = 0; j < 4; ++j)
                    a.m[i][j] = 0;
            a.m[0][0] = a.m[0][1] = a.m[0][2] = a.m[0][3] = a.m[1][1] = a.m[1][2] = a.m[1][3] = a.m[2][1] = a.m[3][2] = 1;
            res = binPow(a, n - 3);
            ll ans = 0;
            for(int i = 0; i < 4; ++i) ans = (ans + binMul(res.m[0][i], x[i])) % mod;
            cout << ans << endl;
        }
    }
    return 0;
}


================================================
FILE: Divide and Conquer/DSA04035 - TÍNH LŨY THỪA.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int mod = 1e9 + 7;

ll binPow(ll a, ll b)
{
    if(!b) return 1;
    ll res = binPow(a, b >> 1);
    res = (res * res) % mod;
    if(b & 1) res = (res * a) % mod;
    return res;
}

int main()
{
    faster();
    ll a, b;
    while(1)
    {
        cin >> a >> b;
        if(!a and !b) return 0;
        cout << binPow(a, b) << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05001 - XÂU CON CHUNG DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string a, b;
    while(t--)
    {
        cin >> a >> b;
        int dp[a.sz + 1][b.sz + 1];
        for(int i = 0; i <= b.sz; ++i) dp[0][i] = 0;
        for(int i = 0; i <= a.sz; ++i) dp[i][0] = 0;
        for(int i = 0; i < a.sz; ++i)
        {
            for(int j = 0; j < b.sz; ++j)
            {
                if(a[i] == b[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
                else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }
        cout << dp[a.sz][b.sz] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05003 - DÃY CON CHUNG DÀI NHẤT CỦA BA XÂU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
  
int main()
{
    faster();
    int t = 1, n, m, k;
    cin >> t;
    string a, b, c;
    while(t--)
    {
        cin >> n >> m >> k;
        cin >> a >> b >> c;
        int dp[n + 5][m + 5][k + 5];
        memset(dp, 0, sizeof(dp));
        for(int i = 1; i <= a.sz; ++i)
        {
            for(int j = 1; j <= b.sz; ++j)
            {
                for(int z = 1; z <= c.sz; ++z)
                {
                    if(a[i - 1] == b[j - 1] and a[i - 1] == c[z - 1]) dp[i][j][z] = dp[i - 1][j - 1][z - 1] + 1;
                    else dp[i][j][z] = max(dp[i - 1][j][z], max(dp[i][j - 1][z], dp[i][j][z - 1]));
                }
            }
        }
        cout << dp[n][m][k] << endl;
    }
    return 0;
}




================================================
FILE: Dynamic Programming/DSA05004 - DÃY CON TĂNG DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n);
        for(int &i : a) cin >> i;
        int res = 1;
        vi dp(n, 0);
        for(int i = 0; i < n; ++i)
        {
            dp[i] = 1;
            for(int j = 0; j < i; ++j) if(a[j] < a[i]) dp[i] = max(dp[i], dp[j] + 1);
            res = max(res, dp[i]);
        }
        cout << res;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05005 - SỐ BƯỚC ÍT NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n], dp[n], M = -1;
        for(int &i : a) cin >> i;
        for(int i = 0; i < n; ++i)
        {
            dp[i] = 1;
            for(int j = 0; j < i; ++j) if(a[j] <= a[i]) dp[i] = max(dp[i], dp[j] + 1);
            M = max(M, dp[i]);
        }
        cout << n - M << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05006 - TỔNG LỚN NHẤT CỦA DÃY CON TĂNG DẦN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, a[1005], dp[1005], res;
    cin >> t;
    while(t--)
    {
        res = -1;
        cin >> n;
        for(int i = 0; i < n; ++i)
        {
            cin >> a[i];
            dp[i] = a[i];
            for(int j = 0; j < i; ++j) if(a[i] > a[j]) dp[i] = max(dp[i], dp[j] + a[i]);
            res = max(res, dp[i]);
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05007 - TỔNG LỚN NHẤT CỦA DÃY CON KHÔNG KỀ NHAU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    ll dp[1000005];
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        if(n == 1) cout << a[0] << endl;
        else if(n == 2) cout << max(a[0], a[1]) << endl;
        else
        {
            dp[0] = a[0];
            dp[1] = max(a[0], a[1]);
            for(int i = 2; i < n; ++i) dp[i] = max(dp[i - 1], dp[i - 2] + a[i]);
            cout << dp[n - 1] << endl;
        }
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05008 - DÃY CON CÓ TỔNG BẰNG S.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, s;
    cin >> t;
    while(t--)
    {
        cin >> n >> s;
        int a[n];
        for(int &i : a) cin >> i;
        bitset<40005> dp;
        dp[0] = 1;
        for(int i = 0; i < n; ++i)
            for(int j = s; j >= a[i]; --j)
                if(dp[j - a[i]])
                    dp[j] = 1;
        if(dp[s]) cout << "YES\n";
        else cout << "NO\n";
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05010 - DÃY CON DÀI NHẤT CÓ TỔNG CHIA HẾT CHO K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        int a[n];
        for(int i = 0; i < n; ++i)
        {
            cin >> a[i];
            a[i] %= k;
        }
        int dp[n][k];
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < k; ++j)
                dp[i][j] = INT_MIN;
        dp[0][a[0]] = 1;
        for(int i = 1; i < n; ++i)
            for(int j = 0; j < k; ++j)
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][(j + k - a[i]) % k] + 1);
        cout << dp[n - 1][0] << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05011 - SỐ CÓ TỔNG CHỮ SỐ BẰNG K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, k;
    cin >> t;
    const int mod = 1e9 + 7;
    int dp[105][50005] = {};
    for(int i = 1; i <= 9; ++i)
        dp[1][i] = 1;
    for(int i = 1; i <= 100; ++i)
        for(int j = 0; j <= 9; ++j)
            for(int z = j; z <= 50000; ++z)
                dp[i][z] = (dp[i][z] + dp[i - 1][z - j]) % mod;
    while(t--)
    {
        cin >> n >> k;
        cout << dp[n][k] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05012 - TỔ HỢP C(n, k).cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

const ll int mod = 1e9 + 7;

inline ll calc(int n, int k)
{
    vector<ll int> invert(k + 5, 0);
    invert[0] = 1;
    if(k + 1 >= 2) invert[1] = 1;
    FOR(i, 2, k) invert[i] = mod - (mod / i) * invert[mod % i] % mod;
    int res = 1;
    FOR(i, 2, k) res = ((res % mod) * (invert[i] % mod)) % mod;
    ll ed = n - k + 1;
    FORD(i, n, ed) res = ((res % mod) * (i % mod)) % mod;
    return res;
}

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        cout << calc(n, k) << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05013 - BẬC THANG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x, sum, k, mod = 1e9 + 7, dp[100005];
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        ++n;
        ++k;
        sum = 1;
        for(int i = 1; i < k; ++i)
        {
            dp[i] = sum;
            sum = (sum + dp[i]) % mod;
        }
        x = 1;
        sum -= 1;
        for(int i = k; i < n; ++i)
        {
            dp[i] = sum;
            sum -= dp[x++];
            sum += dp[i];
            sum %= mod;
            if(sum < 0) sum += mod;
        }
        cout << dp[n - 1] << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05014 - CATALAN NUMBER.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        int a[20005] = {}, s[20005] = {}, len;
        cin >> n;
        FOR(j, 1, n)
        {
            int x = (n << 1) - j + 1, delta = 1;
            for(int i = 2; i * i <= x; ++i)
            {
                while(x % i == 0)
                {
                    s[i] += delta;
                    x /= i;
                }
            }
            if(x != 1) s[x] += delta;
        }
        int st = n + 1;
        FOR(j, 1, st)
        {
            int x = j, delta = -1;
            for(int i = 2; i * i <= x; ++i)
            {
                while(x % i == 0)
                {
                    s[i] += delta;
                    x /= i;
                }
            }
            if(x != 1) s[x] += delta;
        }
        a[0] = len = 1;
        F(j, 1, 20005)
        {
            while(s[j]--)
            {
                int x = j;
                len += 5;
                F(i, 0, len) a[i] *= x;
                F(i, 0, len)
                {
                    a[i + 1] += a[i] / 10;
                    a[i] %= 10;
                }
                while(len > 0 && a[len - 1] == 0) --len;
            }
        }
        FORD(i, len - 1, 0) cout << a[i];
        cout << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05015 - TÍNH P(N,K).cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k, mod = 1e9 + 7;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        if(k > n)
            cout << 0 << endl;
        else if(!k)
            cout << 1 << endl;
        else
        {
            ll res = 1;
            for(int i = n - k + 1; i <= n; ++i)
                res = (res * i) % mod;
            cout << res << endl;
        }
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05016 - SỐ UGLY.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    vi a;
    priority_queue<int, vi, greater<int>> pq;
    unordered_map<int, bool> m;
    pq.push(1);
    int tmp;
    while(a.sz < 1e4)
    {
        tmp = pq.top();
        pq.pop();
        a.pb(tmp);
        if(!m[tmp << 1])
        {
            pq.push(tmp << 1);
            m[tmp << 1] = 1;
        }
        if(!m[tmp * 3])
        {
            pq.push(tmp * 3);
            m[tmp * 3] = 1;
        }
        if(!m[tmp * 5])
        {
            pq.push(tmp * 5);
            m[tmp * 5] = 1;
        }
    }
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << a[n - 1] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05017 - DÃY SỐ BI-TONIC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
   faster();
   int t = 1, n;
   cin >> t;
   while(t--)
   {
       cin >> n;
       vi a(n);
       for(int &i : a) cin >> i;
       vi dpL(n, 0), dpR(n, 0);
       for(int i = 0; i < n; ++i)
       {
           dpL[i] = a[i];
           for(int j = 0; j < i; ++j)
               if(a[i] > a[j]) dpL[i] = max(dpL[i], dpL[j] + a[i]);
       }
       for(int i = n - 1; ~i; --i)
       {
           dpR[i] = a[i];
           for(int j = n - 1; j > i; --j)
               if(a[i] > a[j]) dpR[i] = max(dpR[i], dpR[j] + a[i]);
       }
       int res = -1;
       for(int i = 0; i < n; ++i) res = max(res, dpL[i] + dpR[i] - a[i]);
       cout << res << endl;
   }
   return 0;
}



================================================
FILE: Dynamic Programming/DSA05018 - XÂU CON ĐỐI XỨNG DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int lcs(string &s)
{
    int res = 1;
    int len = s.sz;
    int l, r;
    for(int i = 1; i < len; ++i)
    {
        l = i - 1;
        r = i;
        while(l >= 0 and r < len and s[l] == s[r])
        {
            --l;
            ++r;
        }
        ++l;
        --r;
        if(s[l] == s[r] and r - l + 1 > res) res = r - l + 1;
        l = i - 1;
        r = i + 1;
        while(l >= 0 and r < len and s[l] == s[r])
        {
            --l;
            ++r;
        }
        ++l;
        --r;
        if(s[l] == s[r] and r - l + 1 > res) res = r - l + 1;
    }
    return res;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        cout << lcs(s) << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05019 - HÌNH VUÔNG LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool a[505][505];
int dp[505][505];

int main()
{
    faster();
    int t = 1, n, m, ans;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        ans = 0;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= m; ++j)
            {
                cin >> a[i][j];
                dp[i][j] = a[i][j];
                if(dp[i][j]) ans = 1;
            }
        }
        for(int i = 0; i <= n; ++i) dp[0][i] = 0;
        for(int i = 0; i <= m; ++i) dp[i][0] = 0;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= m; ++j)
            {
                if(a[i][j])
                {
                    if(!a[i - 1][j] or !a[i][j - 1] or !a[i - 1][j - 1]) continue;
                    dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i][j - 1]));
                    ++dp[i][j];
                    ans = max(ans, dp[i][j]);
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05020 - ĐƯỜNG ĐI NHỎ NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        vector<vi> a(n, vi (m));
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j) cin >> a[i][j];
        for(int i = 1; i < m; ++i) a[0][i] += a[0][i - 1];
        for(int i = 1; i < n; ++i)
            for(int j = 0; j < m; ++j)
            {
                int tmp = a[i - 1][j];
                if (j - 1 >= 0) tmp = min(tmp, (min(a[i - 1][j - 1], a[i][j - 1])));
                a[i][j] += tmp;
            }
        cout << a[n - 1][m - 1] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05021 - CẶP SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        pair<int, int> a[n];
        for(pair<int, int> &i : a)
            cin >> i.fi >> i.se;
        sort(a, a + n);
        int dp[n], res = -1;
        for(int i = 0; i < n; ++i)
        {
            dp[i] = 1;
            for(int j = 0; j < i; ++j)
                if(a[i].fi > a[j].se)
                    dp[i] = max(dp[i], dp[j] + 1);
            res = max(res, dp[i]);
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05022 - KÝ TỰ GIỐNG NHAU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, insrt, cpy, del;
    cin >> t;
    while(t--)
    {
        cin >> n >> insrt >> del >> cpy;
        int dp[n + 1], i = 1;
        dp[0] = 0;
        while(i <= n)
        {
            dp[i] = dp[i - 1] + insrt;
            if(i & 1)
                dp[i] = min(dp[i], dp[(i + 1) >> 1] + del + cpy);
            else
                dp[i] = min(dp[i], dp[i / 2] + cpy);
            ++i;
        }
        cout << dp[n] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05023 - TỔNG CÁC XÂU CON.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll sum = 0;
char x[15];
string s;
int k;

void print(int i)
{
    ll tmp = 0;
    for(int j = k; j <= i; ++j) tmp = tmp * 10 + x[j] - '0';
    sum += tmp;
}

void Try(int i)
{
    for(int j = i - 1; j < s.sz; ++j)
    {
        x[i] = s[j];
        print(i);
        Try(i + 1);
        j = s.sz - 1;
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        sum = 0;
        cin >> s;
        for(k = 1; k <= s.sz; ++k) Try(k);
        cout << sum << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05024 - TỔNG BẰNG K.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    int a[1005];
    int mod = 1e9 + 7;
    while(t--)
    {
        cin >> n >> k;
        vector<int> dp(k + 5, 0);
        for(int i = 0; i < n; ++i)
            cin >> a[i];
        dp[0] = 1;
        for(int i = 1; i <= k; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                if(i >= a[j])
                    dp[i] = (dp[i] % mod + dp[i - a[j]] % mod) % mod;
            }
        }
        cout << dp[k] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05025 - CON ẾCH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    ll dp[55];
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 4;
    for(int i = 4; i <= 50; ++i) dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << dp[n] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05026 - XEM PHIM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, s;
    //cin >> t;
    while(t--)
    {
        cin >> s >> n;
        int a[n + 1];
        for(int i = 1; i <= n; ++i) cin >> a[i];
        vector<vector<int>> dp(n + 1, vi(s + 1, 0));
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= s; ++j)
                if(a[i] < j) dp[i][j] = max(dp[i - 1][j - a[i]] + a[i], dp[i - 1][j]);
                else dp[i][j] = dp[i - 1][j];
        cout << dp[n][s];
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05027 - CÁI TÚI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll n, m, res;
ll dp[1005][1005];
pair<ll, ll> a[1005];

void solve()
{
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= m; ++j)
        {
            if(j < a[i].fi) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - a[i].fi] + a[i].se);
            res = max(res, dp[i][j]);
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        res = 0;
        cin >> n >> m;
        for(int i = 1; i <= n; ++i) cin >> a[i].fi;
        for(int i = 1; i <= n; ++i) cin >> a[i].se;
        solve();
        cout << res << endl;
    }
    return 0;
}




================================================
FILE: Dynamic Programming/DSA05028 - BIẾN ĐỔI XÂU.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    string s1, s2;
    while(t--)
    {
        cin >> s1 >> s2;
        int dp[105][105];
        for(int i = 0; i <= s1.sz; ++i)
            dp[i][0] = i;
        for(int i = 0; i <= s2.sz; ++i)
            dp[0][i] = i;
        for(int i = 1; i <= s1.sz; ++i)
        {
            for(int j = 1; j <= s2.sz; ++j)
            {
                if(s1[i - 1] == s2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
            }
        }
        cout << dp[s1.sz][s2.sz] << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05029 - GIẢI MÃ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        if(s[0] == '0')
        {
            cout << 0 << endl;
            continue;
        }
        int dp[1005] = {};
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= s.sz; ++i)
        {
            if(s[i - 1] > '0') dp[i] = dp[i - 1];
            if(s[i - 2] == '1' or (s[i - 2] == '2' && s[i - 1] < '7')) dp[i] += dp[i - 2];
        }
        cout << dp[s.sz] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05030 - DI CHUYỂN VỀ GỐC TỌA ĐỘ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, m;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        vector<vll> dp(n + 5, vll(m + 5, 1));
        for(int i = n - 1; ~i; --i)
            for(int j = m - 1; ~j; --j)
                dp[i][j] = dp[i + 1][j] + dp[i][j + 1];
        cout << dp[0][0] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05031 - TỔNG BÌNH PHƯƠNG.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, sqr;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int dp[10005] = {};
        for(int i = 1; i <= n; ++i)
        {
            dp[i] = INT_MAX;
            sqr = sqrt(i);
            for(int j = 1; j <= sqr; ++j)
                if(dp[i - j * j] < INT_MAX)
                    dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
        cout << dp[n] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05032 - XÂU ĐỐI XỨNG 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> s;
        int dp[41][41] = {};
        string tmp = s;
        reverse(tmp.begin(), tmp.end());
        for(int i = 0; i < s.sz; ++i)
        {
            for(int j = 0; j < tmp.sz; ++j)
            {
                if(s[i] == tmp[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
                else dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);
            }
        }
        int M = dp[s.sz][tmp.sz];
        cout << s.sz - M << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05033 - XÂU ĐỐI XỨNG 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    string s, s1, s2;
    while(t--)
    {
        cin >> s2;
        s1 = s2;
        reverse(all(s2));
        vector<vector<int>> dp(105, vector<int>(105, 0));
        for(int i = 0; i < s1.sz; ++i)
        {
            for(int j = 0; j < s2.sz; ++j)
            {
                if(s1[i] == s2[j])
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                else
                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }
        cout << s1.sz - dp[s1.sz][s2.sz] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05034 - TỔNG SỐ CÁCH DI CHUYỂN.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, k;
    cin >> t;
    int mod = 1e9 + 7;
    while(t--)
    {
        cin >> n >> k;
        int dp[100005] = {};
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n; ++i)
        {
            for(int j = 1; j <= min(i, k); ++j)
            {
                dp[i] += dp[i - j];
                dp[i] %= mod;
            }
        }
        cout << dp[n] << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05035 - CHỮ SỐ SẮP XẾP TĂNG DẦN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    vll a(15, 1);
    ll dp[105] = {};
    const int mod = 1e9 + 7;
    dp[1] = 10;
    ll sum;
    for(int i = 2; i <= 100; ++i)
    {
        for(int j = 1; j < 10; ++j)
        {
            sum = 0;
            for(int z = j; z < 10; ++z)
                sum += a[z];
            dp[i] += sum;
            while(dp[i] >= mod)
                dp[i] -= mod;
            a[j] = sum;
        }
    }
    for(int i = 2; i <= 100; ++i)
    {
        dp[i] += dp[i - 1];
        while(dp[i] >= mod)
            dp[i] -= mod;
    }
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << dp[n] << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05036 - TĂNG - GIẢM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        double a[n], b[n];
        for(int i = 0; i < n; ++i)
            cin >> a[i] >> b[i];
        int dp[n], res = -1;
        for(int i = 0; i < n; ++i)
        {
            dp[i] = 1;
            for(int j = 0; j < i; ++j)
                if(a[j] < a[i] and b[j] > b[i])
                    dp[i] = max(dp[i], dp[j] + 1);
            res = max(res, dp[i]);
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05037 - CHỮ SỐ SẮP XẾP TĂNG DẦN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    vll a(15, 1);
    ll dp[105] = {};
    const int mod = 1e9 + 7;
    dp[1] = 10;
    ll sum;
    for(int i = 2; i <= 100; ++i)
    {
        for(int j = 1; j < 10; ++j)
        {
            sum = 0;
            for(int z = j; z < 10; ++z)
                sum += a[z];
            dp[i] += sum;
            while(dp[i] >= mod)
                dp[i] -= mod;
            a[j] = sum;
        }
    }
    for(int i = 2; i <= 100; ++i)
    {
        dp[i] += dp[i - 1];
        while(dp[i] >= mod)
            dp[i] -= mod;
    }
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << dp[n] << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05038 - DÃY CON TĂNG DÀI NHẤT 2 CHIỀU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<map<int, int>> dp;

inline bool check(int mid, int x, int y)
{
    auto it = dp[mid].lower_bound(x);
    if(it == dp[mid].begin())
        return 0;
    --it;
    return (*it).se < y;
}

inline void Add(int l, int x, int y)
{
    auto it = dp[l].lower_bound(x);
    auto ori = it;
    while(it != dp[l].end() and (*it).se >= y)
        ++it;
    dp[l].erase(ori, it);
    dp[l].insert({x, y});
}

int main()
{
    faster();
    int n, x, y, res = 0, l, r, mid;
    cin >> n;
    dp.resize(n);
    Add(0, INT_MIN, INT_MIN);
    while(n--)
    {
        cin >> x >> y;
        l = 0;
        r = res;
        while(l <= r)
        {
            mid = (l + r) >> 1;
            if (check(mid, x, y))
                l = mid + 1;
            else
                r = mid - 1;
        }
        if(res == l - 1)
            res = l;
        Add(l, x, y);
    }
    cout << res;
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05039 - TỔNG CHỮ SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int dp[105][8105];

int Find(int a, int b)
{
    if(a > 100 or b > 8100 or a > b or a < 0 or b < 0)
        return -1;
    if(!a and !b)
        return 0;
    if(dp[a][b] != -1)
        return dp[a][b];
    int res = 105, i = 9;
    while(i)
    {
        int tmp = Find(a - i, b - i * i);
        if(tmp != -1)
            res = min(res, tmp + 1);
        --i;
    }
    dp[a][b] = res;
    return res;
}

int main()
{
    faster();
    int t, a, b;
    cin >> t;
    while(t--)
    {
        memset(dp, -1, sizeof(dp));
        dp[0][0] = 0;
        cin >> a >> b;
        int MIN = Find(a, b);
        if(MIN == -1 or MIN > 100)
            cout << -1;
        else
        {
            int i;
            while(a > 0 and b > 0)
            {
                i = 1;
                while(i < 10)
                {
                    if(a >= i and b >= i * i and dp[a - i][b - i * i] + 1 == dp[a][b])
                    {
                        cout << i;
                        a -= i;
                        b -= i * i;
                        break;
                    }
                    ++i;
                }
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05040 - DÃY TAM GIÁC DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    int n, a[100005];
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i) cin >> a[i];
        int inc[n], dec[n];
        inc[0] = dec[n - 1] = 1;
        for(int i = 1; i < n; ++i)
        {
            if(a[i] > a[i - 1]) inc[i] = inc[i - 1] + 1;
            else inc[i] = 1;
        }
        for(int i = n - 2; i >= 0; --i)
        {
            if(a[i] > a[i + 1]) dec[i] = dec[i + 1] + 1;
            else dec[i] = 1;
        }
        int ans = -1;
        for(int i = 0; i < n; ++i) ans = max(ans, inc[i] + dec[i] - 1);
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05042 - DÃY CON LIÊN TIẾP TỔNG BẰNG K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline string solve(ll* a, int &n, ll &k)
{
    unordered_map<ll, int> m;
    ll sum = 0;
    for(int i = 0; i < n; ++i)
    {
        sum += a[i];
        if(sum == k or m[sum - k])
            return "YES";
        m[sum] = 1;
    }
    return "NO";
}

int main()
{
    faster();
    int t, n;
    ll k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        ll a[n];
        for(ll &i : a)
            cin >> i;
        cout << solve(a, n, k) << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05043 - SỐ THUẬN NGHỊCH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> s;
        vector<bitset<1005>> dp(s.sz + 5);
        int res = 1;
        dp[s.sz - 1][s.sz - 1] = 1;
        for(int i = 0; i < s.sz - 1; ++i)
        {
            dp[i][i] = 1;
            if(s[i] == s[i + 1])
            {
                dp[i][i + 1] = 1;
                res = 2;
            }
        }
        int z;
        for(int i = 3; i <= s.sz; ++i)
        {
            for(int j = 0; j < s.sz - i + 1; ++j)
            {
                z = i + j - 1;
                if(s[j] == s[z] and dp[j + 1][z - 1])
                {
                    dp[j][z] = 1;
                    res = max(res, i);
                }
            }
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05045 - BÀI TOÁN CÁI TÚI KHÔNG NGUYÊN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool cmp(pair<pair<int, int>, float> a, pair<pair<int, int>, float> b)
{
    return a.se > b.se;
}

int main()
{
    int t = 1;
    cin >> t;
    int n, w;
    while (t--)
    {
        cin >> n >> w;
        vector<pair<pair<int, int>, float>> v(n);
        for (pair<pair<int, int>, float> &i : v)
        {
            cin >> i.fi.fi >> i.fi.se;
            i.se = 1.0 * i.fi.fi / i.fi.se;
        }
        sort(all(v), cmp);
        int sumVal, idx;
        float sumWeight;
        idx = sumVal = sumWeight = 0;
        for (int i = 0; i < n; ++i)
        {
            if (sumVal <= w)
            {
                sumVal += v[i].fi.se;
                sumWeight += v[i].fi.fi;
                idx = i;
            }
        }
        if (sumVal > w)
            sumWeight -= 1.0 * (sumVal - w) * v[idx].se;
        cout << setprecision(2) << fixed << sumWeight << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSA05046 - LŨY THỪA BẬC K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

const int mod = 1e9 + 7;
ll a[1005], b[1005], dp[1005];

ll Mul(ll a, ll b, ll m)
{
    a %= m;
    b %= m;
    ll tmp = (double) a * b / m;
    return (a * b - tmp * m);
}

ll Pow(ll a, ll b)
{
    ll res = 1;
    while(b)
    {
        if(b & 1)
            res = Mul(res, a, mod);
        a = Mul(a, a, mod);
        b >>= 1;
    }
    return res;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    ll n, k;
    while(t--)
    {
        cin >> n >> k;
        ll res = 0;
        a[0] = b[k + 3] = dp[0] = 1;
        ll tmp = k + 2;
        for(int i = 1; i <= tmp; ++i)
        {
            a[i] = Mul(a[i - 1], n - i, mod);
            b[tmp - i + 1] = Mul(b[tmp - i + 2], n - (tmp - i + 1), mod);
            dp[i] = Mul(dp[i - 1], i, mod);
        }
        ll sum = 0, x, y, z;
        for(int i = 1; i <= tmp; ++i)
        {
            sum += Pow(i, k);
            sum %= mod;
            x = Mul(sum, a[i - 1], mod);
            y = Mul(dp[i - 1], dp[k + 2 - i], mod);
            z = Mul(b[i + 1], Pow(Mul(y, ((k - i) & 1) ? -1 : 1, mod), mod - 2), mod);
            res = (res + Mul(x, z, mod)) % mod;
        }
        cout << (res + mod) % mod << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSA05047 - CHỌN Ô.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    int t = 1;
    cin >> t;
    int n;
    ll bitmask[10005][20] = {};
    const ll _oo = -1e18;
    while(t--)
    {
        cin >> n;
        ll a[4][n + 5];
        ll MAX = _oo;
        for(int i = 0; i < 4; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                cin >> a[i][j];
                MAX = max(MAX, a[i][j]);
            }
        }
        bitset<20> f;
        if(MAX <= 0)
        {
            cout << MAX << endl;
            continue;
        }
        bool check;
        for(int i = 0; i < 16; ++i)
        {
            check = 1;
            for(int j = 0; j < 4; ++j)
            {
                if((i >> j) & 1 and (i >> (j + 1)) & 1)
                {
                    check = 0;
                    break;
                }
            }
            f[i] = check;
        }
        int sum;
        ll res = _oo;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 0; j < 16; ++j)
            {
                bitmask[i][j] = _oo;
                if(f[j])
                {
                    sum = 0;
                    for(int z = 0; z < 4; ++z)
                        sum += a[z][i] * ((j >> z) & 1);
                    for(int z = 0; z < 16; ++z)
                        if(f[z] and !(j & z))
                            bitmask[i][j] = max(bitmask[i][j], bitmask[i - 1][z] + sum);
                }
                res = max(res, bitmask[i][j]);
            }
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Dynamic Programming/DSAKT053 - SỐ NGUYÊN LỚN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string a, b;
    while(t--)
    {
        cin >> a >> b;
        int dp[a.sz + 1][b.sz + 1];
        for(int i = 0; i <= b.sz; ++i) dp[0][i] = 0;
        for(int i = 0; i <= a.sz; ++i) dp[i][0] = 0;
        for(int i = 0; i < a.sz; ++i)
        {
            for(int j = 0; j < b.sz; ++j)
            {
                if(a[i] == b[j]) dp[i + 1][j + 1] = dp[i][j] + 1;
                else dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }
        cout << dp[a.sz][b.sz] << endl;
    }
    return 0;
}


================================================
FILE: Dynamic Programming/DSAKT055 - BÀI TOÁN CÁI TÚI 0-1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll n, m, res;
ll dp[1005][1005];
pair<ll, ll> a[1005];

void solve()
{
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= m; ++j)
        {
            if(j < a[i].fi) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - a[i].fi] + a[i].se);
            res = max(res, dp[i][j]);
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        res = 0;
        cin >> n >> m;
        for(int i = 1; i <= n; ++i) cin >> a[i].fi;
        for(int i = 1; i <= n; ++i) cin >> a[i].se;
        solve();
        cout << res << endl;
    }
    return 0;
}




================================================
FILE: Dynamic Programming/DSAKT110 - NHÀ KHÔNG KỀ NHAU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    ll dp[1000005];
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        if(n == 1) cout << a[0] << endl;
        else if(n == 2) cout << max(a[0], a[1]) << endl;
        else
        {
            dp[0] = a[0];
            dp[1] = max(a[0], a[1]);
            for(int i = 2; i < n; ++i) dp[i] = max(dp[i - 1], dp[i - 2] + a[i]);
            cout << dp[n - 1] << endl;
        }
    }
    return 0;
}



================================================
FILE: Generation/CTDL_001 - THUẬT TOÁN SINH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[25] = {}, n;

bool check()
{
    for(int i = 1; i <= n; ++i) if(a[i] != a[n - i + 1]) return 0;
    return 1;
}

void print()
{
    for(int i = 1; i <= n; ++i) cout << a[i] << ' ';
    cout << endl;
}

void Try(int i)
{
    for(int j = 0; j <= 1; ++j)
    {
        a[i] = j;
        if(i == n)
        {
            if(check()) print();
        }
        else Try(i + 1);
    }
}

int main()
{
    faster();
    cin >> n;
    Try(1);
    return 0;
}



================================================
FILE: Generation/CTDL_002 - Tổng dãy con = K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
vector<int> v;
vector<bool> f;
vector<vector<bool>> ans;

void check()
{
    int sum = 0;
    for(int i = 1; i <= n; ++i) sum += v[i] * f[i];
    if(sum == k) ans.pb(f);
}

void Try(int i)
{
    for(int j = 0; j < 2; ++j)
    {
        f[i] = j;
        if(i == n) check();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    cin >> n >> k;
    v.resize(n + 1);
    f.resize(n + 1);
    for(int i = 1; i <= n; ++i) cin >> v[i];
    Try(1);
    for(vector<bool> &i : ans)
    {
        for(int j = 1; j <= n ; ++j) if(i[j]) cout << v[j] << ' ';
        cout << endl;
    }
    cout << ans.sz;
    return 0;
}



================================================
FILE: Generation/CTDL_003 - PHƯƠNG ÁN TỐI ƯU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<pair<int, int>> x;
vector<vector<int> > f;
string res;
void trace(int n, int v)
{
    if (n == 0) return;
    if (f[n][v] == f[n - 1][v]) trace(n - 1, v);
    else
    {
        trace(n - 1, v - x[n].fi);
        res[n - 1] = '1';
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        int v, n;
        cin >> n >> v;
        f.resize((n + 1), vector<int> (v + 1, 0));
        x.resize(n + 1);
        for(int i = 1; i <= n; i++)
        {
            res = res + "0";
            cin >> x[i].se;
        }
        for(int i = 1; i <= n; i++) cin >> x[i].fi;
        for(int i = 0; i <= n; i++) f[i][0] = 0;
        for(int i = 0; i <= v; i++) f[0][i] = 0;
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= v; j++)
            {
                if (j < x[i].fi) f[i][j] = f[i - 1][j];
                else f[i][j] = max(f[i - 1][j], f[i - 1][j - x[i].fi] + x[i].se);
            }
        cout << f[n][v] << endl;
        trace(n, v);
        for(char c: res) cout << c <<' ';
    }
    return 0;
}



================================================
FILE: Generation/CTDL_004 - DÃY CON TĂNG DẦN BẬC K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k, a[105];
ll ans = 0;

void Try(int i, int cnt = 0)
{
    for(int j = i + 1; j <= n; ++j)
    {
        if(a[j] > a[i])
        {
            ++cnt;
            if(cnt == k) ++ans;
            Try(j, cnt);
            --cnt;
        }
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        for(int i = 1; i <= n; ++i) cin >> a[i];
        Try(0);
        cout << ans;
    }
    return 0;
}



================================================
FILE: Generation/DSA01001 - XÂU NHỊ PHÂN KẾ TIẾP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        int idx = s.sz - 1;
        while(s[idx] == '1')
        {
            s[idx] = '0';
            --idx;
        }
        if(idx >= 0) s[idx] = '1';
        cout << s << endl;
    }
    return 0;
}




================================================
FILE: Generation/DSA01002 - TẬP CON KẾ TIẾP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    string s;
    while(t--)
    {
        int a[1005];
        cin >> n >> k;
        FOR(i, 1, k) cin >> a[i];
        int tmp = k;
        while(a[tmp] == n - k + tmp) --tmp;
        if(tmp > 0)
        {
            ++a[tmp];
            FOR(i, tmp + 1, k) a[i] = a[i - 1] + 1;
            FOR(i, 1, k) cout << a[i] << ' ';
        }
        else FOR(i, 1, k) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01003 - HOÁN VỊ KẾ TIẾP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> n;
        vi a(n);
        for(int &i : a) cin >> i;
        next_permutation(all(a));
        for(int i : a) cout << i << ' ';
        cout << endl;
    }
    return 0;
}




================================================
FILE: Generation/DSA01004 - SINH TỔ HỢP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
int a[20];

void print()
{
    for(int i = 1; i <= k; ++i) cout << a[i];
    cout << ' ';
}

void Try(int i)
{
    for(int j = a[i - 1] + 1; j <= n - k + i; ++j)
    {
        a[i] = j;
        if(i == k) print();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        Try(1);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01004 - SINH TỔ HỢP.java
================================================
// Created by Nguyễn Mạnh Quân

import java.util.Scanner;

public class code
{
    static int n, k;
    static int[] a = new int[20];

    static void Try(int i, int idx)
    {
        if(idx > k)
        {
            for(int j = 1; j <= k; ++j)
                System.out.print(a[j]);
            System.out.print(" ");
            return;
        }
        for(int j = i; j <= n; ++j)
        {
            a[idx] = j;
            Try(j + 1, idx + 1);
        }
    }

    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t-- > 0)
        {
            n = sc.nextInt();
            k = sc.nextInt();
            Try(1, 1);
            System.out.println();
        }
    }
}



================================================
FILE: Generation/DSA01005 - SINH HOÁN VỊ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check[15] = {};
int n, a[15] = {};

void print()
{
    for (int i = 1; i <= n; ++i) cout << a[i];
    cout << ' ';
}
 
void Try(int i)
{
    for (int j = 1; j <= n; ++j)
    {
        if (!check[j])
        {
            a[i] = j;
            check[j] = 1;
            if(i == n) print();
            else Try(i + 1);
            check[j] = 0;
        }
    }
}

int main()
{
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        Try(1);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01006 - HOÁN VỊ NGƯỢC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check[15] = {};
int n, a[15] = {};

void print()
{
    for (int i = n; i ; --i) cout << a[i];
    cout << ' ';
}
 
void Try(int i)
{
    for (int j = n; j; --j)
    {
        if (!check[j])
        {
            a[i] = j;
            check[j] = 1;
            if(i == 1) print();
            else Try(i - 1);
            check[j] = 0;
        }
    }
}

int main()
{
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        Try(n);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01007 - XÂU AB CÓ ĐỘ DÀI N.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, a[15] = {};

void print()
{
    for (int i = 1; i <= n; ++i) cout << (char) (a[i] + 'A' - 1);
    cout << ' ';
}
 
void Try(int i)
{
    for (int j = 1; j <= 2; ++j)
    {
        a[i] = j;
        if(i == n) print();
        else Try(i + 1);
    }
}

int main()
{
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        Try(1);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01007 - XÂU AB CÓ ĐỘ DÀI N.java
================================================
// Created by Nguyễn Mạnh Quân

import java.util.Scanner;

public class code
{
    static int n;
    static char[] a = new char[20];

    static void Try(int idx)
    {
        if(idx > n)
        {
            for(int j = 1; j <= n; ++j)
                System.out.print(a[j]);
            System.out.print(" ");
            return;
        }
        for(char j = 'A'; j <= 'B'; ++j)
        {
            a[idx] = j;
            Try(idx + 1);
        }
    }

    public static void main(String[] args)
    {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t-- > 0)
        {
            n = sc.nextInt();
            Try(1);
            System.out.println();
        }
    }
}



================================================
FILE: Generation/DSA01008 - XÂU NHỊ PHÂN CÓ K BIT 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k, a[20] = {};

void print()
{
    for (int i = 1; i <= n; ++i) cout << a[i];
    cout << endl;
}
 
void Try(int i)
{
    for (int j = 0; j <= 1; ++j)
    {
        a[i] = j;
        if(i == n)
        {
            int cnt = 0;
            for (int i = 1; i <= n; ++i) cnt += a[i];
            if(cnt == k) print();
        }
        else Try(i + 1);
    }
}

int main()
{
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        Try(1);
    }
    return 0;
}


================================================
FILE: Generation/DSA01009 - XÂU AB ĐẶC BIỆT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
vector<bool> a;
vector<vector<bool>> ans;

void check()
{
    int cnt = 0, res = 0;
    for(int i = 1; i <= n; ++i)
    {
        if(a[i])
        {
            res += cnt == k;
            cnt = 0;
        }
        else ++cnt;
    }
    res += cnt == k;
    if(res == 1) ans.pb(a);
}

void sinh()
{
    while(1)
    {
        for(int i = n; i >= 0; --i)
        {
            if (i == 0) return;
            if (a[i] == 1) a[i] = 0;
            else
            {
                a[i] = 1;
                check();
                break;
            }
        }
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        a.resize(n + 1, 0);
        sinh();
        cout << ans.size() << endl;
        for(vector<bool> &i : ans)
        {
            for(int j = 1; j < i.sz; ++j)
            {
                if(!i[j]) cout << 'A';
                else cout << 'B';
            }
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Generation/DSA01010 - TẬP QUÂN SỰ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        int a[k + 1],b[k + 1], cnt = 0, idx;
        for(int i = 1;i <= k; i++)
        {
            cin >> b[i];
            a[i] = b[i];
        }
        idx = k;
        while(a[idx] == n - k + idx && idx > 0) idx--;
        if(idx < 1)
        {
            cout << k << endl;
        }
        else
        {
            a[idx]++;
            for(int j = idx + 1; j <= k; j++) a[j] = a[j - 1] + 1;
            for(int i = 1; i <= k; i++)
                for(int j = 1; j <= k; j++)
                    if(a[i] == b[j]) ++cnt;
            if(cnt == k) cnt = 0;
            cout << k - cnt << endl;
        }
    }
    return 0;
}



================================================
FILE: Generation/DSA01011 - HOÁN VỊ TIẾP THEO CỦA CHUỖI SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    int cnt;
    while(t--)
    {
        cin >> cnt;
        cout << cnt << ' ';
        cin >> s;
        int i, j;
        i = s.sz - 2;
        while (i >= 0 && s[i] >= s[i + 1]) --i;
        if(i < 0)
        {
            cout << "BIGGEST" << endl;
            continue;
        }
        j = s.size() - 1;
        while(s[i] >= s[j]) j--;
        swap(s[i], s[j]);
        sort(s.begin() + i + 1, s.end());
        cout << s << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01012 - MÃ GRAY 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int t = pow(2, n);
        t >>= 1;
        vector<string> s(pow(2, n));
        while(t)
        {
            F(i, 0, t) s[i] += "0";
            int tmp = t * 2;
            F(i, t, tmp) s[i] += "1";
            t >>= 1;
        }
        t = pow(2, n);
        t >>= 1;
        int move = 1;
        while(t != 1)
        {
            string tmp = "";
            F(i, 0, t) tmp += s[i][move];
            int cnt = pow(2, n) / t - 1;
            int k = t;
            while(cnt--)
            {
                if(cnt & 1)
                {
                    int j = 0;
                    for(int i = k; i <= k + tmp.length() - 1; ++i)
                    {
                        s[i] += tmp[j];
                        ++j;
                    }
                }
                else
                {
                    int j = tmp.length() - 1;
                    for(int i=k; i <= k + tmp.length() - 1; ++i)
                    {
                        s[i] += tmp[j];
                        --j;
                    }
                }
                k += tmp.length();
            }
            t >>= 1;
            ++move;
        }
        for(string i : s) cout << i << ' ';
        cout << endl;
    }
    return 0;
}




================================================
FILE: Generation/DSA01013 - MÃ GRAY 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        cout << s[0];
        int tmp = s[0] - '0', x;
        for(int i = 1; i < s.sz; ++i)
        {
            x = s[i] - '0';
            if(x != tmp)
            {
                tmp = 1;
                cout << tmp;
            }
            else
            {
                tmp = 0;
                cout << tmp;
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01014 - TẬP HỢP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k, sum, res;
bool dd[25];
vector<int> a;

void Try(int i, int cur = 0)
{
    if(i > k)
    {
        res += cur == sum;
        return;
    }
    for(int j = a[i - 1] + 1; j <= n; ++j)
        if (!dd[j])
        {
            a.pb(j);
            dd[j] = 1;
            Try(i + 1, cur + j);
            a.pop_back();
            dd[j] = 0;
        }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        while(1)
        {
            res = 0;
            cin >> n >> k >> sum;
            if(n == 0 && k == 0 && sum == 0) return 0;
            a.pb(0);
            Try(1);
            cout << res << endl;
            a.clear();
        }
    }
    return 0;
}



================================================
FILE: Generation/DSA01015 - TÌM BỘI SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    vll v;
    ll tmp = 9;
    v.pb(tmp);
    while(tmp * 10 <= 9000000999999)
    {
        int s = v.sz;
        tmp *= 10;
        v.pb(tmp);
        F(i, 0, s) v.pb(tmp + v[i]);
    }
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int idx = 0;
        while(v[idx] % n) ++idx;
        cout << v[idx] << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01016 - PHÂN TÍCH SỐ 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

void push(vector<int> &v1, vector<string> &ans)
{
    vi v = v1;
    sort(v.begin(), v.end(), greater<int>());
    string s = "(";
    int size = v.sz - 1;
    F(i, 0, size)
    {
        s += to_string(v[i]);
        s += " ";
    }
    s += to_string(v[size]) + ")";
    ans.pb(s);
}

void Try(vi &v, int i, int n, vector<string> &ans)
{
    if (!n) push(v, ans);
    for (int j = n; j >= i; --j)
    {
        v.push_back(j);
        Try(v, j, n - j, ans);
        v.pop_back();
    }
}

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi v;
        vector<string> ans;
        Try(v, 1, n, ans);
        sort(ans.begin(), ans.end(), greater<string>());
        if(n == 10)
        {
            cout << "(10) ";
            ans.erase(ans.begin() + 40);
        }
        for(string i : ans) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Generation/DSA01017 - MÃ GRAY 3.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    vector<vector<string>> res(15);
    res[1].pb("0");
    res[1].pb("1");
    for(int i = 2; i <= 10; ++i)
    {
        for(int j = 0; j < res[i - 1].sz; ++j) res[i].pb('0' + res[i - 1][j]);
        for(int j = res[i - 1].sz - 1; j >= 0 ; --j) res[i].pb('1' + res[i - 1][j]);
    }
    int t = 1;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> s;
        int idx = 0;
        for(int i = s.sz - 1; i >= 0; --i) if(s[i] == '1') idx += 1 << (s.sz - i - 1);
        cout << res[s.sz][idx] << endl;
    }
    return 0;
}




================================================
FILE: Generation/DSA01018 - TẬP CON LIỀN KỀ PHÍA TRƯỚC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int a[1005];

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        FOR(i, 1, k) cin >> a[i];
        int tmp = k;
        while(a[tmp - 1] + 1 == a[tmp] && tmp) --tmp;
        if(tmp)
        {
            --a[tmp];
            FOR(i, tmp + 1, k) a[i] = n - k + i;
            FOR(i, 1, k) cout << a[i] << ' ';
        }
        else FOR(i, n - k + 1, n) cout << i << ' ';
        cout << endl;
    }
    return 0;
}


================================================
FILE: Generation/DSA01019 - HAHAHA.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
vector<char> vc;
char a[2] = {'A', 'H'};

void print()
{
    for(int i = 1; i <= n; ++i) cout << vc[i];
    cout << endl;
}

void Try(int i)
{
    for(int j = 0; j < 2; ++j)
    {
        if(vc[i - 1] == 'H' and j == 1) continue;
        vc[i] = a[j];
        if(i == n - 1) print();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        if(n == 2)
        {
            cout << "HA\n";
            continue;
        }
        vc.resize(n + 1);
        vc[1] = 'H';
        vc[n] = 'A';
        Try(2);
    }
    return 0;
}



================================================
FILE: Generation/DSA01020 - XÂU NHỊ PHÂN TRƯỚC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        int i = s.length() - 1;
        while(s[i] == '0')
        {
            s[i] = '1';
            --i;
        }
        if(i < 0) F(i, 0, s.length()) cout << 1;
        else
        {
            s[i] = '0';
            cout << s;
        }
        cout << endl;
    }
    return 0;
}




================================================
FILE: Generation/DSA01021 - TỔ HỢP TIẾP THEO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        int a[k + 1],b[k + 1], cnt = 0, idx;
        for(int i = 1;i <= k; i++)
        {
            cin >> b[i];
            a[i] = b[i];
        }
        idx = k;
        while(a[idx] == n - k + idx && idx > 0) idx--;
        if(idx < 1)
        {
            cout << k << endl;
        }
        else
        {
            a[idx]++;
            for(int j = idx + 1; j <= k; j++) a[j] = a[j - 1] + 1;
            for(int i = 1; i <= k; i++)
                for(int j = 1; j <= k; j++)
                    if(a[i] == b[j]) ++cnt;
            if(cnt == k) cnt = 0;
            cout << k - cnt << endl;
        }
    }
    return 0;
}



================================================
FILE: Generation/DSA01022 - SỐ THỨ TỰ HOÁN VỊ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi v(n), a(n);
        for(int i = 0; i < n; ++i)
        {
            cin >> a[i];
            v[i] = i + 1;
        }
        if(a == v) cout << 1 << endl;
        else
        {
            int cnt = 1;
            while(v != a)
            {
                ++cnt;
                next_permutation(all(v));
            }
            cout << cnt << endl;
        }
    }
    return 0;
}



================================================
FILE: Generation/DSA01023 - SỐ THỨ TỰ TỔ HỢP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
bool f[20];
vi a, v;
int cnt = 0;
bool ok;

bool check()
{
    return a == v;
}

void Try(int i)
{
    if(ok) return;
    for(int j = v[i - 1] + 1; j <= n - k + i; ++j)
    {
        v[i] = j;
        if(i == k)
        {
            ++cnt;
            if(check())
            {
                ok = 1;
                return;
            }
        }
        else Try(i + 1);
        if(ok) return;
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        ok = 0;
        cnt = 0;
        cin >> n >> k;
        a.resize(n + 1);
        v.resize(n + 1);
        memset(f, 0, 20);
        for(int i = 1; i <= k; ++i) cin >> a[i];
        Try(1);
        cout << cnt << endl;
    }
    return 0;
}


================================================
FILE: Generation/DSA01025 - ĐẶT TÊN - 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[20], n, k;

void print()
{
    for(int i = 1; i <= k; ++i) cout << (char) (a[i] + 'A' - 1);
    cout << endl;
}

void Try(int i)
{
    for(int j = a[i - 1] + 1; j < n - k + i; ++j)
    {
        a[i] = j;
        if(i == k) print();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        ++n;
        Try(1);
    }
    return 0;
}



================================================
FILE: Generation/DSA01026 - PHÁT LỘC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string s;
int n;
char a[2] = {'6', '8'};

bool check()
{
    int cnt6 = 0, cnt8 = 0;
    for(char &i : s)
    {
        if(i == '6')
        {
            ++cnt6;
            cnt8 = 0;
        }
        else
        {
            ++cnt8;
            cnt6 = 0;
        }
        if(cnt6 > 3 or cnt8 > 1) return 0;
    }
    return 1;
}

void Try(int i)
{
    for(int j = 0; j < 2; ++j)
    {
        s[i] = a[j];
        if(i == n)
        {
            if(check()) cout << s << endl;
        }
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        s.resize(n);
        s[0] = '8';
        s.back() = '6';
        n -= 2;
        Try(1);
    }
    return 0;
}



================================================
FILE: Generation/DSA01027 - HOÁN VỊ DÃY SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        vi a(n);
        for(int &i : a) cin >> i;
        sort(all(a));
        for(int &i : a) cout << i << ' ';
        cout << endl;
        while(next_permutation(all(a)))
        {
            for(int &i : a) cout << i << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Generation/DSA01028 - LIỆT KÊ TỔ HỢP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
vi v(1, 0), a;

void print()
{
    for(int i = 1; i <= k; ++i) cout << v[a[i]] << ' ';
    cout << endl;
}

void Try(int i)
{
    for(int j = a[i - 1] + 1; j <= n - k + i; ++j)
    {
        a[i] = j;
        if(i == k) print();
        else Try(i + 1);
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        bool f[1005] = {};
        int x;
        cin >> n >> k;
        for(int i = 0; i < n; ++i)
        {
            cin >> x;
            if(!f[x])
            {
                v.pb(x);
                f[x] = 1;
            }
        }
        sort(all(v));
        n = v.sz - 1;
        a.resize(v.sz);
        Try(1);
    }
    return 0;
}


================================================
FILE: Generation/DSA02008 - CHỌN SỐ TỪ MA TRẬN VUÔNG CẤP N.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
vector<vi> a(10, vi (10));
vector<vi> ans;
vi tmp;

void Try(int i)
{
    if(i == n)
    {
        int sum = 0;
        bitset<10> f;
        int idx = 0;
        for(int &j : tmp)
        {
            if(f[j]) return;
            sum += a[idx++][j];
            f[j] = 1;
        }
        if(sum == k) ans.pb(tmp);
        return;
    }
    for(int j = 0; j < n; ++j)
    {
        tmp.pb(j);
        Try(i + 1);
        tmp.pop_back();
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        for(int i = 0; i < n; i++)
            for(int j = 0; j < n; j++)
                cin >> a[i][j];
        Try(0);
        cout << ans.sz <<endl;
        for(vector<int> &i : ans)
        {
            for(int &j : i) cout << j + 1 << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Graph/DSA09001 - CHUYỂN DANH SÁCH CẠNH SANG DANH SÁCH KỀ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, v, e, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        vector<set<int>> vs(v + 1);
        while(e--)
        {
            cin >> x >> y;
            vs[x].insert(y);
            vs[y].insert(x);
        }
        for(int i = 1; i <= v; ++i)
        {
            cout << i << ": ";
            if(vs[i].empty()) continue;
            for(auto &j : vs[i]) cout << j << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Graph/DSA09002 - CHUYỂN TỪ DANH SÁCH KỀ SANG DANH SÁCH CẠNH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, tmp;
    cin >> t;
    vector<vector<int>> v(t + 1);
    cin.ignore();
    string s;
//    while(t--)
    for(int i = 1; i <= t; ++i)
    {
        getline(cin, s);
        stringstream ss(s);
        while(ss >> s)
        {
            tmp = stoi(s);
            v[i].pb(tmp);
        }
    }
    for(int i = 1; i <= t; ++i)
    {
        sort(all(v[i]));
        for(int &j : v[i]) if(j > i) cout << i << ' ' << j << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09003 - BIỂU DIỄN ĐỒ THỊ CÓ HƯỚNG..cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, v, e, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        vector<set<int>> vs(v + 1);
        while(e--)
        {
            cin >> x >> y;
            vs[x].insert(y);
        }
        for(int i = 1; i <= v; ++i)
        {
            cout << i << ": ";
            for(auto &j : vs[i]) cout << j << ' ';
            cout << endl;
        }
    }
    return 0;
}


================================================
FILE: Graph/DSA09004 - DFS TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge(100005);
bitset<100005> visited;

void DFS(int u)
{
    visited[u] = 1;
    cout << u << ' ';
    for(int i = 0; i < edge[u].sz; ++i) if(!visited[edge[u][i]]) DFS(edge[u][i]);
}

int main()
{
    faster();
    int t = 1, n, m, x, y, u;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> u;
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
            edge[y].pb(x);
        }
        DFS(u);
        cout << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA09005 - BFS TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge(100005);
bitset<100005> visited;

void BFS(int u)
{
    queue<int> q;
    q.push(u);
    visited[u] = 1;
    while(q.sz)
    {
        u = q.front();
        cout << u << ' ';
        q.pop();
        for(int &i : edge[u])
        {
            if(!visited[i])
            {
                q.push(i);
                visited[i] = 1;
            }
        }
    }
}

int main()
{
    faster();
    int t = 1, n, m, x, y, u;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> u;
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
            edge[y].pb(x);
        }
        BFS(u);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09006 - ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ VÔ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge;
bitset<100005> visited;
vi trace;

void DFS(int u)
{
    if(visited[u]) return;
    visited[u] = 1;
    for(int &i : edge[u])
    {
        if(!visited[i])
        {
            trace[i] = u;
            DFS(i);
        }
    }
}

void findPath(int s, int e)
{
    if(!trace[e])
    {
        cout << -1;
        return;
    }
    vi res;
    while(s != e)
    {
        if(!e)
        {
            cout << -1;
            return;
        }
        res.pb(e);
        e = trace[e];
    }
    res.pb(e);
    reverse(all(res));
    for(int &i : res) cout << i << ' ';
}

int main()
{
    faster();
    int t = 1, n, m, x, y, s, e;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> s >> e;
        edge.resize(n + 1);
        trace.resize(n + 1);
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            trace[i] = 0;
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
            edge[y].pb(x);
        }
        DFS(s);
        findPath(s, e);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09007 - ĐƯỜNG ĐI THEO BFS TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge;
bitset<100005> visited;
vi trace;

void BFS(int u)
{
    queue<int> q;
    q.push(u);
    visited[u] = 1;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : edge[u])
        {
            if(!visited[i])
            {
                visited[i] = 1;
                trace[i] = u;
                q.push(i);
            }
        }
    }
}

void findPath(int s, int e)
{
    if(!trace[e])
    {
        cout << -1;
        return;
        
    }
    vi res;
    while(s != e)
    {
        if(!e)
        {
            cout << -1;
            return;
        }
        res.pb(e);
        e = trace[e];
    }
    res.pb(e);
    reverse(all(res));
    for(int &i : res) cout << i << ' ';
}

int main()
{
    faster();
    int t = 1, n, m, x, y, s, e;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> s >> e;
        edge.resize(n + 1);
        trace.resize(n + 1);
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            trace[i] = 0;
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
            edge[y].pb(x);
        }
        BFS(s);
        findPath(s, e);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09008 - ĐẾM SỐ THÀNH PHẦN LIÊN THÔNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> a(1005);
bitset<1005> bs;

inline void BFS(int x)
{
    queue<int> q;
    q.push(x);
    bs[x] = 1;
    int u;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : a[u])
        {
            if(!bs[i])
            {
                bs[i] = 1;
                q.push(i);
            }
        }
    }
}
  
int main()
{
    faster();
    int t = 1, v, e, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        for(int i = 1; i <= v; ++i)
        {
            a[i].clear();
            bs[i] = 0;
        }
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        int cnt = 0;
        for(int i = 1; i <= v; ++i)
        {
            if(!bs[i])
            {
                ++cnt;
                BFS(i);
            }
        }
        cout << cnt << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA09009 - TÌM SỐ THÀNH PHẦN LIÊN THÔNG VỚI BFS.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> a(1005);
bitset<1005> bs;

inline void BFS(int x)
{
    queue<int> q;
    q.push(x);
    bs[x] = 1;
    int u;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : a[u])
        {
            if(!bs[i])
            {
                bs[i] = 1;
                q.push(i);
            }
        }
    }
}
  
int main()
{
    faster();
    int t = 1, v, e, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        for(int i = 1; i <= v; ++i)
        {
            a[i].clear();
            bs[i] = 0;
        }
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        int cnt = 0;
        for(int i = 1; i <= v; ++i)
        {
            if(!bs[i])
            {
                ++cnt;
                BFS(i);
            }
        }
        cout << cnt << endl;
    }
    return 0;
}




================================================
FILE: Graph/DSA09010 - KIỂM TRA TÍNH LIÊN THÔNG MẠNH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline void BFS(int x, vector<vector<int>> &a, bitset<1005> &bs)
{
    queue<int> q;
    int u;
    q.push(x);
    bs[x] = 1;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : a[u])
        {
            if(!bs[i])
            {
                bs[i] = 1;
                q.push(i);
            }
        }
    }
}

inline bool check(bitset<1005> &bs, int &v)
{
    for(int i = 1; i <= v; ++i)
        if(!bs[i])
            return 0;
    return 1;
}

int main()
{
    faster();
    int t = 1, e, v, x, y;
    cin >> t;
    while(t--)
    {
        bitset<1005> bs1, bs2;
        cin >> v >> e;
        vector<vector<int>> a(v + 5), b(v + 5);
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            b[y].pb(x);
        }
        BFS(1, a, bs1);
        if(!check(bs1, v))
        {
            cout << "NO" << endl;
            continue;
        }
        BFS(1, b, bs2);
        if(check(bs2, v)) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09011 - SỐ LƯỢNG HÒN ĐẢO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};
int n, m;

vector<vector<int>> a(505, vector<int>(505));

inline bool check(int x, int y)
{
    return (x and y and x <= n and y <= m and a[x][y]);
}

inline void DFS(int x, int y)
{
    if(check(x, y))
    {
        a[x][y] = 0;
        for(int i = 0; i < 8; ++i)
            DFS(x + dx[i], y + dy[i]);
    }
}

int main()
{
    faster();
    int t = 1, ans;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                cin >> a[i][j];
        ans = 0;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= m; ++j)
            {
                if(a[i][j])
                {
                    ++ans;
                    DFS(i, j);
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09012 - LIỆT KÊ ĐỈNH TRỤ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int dis[1005], low[1005], par[1005], v, e, cnt;
bitset<1005> bs;
vector<vector<int>> a;
set<int> res;

inline void Pre()
{
    a.clear();
    res.clear();
    a.resize(v + 5);
    cnt = 1;
    bs.reset();
    memset(dis, 0, v + 5);
    memset(low, 0, v + 5);
    memset(par, 0, v + 5);
}

inline void DFS(int u)
{
    bs[u] = 1;
    int child = 0;
    dis[u] = low[u] = cnt++;
    for(int &i : a[u])
    {
        if(!bs[i])
        {
            ++child;
            par[i] = u;
            DFS(i);
            low[u] = min(low[u], low[i]);
            if(low[i] >= dis[u] and par[u]) res.insert(u);
        }
        else if(i != par[u]) low[u] = min(low[u], dis[i]);
    }
    if(child > 1 and !par[u]) res.insert(u);
}

int main()
{
    faster();
    int t = 1, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        Pre();
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        for(int i = 1; i <= v; ++i)
            if(!bs[i])
                DFS(i);
        for(int i : res) cout << i << ' ';
        cout << endl;
    }
    return 0;
}


// Brute Force
//int v, e;
//
//inline void BFS(vector<vector<int>> &a, bitset<1005> &bs, int x)
//{
//    queue<int> q;
//    q.push(x);
//    bs[x] = 1;
//    int u;
//    while(q.sz)
//    {
//        u = q.front();
//        q.pop();
//        for(int &i : a[u])
//        {
//            if(!bs[i])
//            {
//                bs[i] = 1;
//                q.push(i);
//            }
//        }
//    }
//}
//
//inline int Try(vector<pair<int, int>> &vp, int val)
//{
//    vector<vector<int>> a(v + 5);
//    bitset<1005> bs;
//    int cnt = 0;
//    for(int i = 0; i < vp.sz; ++i)
//    {
//        if(vp[i].fi == val or vp[i].se == val) continue;
//        a[vp[i].fi].pb(vp[i].se);
//        a[vp[i].se].pb(vp[i].fi);
//    }
//    for(int i = 1; i <= v; ++i)
//    {
//        if(!bs[i] and i != val)
//        {
//            ++cnt;
//            BFS(a, bs, i);
//        }
//    }
//    return cnt;
//}
//
//int main()
//{
//    faster();
//    int t = 1, x, y;
//    cin >> t;
//    while(t--)
//    {
//        cin >> v >> e;
//        vector<pair<int, int>> vp;
//        vector<vector<int>> a(v + 5);
//        bitset<1005> bs;
//        for(int i = 0; i < e; ++i)
//        {
//            cin >> x >> y;
//            a[x].pb(y);
//            a[y].pb(x);
//            vp.pb({x, y});
//        }
//        int cnt = 0;
//        for(int i = 1; i <= v; ++i)
//        {
//            if(!bs[i])
//            {
//                ++cnt;
//                BFS(a, bs, i);
//            }
//        }
//        for(int i = 0; i < vp.sz; ++i)
//            if(cnt < Try(vp, i))
//                cout << i << ' ';
//        cout << endl;
//    }
//    return 0;
//}



================================================
FILE: Graph/DSA09013 - LIỆT KÊ CẠNH CẦU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int dis[1005], low[1005], par[1005], v, e, cnt;
bitset<1005> bs;
vector<vector<int>> a;
vector<pair<int, int>> res;

inline void Pre()
{
    a.clear();
    res.clear();
    a.resize(v + 5);
    cnt = 1;
    bs.reset();
    memset(dis, 0, v + 5);
    memset(low, 0, v + 5);
    memset(par, 0, v + 5);
}

inline void DFS(int u)
{
    bs[u] = 1;
    dis[u] = low[u] = cnt++;
    for(int &i : a[u])
    {
        if(!bs[i])
        {
            par[i] = u;
            DFS(i);
            low[u] = min(low[u], low[i]);
            if(low[i] > dis[u])
            {
                if(u < i) res.pb({u, i});
                else res.pb({i, u});
            }
        }
        else if(i != par[u]) low[u] = min(low[u], dis[i]);
    }
}

int main()
{
    faster();
    int t = 1, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        Pre();
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        for(int i = 1; i <= v; ++i)
            if(!bs[i])
                DFS(i);
        sort(all(res));
        for(pair<int, int> &i : res) cout << i.fi << ' ' << i.se << ' ';
        cout << endl;
    }
    return 0;
}


// Brute Force
//int v, e;
//
//inline void BFS(vector<vector<int>> &a, bitset<1005> &bs, int x)
//{
//    queue<int> q;
//    q.push(x);
//    bs[x] = 1;
//    int u;
//    while(q.sz)
//    {
//        u = q.front();
//        q.pop();
//        for(int &i : a[u])
//        {
//            if(!bs[i])
//            {
//                bs[i] = 1;
//                q.push(i);
//            }
//        }
//    }
//}
//
//inline int Try(vector<pair<int, int>> &vp, int idx)
//{
//    vector<vector<int>> a(v + 5);
//    bitset<1005> bs;
//    int cnt = 0;
//    for(int i = 0; i < idx; ++i)
//    {
//        a[vp[i].fi].pb(vp[i].se);
//        a[vp[i].se].pb(vp[i].fi);
//    }
//    for(int i = idx + 1; i < vp.sz; ++i)
//    {
//        a[vp[i].fi].pb(vp[i].se);
//        a[vp[i].se].pb(vp[i].fi);
//    }
//    for(int i = 1; i <= v; ++i)
//    {
//        if(!bs[i])
//        {
//            ++cnt;
//            BFS(a, bs, i);
//        }
//    }
//    return cnt;
//}
//
//int main()
//{
//    faster();
//    int t = 1, x, y;
//    cin >> t;
//    while(t--)
//    {
//        cin >> v >> e;
//        vector<pair<int, int>> vp;
//        vector<vector<int>> a(v + 5);
//        bitset<1005> bs;
//        for(int i = 0; i < e; ++i)
//        {
//            cin >> x >> y;
//            a[x].pb(y);
//            a[y].pb(x);
//            vp.pb({x, y});
//        }
//        int cnt = 0;
//        for(int i = 1; i <= v; ++i)
//        {
//            if(!bs[i])
//            {
//                ++cnt;
//                BFS(a, bs, i);
//            }
//        }
//        for(int i = 0; i < vp.sz; ++i)
//        {
//            if(cnt < Try(vp, i))
//            {
//                if(vp[i].fi < vp[i].se) cout << vp[i].fi << ' ' << vp[i].se << ' ';
//                else cout << vp[i].se << ' ' << vp[i].fi << ' ';
//            }
//        }
//        cout << endl;
//    }
//    return 0;
//}


================================================
FILE: Graph/DSA09014 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ VÔ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check;

inline void DFS(int x, int par, vector<vector<int>> &a, bitset<1005> &bs)
{
    if(check) return;
    bs[x] = 1;
    for(int &i : a[x])
    {
        if(!bs[i]) DFS(i, x, a, bs);
        else if(bs[i] == 1 and i != par)
        {
            check = 1;
            return;
        }
    }
}

int main()
{
    faster();
    int t = 1, e, v, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        vector<vector<int>> a(v + 5);
        bitset<1005> bs;
        check = 0;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        for(int i = 1; i <= v; ++i)
        {
            if(check) break;
            else if(!bs[i]) DFS(i, 1, a, bs);
        }
        if(check) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA09015 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check;

inline void DFS(int x, vector<vector<int>> &a, vector<int> &b)
{
    if(check) return;
    b[x] = 1;
    for(int &i : a[x])
    {
        if(!b[i]) DFS(i, a, b);
        else if(b[i] == 1)
        {
            check = 1;
            return;
        }
    }
    b[x] = 2;
}

int main()
{
    faster();
    int t = 1, e, v, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        vector<vector<int>> a(v + 5);
        vector<int> b(v + 5, 0);
        check = 0;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        for(int i = 1; i <= v; ++i)
        {
            if(check) break;
            else if(!b[i]) DFS(i, a, b);
        }
        if(check) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09016 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG VỚI DFS.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check;

inline void DFS(int x, vector<vector<int>> &a, vector<int> &b)
{
    if(check) return;
    b[x] = 1;
    for(int &i : a[x])
    {
        if(!b[i]) DFS(i, a, b);
        else if(b[i] == 1)
        {
            check = 1;
            return;
        }
    }
    b[x] = 2;
}

int main()
{
    faster();
    int t = 1, e, v, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        vector<vector<int>> a(v + 5);
        vector<int> b(v + 5, 0);
        check = 0;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        for(int i = 1; i <= v; ++i)
        {
            if(check) break;
            else if(!b[i]) DFS(i, a, b);
        }
        if(check) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09017 - KIỂM TRA ĐỒ THỊ CÓ PHẢI LÀ CÂY HAY KHÔNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline void BFS(int x, vector<vector<int>> &a, bitset<1005> &bs, bool &check)
{
    queue<int> q;
    int u;
    q.push(x);
    bs[x] = 1;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : a[u])
        {
            if(!bs[i])
            {
                bs[i] = 1;
                q.push(i);
            }
            else
            {
                check = 1;
                return;
            }
        }
    }
}

int main()
{
    faster();
    int t = 1, e, v, x, y;
    cin >> t;
    bool check;
    while(t--)
    {
        bitset<1005> bs;
        cin >> v;
        e = v - 1;
        vector<vector<int>> a(v + 5);
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        for(int i = 1; i <= v; ++i)
        {
            check = 0;
            if(!bs[i])
                BFS(i, a, bs, check);
            if(check)
            {
                cout << "NO" << endl;
                break;
            }
        }
        if(!check) cout << "YES" << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09018 - LIỆT KÊ ĐỈNH TRỤ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int dis[1005], low[1005], par[1005], v, e, cnt;
bitset<1005> bs;
vector<vector<int>> a;
set<int> res;

inline void Pre()
{
    a.clear();
    res.clear();
    a.resize(v + 5);
    cnt = 0;
    bs.reset();
    memset(dis, 0, v + 5);
    memset(low, 0, v + 5);
    memset(par, 0, v + 5);
}

inline void DFS(int u)
{
    bs[u] = 1;
    int child = 0;
    dis[u] = low[u] = ++cnt;
    for(int &i : a[u])
    {
        if(!bs[i])
        {
            ++child;
            par[i] = u;
            DFS(i);
            low[u] = min(low[u], low[i]);
            if(par[u] and low[i] >= dis[u]) res.insert(u);
        }
        else if(i != par[u]) low[u] = min(low[u], dis[i]);
    }
    if(!par[u] and child > 1) res.insert(u);
}

int main()
{
    faster();
    int t = 1, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        Pre();
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        for(int i = 1; i <= v; ++i)
            if(!bs[i])
                DFS(i);
        for(int i : res) cout << i << ' ';
        cout << endl;
    }
    return 0;
}


// Brute Force
//int v, e;
//
//inline void BFS(vector<vector<int>> &a, bitset<1005> &bs, int x)
//{
//    queue<int> q;
//    q.push(x);
//    bs[x] = 1;
//    int u;
//    while(q.sz)
//    {
//        u = q.front();
//        q.pop();
//        for(int &i : a[u])
//        {
//            if(!bs[i])
//            {
//                bs[i] = 1;
//                q.push(i);
//            }
//        }
//    }
//}
//
//inline int Try(vector<pair<int, int>> &vp, int val)
//{
//    vector<vector<int>> a(v + 5);
//    bitset<1005> bs;
//    int cnt = 0;
//    for(int i = 0; i < vp.sz; ++i)
//    {
//        if(vp[i].fi == val or vp[i].se == val) continue;
//        a[vp[i].fi].pb(vp[i].se);
//        a[vp[i].se].pb(vp[i].fi);
//    }
//    for(int i = 1; i <= v; ++i)
//    {
//        if(!bs[i] and i != val)
//        {
//            ++cnt;
//            BFS(a, bs, i);
//        }
//    }
//    return cnt;
//}
//
//int main()
//{
//    faster();
//    int t = 1, x, y;
//    cin >> t;
//    while(t--)
//    {
//        cin >> v >> e;
//        vector<pair<int, int>> vp;
//        vector<vector<int>> a(v + 5);
//        bitset<1005> bs;
//        for(int i = 0; i < e; ++i)
//        {
//            cin >> x >> y;
//            a[x].pb(y);
//            a[y].pb(x);
//            vp.pb({x, y});
//        }
//        int cnt = 0;
//        for(int i = 1; i <= v; ++i)
//        {
//            if(!bs[i])
//            {
//                ++cnt;
//                BFS(a, bs, i);
//            }
//        }
//        for(int i = 0; i < vp.sz; ++i)
//            if(cnt < Try(vp, i))
//                cout << i << ' ';
//        cout << endl;
//    }
//    return 0;
//}


================================================
FILE: Graph/DSA09019 - KIỂM TRA CHU TRÌNH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool check;

inline void BFS(int x, int par, vector<vector<int>> &a, bitset<1005> &bs)
{
    queue<pair<int, int>> q;
    pair<int, int> u;
    q.push({x, par});
    bs[x] = 1;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : a[u.fi])
        {
            if(!bs[i])
            {
                bs[i] = 1;
                q.push({i, u.fi});
            }
            else if(bs[i] and i != u.se)
            {
                check = 1;
                return;
            }
        }
    }
}

int main()
{
    faster();
    int t = 1, e, v, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        vector<vector<int>> a(v + 5);
        bitset<1005> bs;
        check = 0;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        for(int i = 1; i <= v; ++i)
        {
            if(check) break;
            else if(!bs[i]) BFS(i, 1, a, bs);
        }
        if(check) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA09020 - CHUYỂN DANH SÁCH KỀ SANG MA TRẬN KỀ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, x;
    cin >> t;
    vector<vector<int>> a(t + 1, vi(t + 1, 0));
    //while(t--)
    cin.ignore();
    string s;
    for(int i = 1; i <= t; ++i)
    {
        getline(cin, s);
        stringstream ss(s);
        while(ss >> s)
        {
            x = stoi(s);
            a[x][i] = a[i][x] = 1;
        }
    }
    for(int i = 1; i <= t; ++i)
    {
        for(int j = 1; j <= t; ++j) cout << a[i][j] << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09021 - CHUYỂN MA TRẬN KỀ SANG DANH SÁCH KỀ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, x;
    cin >> t;
    vector<set<int>> v(t + 1);
    for(int i = 1; i <= t; ++i)
    {
        for(int j = 1; j <= t; ++j)
        {
            cin >> x;
            if(x)
            {
                v[j].insert(i);
                v[i].insert(j);
            }
        }
    }
    for(int i = 1; i <= t; ++i)
    {
        for(auto &j : v[i]) cout << j << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09022 - DFS TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge(100005);
bitset<100005> visited;

void DFS(int u)
{
    visited[u] = 1;
    cout << u << ' ';
    for(int i = 0; i < edge[u].sz; ++i) if(!visited[edge[u][i]]) DFS(edge[u][i]);
}

int main()
{
    faster();
    int t = 1, n, m, x, y, u;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> u;
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
        }
        DFS(u);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09024 - BFS TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge(100005);
bitset<100005> visited;

void BFS(int u)
{
    queue<int> q;
    q.push(u);
    visited[u] = 1;
    while(q.sz)
    {
        u = q.front();
        cout << u << ' ';
        q.pop();
        for(int &i : edge[u])
        {
            if(!visited[i])
            {
                q.push(i);
                visited[i] = 1;
            }
        }
    }
}

int main()
{
    faster();
    int t = 1, n, m, x, y, u;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> u;
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
        }
        BFS(u);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09025 - ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ CÓ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge;
bitset<100005> visited;
vi trace;

void DFS(int u)
{
    if(visited[u]) return;
    visited[u] = 1;
    for(int &i : edge[u])
    {
        if(!visited[i])
        {
            trace[i] = u;
            DFS(i);
        }
    }
}

void findPath(int s, int e)
{
    if(!trace[e])
    {
        cout << -1;
        return;
    }
    vi res;
    while(e != s)
    {
        if(!e)
        {
            cout << -1;
            return;
        }
        res.pb(e);
        e = trace[e];
    }
    res.pb(e);
    reverse(all(res));
    for(int &i : res) cout << i << ' ';
}

int main()
{
    faster();
    int t = 1, n, m, x, y, s, e;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> s >> e;
        edge.resize(n + 1);
        trace.resize(n + 1);
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            trace[i] = 0;
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
        }
        DFS(s);
        findPath(s, e);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09026 - ĐƯỜNG ĐI THEO BFS TRÊN ĐỒ THỊ CÓ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge;
bitset<100005> visited;
vi trace;

void BFS(int u)
{
    queue<int> q;
    q.push(u);
    visited[u] = 1;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : edge[u])
        {
            if(!visited[i])
            {
                q.push(i);
                trace[i] = u;
                visited[i] = 1;
            }
        }
    }
}

void findPath(int s, int e)
{
    if(!trace[e])
    {
        cout << -1;
        return;
    }
    vi res;
    while(e != s)
    {
        if(!e)
        {
            cout << -1;
            return;
        }
        res.pb(e);
        e = trace[e];
    }
    res.pb(e);
    reverse(all(res));
    for(int &i : res) cout << i << ' ';
}

int main()
{
    faster();
    int t = 1, n, m, x, y, s, e;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> s >> e;
        edge.resize(n + 1);
        trace.resize(n + 1);
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            trace[i] = 0;
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
        }
        BFS(s);
        findPath(s, e);
        cout << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA09027 - KIỂM TRA ĐƯỜNG ĐI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vi> edge;
bitset<100005> visited;
vi trace;

void DFS(int u)
{
    if(visited[u]) return;
    visited[u] = 1;
    for(int &i : edge[u])
    {
        if(!visited[i])
        {
            trace[i] = u;
            DFS(i);
        }
    }
}

int main()
{
    faster();
    int t = 1, n, m, x, y, s, e, q;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        edge.resize(n + 1);
        trace.resize(n + 1);
        for(int i = 1; i <= n; ++i)
        {
            edge[i].clear();
            trace[i] = 0;
            visited[i] = 0;
        }
        while(m--)
        {
            cin >> x >> y;
            edge[x].pb(y);
            edge[y].pb(x);
        }
        cin >> q;
        while(q--)
        {
            cin >> s >> e;
            for(int i = 1; i <= n; ++i)
            {
                visited[i] = 0;
                trace[i] = 0;
            }
            DFS(s);
            if(visited[e]) cout << "YES\n";
            else cout << "NO\n";
        }
    }
    return 0;
}


================================================
FILE: Graph/DSA09028 - TÔ MÀU ĐỒ THỊ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool cmp(pair<int, int> a, pair<int, int> b)
{
    return a.fi > b.fi;
}

inline bool check(int v, int e, int m)
{
    int dd[15][15] = {};
    int cnt[15] = {};
    int x, y;
    while(e--)
    {
        cin >> x >> y;
        cnt[x] += dd[x][y] == 0;
        cnt[y] += dd[y][x] == 0;
        dd[x][y] = dd[y][x] = 1;
    }
    vector<pair<int, int>> vp;
    for(int i = 1; i <= v; ++i)
        vp.pb({cnt[i], i});
    sort(all(vp), cmp);
    bitset<15> bs;
    int u, c = 0;
    for(pair<int, int> &i : vp)
    {
        u = i.se;
        if(!bs[u])
        {
            bs[u] = 1;
            ++c;
            // Tô các đỉnh không kề với u cùng màu với u
            for(int j = 1; j <= v; ++j)
                if(!dd[u][j])
                    bs[j] = 1;
        }
    }
    return c <= m;
}

int main()
{
    faster();
    int t, v, e, m;
    cin >> t;
    while(t--)
    {
        cin >> v >> e >> m;
        if(check(v, e, m))
            cout << "YES\n";
        else
            cout << "NO\n";
    }
    return 0;
}


================================================
FILE: Graph/DSA09029 - ĐƯỜNG ĐI HAMILTON.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bitset<15> bs;
vector<int> a[15];
bool ok;

void DFS(int u, int v, int cnt = 1)
{
    if(cnt == v)
    {
        ok = 1;
        return;
    }
    if(ok)
        return;
    for(int &i : a[u])
    {
        if(!bs[i])
        {
            bs[i] = 1;
            DFS(i, v, cnt + 1);
            bs[i] = 0;
        }
    }
}

inline bool check(int v)
{
    for(int i = 1; i <= v; ++i)
    {
        bs.reset();
        bs[i] = 1;
        DFS(i, v);
        if(ok)
            return ok;
    }
    return 0;
}

int main()
{
    faster();
    int t, v, e, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        for(int i = 0; i < 15; ++i)
            a[i].clear();
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        ok = 0;
        cout << check(v) << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09030 - ĐỒ THỊ HAI PHÍA.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[1005];
int clr[1005] = {};
bitset<1005> visited;
bool check;
int n, m;

inline void DFS(int u)
{
    visited[u] = 1;
    if(!check)
        return;
    for(int &i : a[u])
    {
        if(!visited[i])
        {
            if(!clr[i])
                clr[i] = 1 - clr[u];
            DFS(i);
        }
        else if(clr[u] == clr[i])
        {
            check = 0;
            return;
        }
    }
}

int main()
{
    faster();
    int t = 1, x, y;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        while(m--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        check = 1;
        for(int i = 1; i <= n; ++i)
        {
            visited.reset();
            DFS(i);
            if(!check)
                goto End;
        }
        End:
        if(check)
            cout << "YES\n";
        else
            cout << "NO\n";
        for(int i = 1; i <= n; ++i)
        {
            a[i].clear();
            clr[i] = 0;
        }
    }
    return 0;
}


================================================
FILE: Graph/DSA09031 - CHÚ CỪU XA CÁCH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m, k;
vector<pair<pair<int, int>, pair<int, int>>> vp;
vector<pair<int, int>> a;
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};
int f[105][105] = {};
int idx = 0;
int C[100005] = {};

inline bool check(int u, int v, int x, int y)
{
    if(x < 1 or x > n or y < 1 or y > n)
        return 0;
    if(f[x][y])
        return 0;
    for(pair<pair<int, int>, pair<int, int>> &i : vp)
        if((i.fi == mp(u, v) and i.se == mp(x, y)) or (i.fi == mp(x, y) and i.se == mp(u, v)))
            return 0;
    return 1;
}

inline void BFS(int x, int y)
{
    f[x][y] = idx;
    queue<pair<int, int>> q;
    pair<int, int> top;
    q.push({x, y});
    while(q.sz)
    {
        top = q.front();
        q.pop();
        for(int i = 0; i < 4; ++i)
        {
            if(check(top.fi, top.se, top.fi + dx[i], top.se + dy[i]))
            {
                f[top.fi + dx[i]][top.se + dy[i]] = idx;
                q.push({top.fi + dx[i], top.se + dy[i]});
            }
        }
    }
}

int main()
{
    faster();
    cin >> n >> k >> m;
    int u, v, x, y;
    vp.resize(m);
    a.resize(k);
    for(int i = 0; i < m; ++i)
    {
        cin >> u >> v >> x >> y;
        vp[i].fi = {u, v};
        vp[i].se = {x, y};
    }
    for(int i = 0; i < k; ++i)
    {
        cin >> x >> y;
        a[i] = {x, y};
    }
    ll res = 0;
    for(int i = 0; i < a.sz; ++i)
    {
        if(!f[a[i].fi][a[i].se])
        {
            ++idx;
            BFS(a[i].fi, a[i].se);
        }
    }
    ll cnt;
    for(pair<int, int> &i : a)
        ++C[f[i.fi][i.se]];
    for(int i = 1; i <= idx; ++i)
    {
        cnt = 0;
        for(int j = i + 1; j <= idx; ++j)
            cnt += C[j];
        res += C[i] * cnt;
    }
    cout << res;
    return 0;
}



================================================
FILE: Graph/DSA09032 - KẾT BẠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int Root[100005], Size[100005];
int n, m;

inline int findRoot(int x)
{
    if(x == Root[x])
        return x;
    return Root[x] = findRoot(Root[x]);
}

inline void Union(int x, int y)
{
    int rootX = findRoot(x), rootY = findRoot(y);
    if(rootX != rootY)
    {
        if(Size[rootX] < Size[rootY])
            swap(rootX, rootY);
        Root[rootY] = rootX;
        Size[rootX] += Size[rootY];
    }
}

int main()
{
    faster();
    int t, x, y;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        for(int i = 1; i <= n; ++i)
        {
            Root[i] = i;
            Size[i] = 1;
        }
        int MAX = -1;
        while(m--)
        {
            cin >> x >> y;
            Union(x, y);
        }
        for(int i = 1; i <= n; ++i)
            MAX = max(MAX, Size[Root[i]]);
        cout << MAX << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA09033 - MẠNG XÃ HỘI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string solve(int v, int e)
{
    int x, y;
    vector<int> a[v + 5];
    while(e--)
    {
        cin >> x >> y;
        a[x].pb(y);
        a[y].pb(x);
    }
    for(int i = 1; i <= v; ++i)
    {
        for(int &j : a[i])
            if(a[i].sz != a[j].sz)
                return "NO";
    }
    return "YES";
}

int main()
{
    faster();
    int t, v, e;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        cout << solve(v, e) << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA09034 - ĐẾM SỐ AO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m;
int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};
vector<string> vs;

inline bool check(int x, int y)
{
    return (x >= 0 and y >= 0 and x < n and y < m and vs[x][y] == 'W');
}

void DFS(int x, int y)
{
    vs[x][y] = '.';
    for(int i = 0; i < 8; ++i)
        if(check(x + dx[i], y + dy[i]))
            DFS(x + dx[i], y + dy[i]);
}

int main()
{
    faster();
    cin >> n >> m;
    vs.resize(n);
    for(int i = 0; i < n; ++i)
        cin >> vs[i];
    int res = 0;
    for(int i = 0; i < n; ++i)
    {
        for(int j = 0; j < m; ++j)
        {
            if(vs[i][j] == 'W')
            {
                ++res;
                DFS(i, j);
            }
        }
    }
    cout << res;
    return 0;
}



================================================
FILE: Graph/DSA09037 - HỌP MẶT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int k, v, e;
vector<int> a[1005];
bitset<1005> bs;
vector<int> vk;

inline void DFS(int u)
{
    bs[u] = 1;
    for(int &i : a[u])
        if(!bs[i])
            DFS(i);
}

inline bool check(int x)
{
    bs.reset();
    DFS(x);
    for(int &i : vk)
        if(!bs[i])
            return 0;
    return 1;
}

int main()
{
    faster();
    cin >> k >> v >> e;
    int x, y;
    while(k--)
    {
        cin >> x;
        vk.pb(x);
    }
    while(e--)
    {
        cin >> x >> y;
        a[x].pb(y);
    }
    int cnt = 0;
    for(int i = 1; i <= v; ++i)
        cnt += check(i);
    cout << cnt;
    return 0;
}


================================================
FILE: Graph/DSA09049 - LAN TRUYỀN DINH DƯỠNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll val[200005], sum[200005];
vector<int> a[200005];

inline void DFS(int u)
{
    for(int &i : a[u])
    {
        DFS(i);
        sum[u] += sum[i] + 1;
        val[u] += val[i];
    }
    val[u] += sum[u];
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    int n, x;
    while(t--)
    {
        cin >> n;
        for(int i = 1; i <= n; ++i)
        {
            val[i] = 1;
            sum[i] = 0;
        }
        for(int i = 2; i <= n; ++i)
        {
            cin >> x;
            a[x].pb(i);
        }
        DFS(1);
        for(int i = 1; i <= n; ++i)
            cout << val[i] << ' ';
    }
    return 0;
}


================================================
FILE: Graph/DSA10001 - TÌM ĐƯỜNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m;
pair<int, int> s;
bool check;

inline void BFS(vector<string> &vs)
{
    if(vs[s.fi][s.se] == 'T')
    {
        check = 1;
        return;
    }
    int f[505][505] = {}, idx, up = 0, down = n - 1, left = 0, right = m - 1;
    pair<int, int> u, v;
    queue<pair<int, int>> q;
    q.push(s);
    while(q.sz)
    {
        u = q.front();
        q.pop();
        if(f[u.fi][u.se] > 2) return;
        idx = u.fi;
        while(idx > up)
        {
            v.fi = idx - 1;
            v.se = u.se;
            if(vs[v.fi][v.se] == '*') break;
            else if(vs[v.fi][v.se] == 'T')
            {
                check = 1;
                return;
            }
            else if(!f[v.fi][v.se])
            {
                f[v.fi][v.se] = f[u.fi][u.se] + 1;
                q.push(v);
            }
            --idx;
        }
        idx = u.fi;
        while(idx < down)
        {
            v.fi = idx + 1;
            v.se = u.se;
            if(vs[v.fi][v.se] == '*') break;
            else if(vs[v.fi][v.se] == 'T')
            {
                check = 1;
                return;
            }
            else if(!f[v.fi][v.se])
            {
                f[v.fi][v.se] = f[u.fi][u.se] + 1;
                q.push(v);
            }
            ++idx;
        }
        idx = u.se;
        while(idx > left)
        {
            v.fi = u.fi;
            v.se = idx - 1;
            if(vs[v.fi][v.se] == '*') break;
            else if(vs[v.fi][v.se] == 'T')
            {
                check = 1;
                return;
            }
            else if(!f[v.fi][v.se])
            {
                f[v.fi][v.se] = f[u.fi][u.se] + 1;
                q.push(v);
            }
            --idx;
        }
        idx = u.se;
        while(idx < right)
        {
            v.fi = u.fi;
            v.se = idx + 1;
            if(vs[v.fi][v.se] == '*') break;
            else if(vs[v.fi][v.se] == 'T')
            {
                check = 1;
                return;
            }
            else if(!f[v.fi][v.se])
            {
                f[v.fi][v.se] = f[u.fi][u.se] + 1;
                q.push(v);
            }
            ++idx;
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        cin.ignore();
        vector<string> vs(n);
        for(int i = 0; i < n; ++i) getline(cin, vs[i]);
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                if(vs[i][j] == 'S') s = {i, j};
        check = 0;
        BFS(vs);
        if(check) cout << "YES" << endl;
        else cout << "NO" << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA10003 - KIỂM TRA CHU TRÌNH SỬ DỤNG DISJOIN SET.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int root[1005];

inline int findRoot(int u)
{
    if(u == root[u])
        return u;
    root[u] = findRoot(root[u]);
    return root[u];
}

inline bool check(vector<pair<int, int>> &vp)
{
    int rootU, rootV;
    for(pair<int, int> &i : vp)
    {
        rootU = findRoot(i.fi);
        rootV = findRoot(i.se);
        if(rootU == rootV)
            return 1;
        root[rootU] = rootV;
    }
    return 0;
}

int main()
{
    faster();
    int t = 1, e, v, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        for(int i = 1; i <= v; ++i)
            root[i] = i;
        vector<pair<int, int>> vp;
        while(e--)
        {
            cin >> x >> y;
            vp.pb({x, y});
        }
        if(check(vp))
            cout << "YES" << endl;
        else
            cout << "NO" << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA10004 - ĐƯỜNG ĐI VÀ CHU TRÌNH EULER VỚI ĐỒ THỊ VÔ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, v, e, x, y;
    cin >> t;
    while(t--)
    {
        int deg[1005] = {};
        cin >> v >> e;
        while(e--)
        {
            cin >> x >> y;
            ++deg[x];
            ++deg[y];
        }
        int cnt = 0;
        for(int i = 1; i <= v; ++i)
            cnt += deg[i] & 1;
        if(!cnt)
            cout << 2 << endl;
        else if(cnt == 2)
            cout << 1 << endl;
        else
            cout << 0 << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA10005 - CHU TRÌNH EULER TRONG ĐỒ THỊ CÓ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, v, e, x, y;
    cin >> t;
    while(t--)
    {
        int degc[1005] = {}, degt[1005] = {};
        cin >> v >> e;
        while(e--)
        {
            cin >> x >> y;
            ++degc[x];
            ++degt[y];
        }
        int cnt = 0;
        bool check = 1;
        for(int i = 1; i <= v; ++i)
        {
            cnt += (abs(degc[i] - degt[i]) == 1);
            if(cnt > 2 or abs(degc[i] - degt[i]) > 1 or !degc[i] or !degt[i])
            {
                check = 0;
                break;
            }
        }
        if(check)
            cout << 1 << endl;
        else
            cout << 0 << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA10006 - CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN DFS.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline void DFS(int x, vector<vector<int>> &a, bitset<1005> &bs, vector<pair<int, int>> &vp)
{
    bs[x] = 1;
    for(int &i : a[x])
    {
        if(!bs[i])
        {
            vp.pb({x, i});
            DFS(i, a, bs, vp);
        }
    }
}

int main()
{
    faster();
    int t = 1, e, v, u, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e >> u;
        vector<vector<int>> a(v + 5);
        bitset<1005> bs;
        vector<pair<int, int>> res;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        DFS(u, a, bs, res);
        if(res.sz == v - 1)
            for(pair<int, int> &i : res)
                cout << i.fi << ' ' << i.se << endl;
        else cout << -1 << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA10007 - CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN BFS.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline void BFS(int x, vector<vector<int>> &a, bitset<1005> &bs, vector<pair<int, int>> &vp)
{
    queue<int> q;
    bs[x] = 1;
    int u;
    q.push(x);
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : a[u])
        {
            if(!bs[i])
            {
                bs[i] = 1;
                q.push(i);
                vp.push_back({u, i});
            }
        }
    }
}

int main()
{
    faster();
    int t = 1, e, v, u, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e >> u;
        vector<vector<int>> a(v + 5);
        bitset<1005> bs;
        vector<pair<int, int>> res;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        BFS(u, a, bs, res);
        if(res.sz == v - 1)
            for(pair<int, int> &i : res)
                cout << i.fi << ' ' << i.se << endl;
        else cout << -1 << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA10008 - DIJKSTRA.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    int v, e, u, x, y, z;
    while(t--)
    {
        cin >> v >> e >> u;
        vector<pair<int, int>> a[v + 5];
        while(e--)
        {
            cin >> x >> y >> z;
            a[x].pb({y, z});
            a[y].pb({x, z});
        }
        int dist[v + 5];
        for(int i = 1; i <= v; ++i)
            dist[i] = INT_MAX;
        dist[u] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, u});
        pair<int, int> top;
        while(pq.sz)
        {
            top = pq.top();
            pq.pop();
            if(top.fi <= dist[top.se])
            {
                for(pair<int, int> &i : a[top.se])
                {
                    if(dist[i.fi] > dist[top.se] + i.se)
                    {
                        dist[i.fi] = dist[top.se] + i.se;
                        pq.push({dist[i.fi], i.fi});
                    }
                }
            }
        }
        for(int i = 1; i <= v; ++i)
            cout << dist[i] << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA10009 - FLOYD.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int n, m;
    cin >> n >> m;
    int F[n + 5][n + 5];
    int x, y, z;
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= n; ++j)
            F[i][j] = 1e9;
        F[i][i] = 0;
    }
    while(m--)
    {
        cin >> x >> y >> z;
        F[x][y] = F[y][x] = z;
    }
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= n; ++j)
            for(int z = 1; z <= n; ++z)
                F[j][z] = min(F[j][z], F[i][j] + F[i][z]);
    int t;
    cin >> t;
    while(t--)
    {
        cin >> x >> y;
        cout << F[x][y] << endl;
    }
    return 0;
}



================================================
FILE: Graph/DSA10011 - DI CHUYỂN TRÊN BẢNG SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m;
int a[505][505];

int dx[] = {0, 0, -1, 1};
int dy[] = {-1, 1, 0, 0};

struct cmp
{
    bool operator () (pair<int, pair<int, int>> a, pair<int, pair<int, int>> b)
    {
        return a.se.se > b.se.se;
    }
};

inline int BFS()
{
    int visited[505][505] = {};
    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, cmp> pq;
    pair<int, pair<int, int>> top;
    pq.push({1, {1, a[1][1]}});
    visited[1][1] = 1;
    int x, y;
    while(pq.sz)
    {
        top = pq.top();
        pq.pop();
        for(int i = 0; i < 4; ++i)
        {
            x = top.fi + dx[i];
            y = top.se.fi + dy[i];
            if(x == n and y == m)
                return top.se.se + a[x][y];
            if(x >= 1 and x <= n and y >= 1 and y <= m and !visited[x][y])
            {
                visited[x][y] = 1;
                pq.push({x, {y, top.se.se + a[x][y]}});
            }
        }
    }
    return -1;
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                cin >> a[i][j];
        cout << BFS() << endl;
    }
    return 0;
}


================================================
FILE: Graph/DSA10012 - ĐƯỜNG ĐI TRUNG BÌNH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m;
bitset<1005> visited;
vector<int> a[1005];

inline int BFS(int u, int v)
{
    queue<pair<int, int>> q;
    q.push({u, 0});
    visited[u] = 1;
    pair<int, int> top;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        for(int &i : a[top.fi])
        {
            if(!visited[i])
            {
                visited[i] = 1;
                if(i == v)
                    return top.se + 1;
                q.push({i, top.se + 1});
            }
        }
    }
    return -1;
}

int main()
{
    faster();
    int t = 1, x, y;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        while(m--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        double res = 0;
        int cnt = 0, val;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = 1; j <= n; ++j)
            {
                if(i - j)
                {
                    val = BFS(i, j);
                    if(val != -1)
                    {
                        res += val;
                        ++cnt;
                    }
                    visited.reset();
                }
            }
        }
        cout << setprecision(2) << fixed << res / cnt << endl;
        for(int i = 1; i <= n; ++i)
            a[i].clear();
        visited.reset();
    }
    return 0;
}


================================================
FILE: Graph/DSA10015 - KRUSKAL.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int Root[105];
int Size[105];
int res, v, e;
vector<pair<pair<int, int>, int>> vp;

inline int findRoot(int x)
{
    if(x == Root[x])
        return x;
    return Root[x] = findRoot(Root[x]);
}

inline void Union(int x, int y, pair<pair<int, int>, int> p)
{
    int rootX = findRoot(x), rootY = findRoot(y);
    if(rootX != rootY)
    {
        res += p.se;
        if(Size[rootX] < Size[rootY])
            swap(rootX, rootY);
        Root[rootY] = rootX;
        Size[rootX] += Size[rootY];
    }
}

inline bool cmp(pair<pair<int, int>, int> a, pair<pair<int, int>, int> b)
{
    return a.se < b.se;
}

int main()
{
    faster();
    int t, x, y, z;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        for(int i = 1; i <= v; ++i)
        {
            Root[i] = i;
            Size[i] = 1;
        }
        while(e--)
        {
            cin >> x >> y >> z;
            vp.push_back({{x, y}, z});
        }
        sort(all(vp), cmp);
        res = 0;
        for(pair<pair<int, int>, int> &i : vp)
            Union(i.fi.fi, i.fi.se, i);
        cout << res << endl;
        vp.clear();
    }
    return 0;
}



================================================
FILE: Graph/DSA10016 - NỐI ĐIỂM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
int Root[105];
map<int, pair<double, double>> m;

struct Element
{
    int a, b;
    double dist;
};

int root(int i)
{
    if (Root[i] == -1) return i;
    else
    {
        int x = root(Root[i]);
        Root[i] = x;
        return x;
    }
}

bool cmp3(Element a, Element b)
{
    return a.dist < b.dist;
}

double calc(int i, int j)
{
    double a1 = m[i].fi, b1 = m[i].se, a2 = m[j].fi, b2 = m[j].se;
    return sqrt((a1 - a2) * (a1 - a2) + (b1 - b2) * (b1 - b2));
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        Element a[10005];
        cin >> n;
        pair<double, double> A;
        double MAX = 0;
        int idx = 0;
        for(int i = 1; i <= n; ++i)
        {
            cin >> A.fi >> A.se;
            m[i] = A;
        }
        Element P;
        for(int i = 1; i <= n; ++i)
        {
            for(int j = i + 1; j <= n; ++j)
            {
                P = {i, j};
                P.dist = calc(i, j);
                a[idx] = P;
                ++idx;
            }
        }
        sort(a, a + idx, cmp3);
        for(int i = 0; i <= n; ++i)
            Root[i] = -1;
        int p, q;
        for(int i = 0; i < idx; ++i)
        {
            P = a[i];
            p = root(P.a);
            q = root(P.b);
            if(p != q)
            {
                Root[p] = q;
                MAX += P.dist;
            }
        }
        cout << setprecision(6) << fixed << MAX << endl;
        m.clear();
    }
    return 0;
}



================================================
FILE: Graph/DSA10017 - CHU TRÌNH ÂM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[1005];
bitset<1005> visited;
int w[1005][1005];
bool check;

inline bool BFS(int u)
{
    queue<pair<int, int>> q;
    q.push({u, 0});
    visited[u] = 1;
    pair<int, int> top;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        for(int &i : a[top.fi])
        {
            if(!visited[i])
            {
                q.push({i, top.se + w[top.fi][i]});
                visited[i] = 1;
            }
            else if(i == u and top.se + w[top.fi][i] < 0)
                return 1;
        }
    }
    return 0;
}

int main()
{
    faster();
    int t = 1, v, e, x, y, z;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        while(e--)
        {
            cin >> x >> y >> z;
            a[x].pb(y);
            w[x][y] = z;
        }
        check = 0;
        for(int i = 1; i <= v; ++i)
        {
            check = BFS(i);
            if(check)
                goto End;
            visited.reset();
        }
        End:
        cout << check << endl;
        for(int i = 1; i <= v; ++i)
            a[i].clear();
        visited.reset();
    }
    return 0;
}


================================================
FILE: Graph/TN05009 - CHU TRÌNH THEO DFS.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<vector<int>> a;
bitset<1005> bs;
bool check;
int trace[1005];
int en;

void DFS(int u, int par)
{
    if(check)
        return;
    bs[u] = 1;
    for(int &i : a[u])
    {
        if(!bs[i])
        {
            trace[i] = u;
            DFS(i, u);
        }
        else
        {
            if(i != trace[u] and i == 1)
            {
                check = 1;
                en = u;
                return;
            }
        }
    }
}

int main()
{
    faster();
    int t, v, e, x, y;
    cin >> t;
    while(t--)
    {
        memset(trace, 0, sizeof(trace));
        cin >> v >> e;
        a.resize(v + 5);
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        for(int i = 1; i <= v; ++i)
            sort(all(a[i]));
        check = 0;
        DFS(1, 0);
        if(check)
        {
            stack<int> st;
            cout << 1 << ' ';
            while(trace[en])
            {
                st.push(en);
                en = trace[en];
            }
            while(st.sz)
            {
                cout << st.top() << ' ';
                st.pop();
            }
            cout << 1;
        }
        else
            cout << "NO";
        bs.reset();
        a.clear();
        cout << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03001 - ĐỔI TIỀN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, idx;
    int a[] = {1, 2, 5, 10, 20, 50, 100, 200, 500, 1000};
    cin >> t;
    ll x;
    while(t--)
    {
        cin >> n;
        int cnt = 0, i = 9;
        while(n)
        {
            cnt += n / a[i];
            n %= a[i];
            --i;
        }
        cout << cnt << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03002 - NHẦM CHỮ SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int m(string &s)
{
    int res = 0;
    for(char &i : s)
    {
        if(i == '6') i = '5';
        res = res * 10 + i - '0';
    }
    return res;
}

inline int M(string &s)
{
    int res = 0;
    for(char &i : s)
    {
        if(i == '5') i = '6';
        res = res * 10 + i - '0';
    }
    return res;
}

int main()
{
    faster();
    int t = 1;
    string a, b;
    //cin >> t;
    while(t--)
    {
        cin >> a >> b;
        cout << m(a) + m(b) << ' ' << M(a) + M(b) << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03003 - TÌM MAX.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, mod = 1e9 + 7;
    cin >> t;
    while(t--)
    {
        ll sum = 0;
        cin >> n;
        vi v(n);
        for(int &i : v) cin >> i;
        sort(all(v));
        for(int i = 0; i < n; ++i)
        {
            sum += 1LL * v[i] * i;
            sum %= mod;
        }
        cout << sum << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03004 - TỔNG NHỎ NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    ll a, b;
    while(t--)
    {
        priority_queue<int, vi, greater<int>> pq;
        cin >> n;
        while(n--)
        {
            cin >> x;
            pq.push(x);
        }
        a = b = 0;
        bool check = 0;
        while(pq.sz)
        {
            if(!check) a = a * 10 + pq.top();
            else b = b * 10 + pq.top();
            pq.pop();
            check ^= 1;
        }
        cout << a + b << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03005 - CHIA MẢNG THÀNH HAI MẢNG CON CÓ TỔNG LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        int sum = 0, tmp = 0;
        vi v(n);
        for(int &i : v)
        {
            cin >> i;
            sum += i;
        }
        sort(all(v));
        k = min(k, n - k);
        for(int i = 0; i < k; ++i) tmp += v[i];
        cout << sum - (tmp << 1) << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03006 - SẮP XẾP THAM LAM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline string calc(vi &a, vi &b)
{
    for(int i = 0; i < a.sz; ++i) if(a[i] != b[i] and a[i] != b[a.sz - i - 1]) return "No";
        return "Yes";
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n), b(n);
        for(int &i : a) cin >> i;
        b = a;
        sort(all(b));
        cout << calc(a, b) << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03007 - GIÁ TRỊ NHỎ NHẤT CỦA BIỂU THỨC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    ll res;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ll a[n], b[n];
        for(ll &i : a) cin >> i;
        for(ll &i : b) cin >> i;
        sort(a, a + n);
        sort(b, b + n, greater<int>());
        res = 0;
        for(int i = 0; i < n; ++i) res += a[i] * b[i];
        cout << res << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03008 - SẮP XẾP CÔNG VIỆC 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool cmp(pair<int, int> a, pair<int, int> b)
{
    return a.se < b.se;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<pair<int, int>> vp(n);
        for(int i = 0; i < n; ++i) cin >> vp[i].fi;
        for(int i = 0; i < n; ++i) cin >> vp[i].se;
        sort(all(vp), cmp);
        int cnt = 1, cur = vp[0].se;
        for(int i = 1; i < n; ++i)
        {
            if(vp[i].fi >= cur)
            {
                ++cnt;
                cur = vp[i].se;
            }
        }
        cout << cnt << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03009 - SẮP XẾP CÔNG VIỆC 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool cmp(pair<int, int> a, pair<int, int> b)
{
    return a.se > b.se;
}

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<pair<int, int>> v(n);
        for(pair<int, int> &i : v) cin >> x >> i.fi >> i.se;
        sort(all(v), cmp);
        bitset<1005> bs;
        int cnt = 0, total = 0;
        for(pair<int, int> &i : v)
        {
            while(bs[i.fi] and i.fi) --i.fi;
            if(!bs[i.fi] and i.fi)
            {
                ++cnt;
                total += i.se;
                bs[i.fi] = 1;
            }
        }
        cout << cnt << ' ' << total << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03010 - NỐI DÂY 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, tmp;
    cin >> t;
    while(t--)
    {
        ll sum = 0;
        cin >> n;
        priority_queue<int, vi, greater<int>> pq;
        while(n--)
        {
            cin >> tmp;
            pq.push(tmp);
        }
        while(pq.sz > 1)
        {
            tmp = pq.top();
            pq.pop();
            tmp += pq.top();
            pq.pop();
            sum += tmp;
            pq.push(tmp);
        }
        cout << sum << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03011 - NỐI DÂY 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, mod = 1e9 + 7, sum, tmp;
    cin >> t;
    while(t--)
    {
        cin >> n;
        priority_queue<int, vector<int>, greater<int>> pq;
        while(n--)
        {
            cin >> tmp;
            pq.push(tmp);
        }
        sum = 0;
        while(pq.sz > 1)
        {
            tmp = pq.top();
            pq.pop();
            tmp += pq.top();
            pq.pop();
            if(tmp >= mod) tmp -= mod;
            sum += tmp;
            if(sum >= mod) sum -= mod;
            pq.push(tmp);
        }
        cout << sum << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03012 - SẮP ĐẶT XÂU KÝ TỰ 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int check(string &s)
{
    int f[130] = {};
    int MAX = 0;
    F(i, 0, s.length())
    {
        ++f[s[i]];
        MAX = max(f[s[i]], MAX);
    }
    if (MAX <= s.length() - MAX + 1) return 1;
    return -1;
}

int main()
{
    faster();
    int t = 1;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> s;
        cout << check(s) << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03013 - SẮP ĐẶT XÂU KÝ TỰ 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        int n, res = 0;
        cin >> n;
        int dd[30] = {};
        string s;
        cin >> s;
        for(char &i : s) ++dd[i - 'A'];
        for(int i = 0; i < 26; i++) res = max(res, dd[i]);
        int k = s.sz - (n - 1) * (res - 1);
        if(res <= k) cout << 1;
        else cout << -1;
        cout << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03014 - SỐ KHỐI LẬP PHƯƠNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vll v;

string calc(string &s)
{
    string tmp;
    for(ll &i : v)
    {
        tmp = to_string(i);
        int idx = 0;
        for(char &j : s) if(j == tmp[idx]) ++idx;
        if(idx == tmp.sz) return tmp;
    }
    return to_string(-1);
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    for(int i = 1e2; i; --i) v.pb(i * i * i);
    string s;
    while(t--)
    {
        cin >> s;
        cout << calc(s) << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03015 - MUA LƯƠNG THỰC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int binSearch(int n, int m, int s)
{
    int res = -1, mid, l = 1, r = s;
    while(l <= r)
    {
        mid = (l + r) >> 1;
        if((mid - mid / 7) * n >= s * m)
        {
            res = mid;
            r = mid - 1;
        }
        else l = mid + 1;
    }
    if(res != -1) res -= res / 7;
    return res;
}

int main()
{
    faster();
    int t = 1, n, m, s;
    cin >> t;
    while(t--)
    {
        cin >> n >> s >> m;
        cout << binSearch(n, m, s) << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03016 - SỐ NHỎ NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, s, d;
    cin >> t;
    while(t--)
    {
        cin >> s >> d;
        stack<int> st;
        if(d == 1 && s == 0) cout << 0;
        if(s == 0 || d * 9 < s) cout << -1;
        else
        {
            --s;
            while(d--)
            {
                if(s >= 9)
                {
                    st.push(9);
                    s -= 9;
                }
                else if (s > 0)
                {
                    st.push(s);
                    s = 0;
                }
                else st.push(0);
            }
            cout << st.top() + 1;
            st.pop();
            while (!st.empty())
            {
                cout << st.top();
                st.pop();
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03017 - GIÁ TRỊ NHỎ NHẤT CỦA XÂU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll cnt(string &s, int k)
{
    ll f[26] = {};
    for(char &i : s) ++f[i - 'A'];
    priority_queue<ll> pq;
    for(int i = 0; i < 26; ++i) pq.push(f[i]);
    ll tmp;
    while(k--)
    {
        tmp = pq.top();
        pq.pop();
        --tmp;
        pq.push(tmp);
    }
    ll sum = 0;
    while(!pq.empty())
    {
        tmp = pq.top();
        sum += tmp * tmp;
        pq.pop();
    }
    return sum;
}

int main()
{
    faster();
    int t = 1, k;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> k >> s;
        cout << cnt(s, k) << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03018 - SỐ MAY MẮN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, num4, num7;
    cin >> t;
    while(t--)
    {
        cin >> n;
        num7 = n / 7;
        while(num7 >= 0)
        {
            if((n - num7 * 7) % 4 == 0)
            {
                num4 = (n - num7 * 7) >> 2;
                break;
            }
            --num7;
        }
        if(num7 >= 0)
        {
            while(num4--) cout << 4;
            while(num7--) cout << 7;
        }
        else cout << -1;
        cout << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03019 - PHÂN SỐ ĐƠN VỊ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline void solve(ll p, ll q)
{
    ll x = 0;
    while(1)
    {
        if(q % p == 0)
        {
            cout << "1/" << q / p << endl;
            return;
        }
        x = q / p + 1;
        cout << "1/" << x << " + ";
        p = x * p - q;
        q *= x;
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    ll p, q;
    while(t--)
    {
        cin >> p >> q;
        solve(p, q);
    }
    return 0;
}


================================================
FILE: Greedy/DSA03020 - BIỂU THỨC ĐÚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> s;
        stack<char> st;
        int cnt = 0, res = 0;
        for(char &i : s)
        {
            if(st.empty())
            {
                st.push(i);
                cnt = 0;
            }
            else if(st.top() == '[' and i == ']')
            {
                cnt += 2;
                st.pop();
            }
            else if(st.top() == ']' and i == '[')
            {
                res += st.sz + cnt;
                st.pop();
            }
            else if(i == ']' and st.top() == ']') st.push(i);
            else if(i == '[') st.push(i);
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03021 - TÌM DÃY SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool check(int n, vi &v)
{
    for(int &i : v) if(i / n == i / (n + 1)) return 0;
    return 1;
}

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n), b(n), c(n);
        for(int &i : a) cin >> i;
        b = c = a;
        sort(all(b));
        for(int i = b[0]; i; --i)
        {
            if(check(i, a))
            {
                for(int j = 0; j < n; ++j) c[j] = a[j] / (i + 1) + 1;
                break;
            }
        }
        int res = 0;
        for(int &i : c) res += i;
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03022 - TÍCH LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int n;
    cin >> n;
    int M1, M2, M3, m1, m2, m3;
    M1 = M2 = M3 = INT_MIN;
    m1 = m2 = m3 = INT_MAX;
    while(cin >> n)
    {
        if(n > M1)
        {
            M3 = M2;
            M2 = M1;
            M1 = n;
        }
        else if(n > M2)
        {
            M3 = M2;
            M2 = n;
        }
        else if(n > M3) M3 = n;
        if(n < m1)
        {
            m3 = m2;
            m2 = m1;
            m1 = n;
        }
        else if(n < m2)
        {
            m3 = m2;
            m2 = n;
        }
        else if(n < m3) m3 = n;
    }
    cout << max(M1 * M2 * M3, max(m1 * m2 * M1, max(m1 * m2, M1 * M2)));
    return 0;
}



================================================
FILE: Greedy/DSA03023 - SẮP XẾP VIÊN BI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int res = 0;
string s;
int f[3] = {};

inline void solve(int a, int b, int idx, char c)
{
    for(int i = a; i < b; ++i)
    {
        if(s[i] == c)
        {
            swap(s[idx], s[i]);
            ++res;
            return;
        }
    }
}

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        cin >> n >> s;
        for(char &i : s)
        {
            if(i == 'X') ++f[0];
            else if(i == 'T') ++f[1];
            else ++f[2];
        }
        for(int i = 0; i < f[0]; ++i)
        {
            if(s[i] == 'T') solve(f[0], n, i, 'X');
            else if(s[i] == 'D')
            {
                for(int j = n - 1; j >= f[0]; --j)
                {
                    if(s[j] == 'X')
                    {
                        swap(s[i], s[j]);
                        ++res;
                        break;
                    }
                }
            }
       }
        for(int i = f[0]; i < f[0] + f[1]; ++i) if(s[i] == 'D') solve(f[0] + f[1], n, i, 'T');
        cout << res;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03024 - LỰA CHỌN TỐI ƯU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool cmp(pair<int, int> a, pair<int, int> b)
{
    return a.se < b.se;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<pair<int, int>> vp(n);
        F(i, 0, n) cin >> vp[i].fi >> vp[i].se;
        sort(all(vp), cmp);
        int cnt = 0;
        int last = 0;
        for(pair<int, int> i : vp)
        {
            if(i.first < last) continue;
            last = i.second;
            ++cnt;
        }
        cout << cnt << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03025 - TRỤC TỌA ĐỘ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool cmp(pair<int, int> a, pair<int, int> b)
{
    if(a.se == b.se) return a.fi < b.fi;
    return a.se < b.se;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<pair<int, int>> vp(n);
        F(i, 0, n) cin >> vp[i].fi >> vp[i].se;
        sort(all(vp), cmp);
        int cnt = 0;
        int last = 0;
        for(pair<int, int> i : vp)
        {
            if(i.first < last) continue;
            last = i.second;
            ++cnt;
        }
        cout << cnt << endl;
    }
    return 0;
}



================================================
FILE: Greedy/DSA03026 - LỰA CHỌN THAM LAM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, s;
    //cin >> t;
    while(t--)
    {
        cin >> n >> s;
        if(s <= n * 9 and s)
        {
            stack<int> st;
            queue<int> q;
            while(s)
            {
                if(s > 9)
                {
                    st.push(9);
                    q.push(9);
                    s -= 9;
                }
                else
                {
                    st.push(s);
                    q.push(s);
                    break;
                }
            }
            if(st.sz < n and st.top() > 1)
            {
                int tmp = st.top();
                st.pop();
                st.push(tmp - 1);
                st.push(1);
            }
            int s = st.sz;
            cout << st.top();
            st.pop();
            while(s < n)
            {
                cout << 0;
                ++s;
            }
            while(st.sz)
            {
                cout << st.top();
                st.pop();
            }
            cout << ' ';
            s = q.sz;
            while(q.sz)
            {
                cout << q.front();
                q.pop();
            }
            while(s < n)
            {
                cout << 0;
                ++s;
            }
        }
        else cout << -1 << ' ' << -1;
        cout << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03027 - GIÁ TRỊ LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int x;
    ll res = 0;
    cin >> x;
    while(cin >> x) res += (x > 0) * (x << 1);
    cout << res;
    return 0;
}


================================================
FILE: Greedy/DSA03033 - ATM THẾ HỆ MỚI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    ll W, c;
    while(t--)
    {
        cin >> W >> c;
        if(W % 1000)
            cout << 0 << endl;
        else
        {
            W /= 1000;
            ll money = 0, toltal = 1, tmp;
            while(W and c--)
            {
                tmp = W % 10;
                if(tmp == 1 or tmp == 2 or tmp == 3 or tmp == 5)
                    ++money;
                else if(tmp == 4 or tmp == 6)
                {
                    money += 2;
                    toltal <<= 1;
                }
                else if(tmp == 7 or tmp == 8)
                    money += 2;
                else if(tmp == 9)
                {
                    money += 3;
                    toltal *= 3;
                }
                W /= 10;
            }
            if(W)
            {
                money += W / 5;
                if(W % 5 == 4)
                    money += 2;
                else if(W % 5)
                    ++money;
                if(W % 5 == 1 and W > 1 or W == 4)
                    toltal <<= 1;
                else if(W % 5 == 4 and W > 4)
                    toltal *= 3;
            }
            cout << money << ' ' << toltal << endl;
        }
    }
    return 0;
}


================================================
FILE: Greedy/DSA03034 - DÃY CON CHUNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, x, y, z, a;
    cin >> t;
    while(t--)
    {
        cin >> x >> y >> z;
        int a[x], b[y], c[z];
        bool check = 0;
        F(i, 0, x) cin >> a[i];
        F(i, 0, y) cin >> b[i];
        F(i, 0, z) cin >> c[i];
        int idxA, idxB, idxC;
        idxA = idxB = idxC = 0;
        while(idxA < x && idxB < y && idxC < z)
        {
            if(a[idxA] == b[idxB] && b[idxB] == c[idxC])
            {
                cout << a[idxA] << ' ';
                check = 1;
                ++idxA;
                ++idxB;
                ++idxC;
            }
            else if(a[idxA] < b[idxB]) ++idxA;
            else if(b[idxB] < c[idxC]) ++idxB;
            else ++idxC;
        }
        if(!check) cout << "NO";
        cout << endl;
    }
    return 0;
}


================================================
FILE: Greedy/DSA03035 - SẮP XẾP ĐƠN GIẢN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n + 5), f(n + 5, 0);
        for(int i = 1; i <= n; i++) cin >> a[i];
        int res = 0;
        for(int i = 1; i <= n; i++)
        {
            f[a[i]] = f[a[i] - 1] + 1;
            res = max(res, f[a[i]]);
        }
        cout << n - res;
    }
    return 0;
}



================================================
FILE: Linked list/CTDL_005 - XÓA DỮ LIỆU TRONG DSLK ĐƠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int n;
    Node* next;
};

typedef Node* node;

inline node createNode(int x)
{
    node res = new Node;
    res -> n = x;
    res -> next = NULL;
    return res;
}

inline void addBack(node &A, int x)
{
    if(A == NULL)
    {
        A = createNode(x);
        return;
    }
    node tmp = A;
    while(tmp -> next != NULL)
        tmp = tmp -> next;
    tmp -> next = createNode(x);
}

int main()
{
    faster();
    int t = 1, n, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        node A = NULL;
        while(n--)
        {
            cin >> x;
            addBack(A, x);
        }
        cin >> x;
        while(A != NULL)
        {
            if(A -> n != x)
                cout << A -> n << ' ';
            A = A -> next;
        }
        delete A;
    }
    return 0;
}



================================================
FILE: Linked list/CTDL_006 - LỌC DỮ LIỆU TRÙNG TRONG DSLK ĐƠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int n;
    Node* next;
};

typedef Node* node;

inline node createNode(int x)
{
    node res = new Node;
    res -> n = x;
    res -> next = NULL;
    return res;
}

inline bool Find(node a, int x)
{
    if(a == NULL)
        return 1;
    while(a != NULL)
    {
        if(a -> n == x)
            return 0;
        a = a -> next;
    }
    return 1;
}

inline void addBack(node &A, int x)
{
    if(A == NULL)
    {
        A = createNode(x);
        return;
    }
    node tmp = A;
    while(tmp -> next != NULL)
        tmp = tmp -> next;
    tmp -> next = createNode(x);
}

int main()
{
    faster();
    int t = 1, n, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        node A = NULL;
        while(n--)
        {
            cin >> x;
            if(Find(A, x))
                addBack(A, x);
        }
        while(A != NULL)
        {
            cout << A -> n << ' ';
            A = A -> next;
        }
        delete A;
    }
    return 0;
}



================================================
FILE: Linked list/DSA07018 - TỔNG ĐA THỨC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int heSo, mu;
    Node *next;
};

typedef Node* node;

node createNode(int heSo, int mu)
{
    node res = new Node;
    res -> heSo = heSo;
    res -> mu = mu;
    res -> next = NULL;
    return res;
}

void addBack(node &a, int heSo, int mu)
{
    if(a == NULL)
    {
        a = createNode(heSo, mu);
        return;
    }
    node tmp = a;
    while(tmp -> next != NULL)
        tmp = tmp -> next;
    tmp -> next = createNode(heSo, mu);
}

void init(node &a)
{
    string s;
    getline(cin, s);
    stringstream ss(s);
    while(ss >> s)
    {
        if(s == "+")
            continue;
        int heSo, mu, i;
        heSo = mu = 0;
        for(i = 0; i < s.sz; ++i)
        {
            if(s[i] == '*')
                break;
            heSo = heSo * 10 + s[i] - '0';
        }
        i += 3;
        for(; i < s.sz; ++i)
            mu = mu * 10 + s[i] - '0';
        addBack(a, heSo, mu);
    }
}

int Find(node a, int x)
{
    while(a != NULL)
    {
        if(a -> mu == x)
            return a -> heSo;
        else if(a -> mu < x)
            return 0;
        a = a -> next;
    }
    return 0;
}

void print(node a)
{
    while(a != NULL)
    {
        if(a -> heSo)
            cout << a -> heSo << "*x^" << a -> mu;
        a = a -> next;
        if(a != NULL and a -> heSo)
            cout << " + ";
    }
}

int main()
{
    faster();
    int t = 1, muMax;
    cin >> t;
    cin.ignore();
    while(t--)
    {
        node A, B, C;
        A = B = C = NULL;
        init(A);
        init(B);
        muMax = max(A -> mu, B -> mu);
        for(int i = muMax; ~i; --i)
            addBack(C, Find(A, i) + Find(B, i), i);
        print(C);
        cout << endl;
        delete A;
        delete B;
        delete C;
    }
    return 0;
}


================================================
FILE: Queue/DSA08001 - CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, x, n, y;
    cin >> t;
    while(t--)
    {
        deque<int> q;
        cin >> n;
        while(n--)
        {
            cin >> x;
            if(x == 1) cout << q.sz << endl;
            else if(x == 2)
            {
                if(q.empty()) cout << "YES\n";
                else cout << "NO\n";
            }
            else if(x == 3)
            {
                cin >> y;
                q.push_back(y);
            }
            else if(x == 4 and q.sz) q.pop_front();
            else if(x == 5)
            {
                if(q.sz) cout << q.front() << endl;
                else cout << -1 << endl;
            }
            else if(x == 6)
            {
                if(q.sz) cout << q.back() << endl;
                else cout << -1 << endl;
            }
        }
    }
    return 0;
}


================================================
FILE: Queue/DSA08002 - CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        deque<int> q;
        cin >> n;
        string s;
        while(cin >> s)
        {
            if(s == "PUSH")
            {
                cin >> n;
                q.pb(n);
            }
            else if(s == "PRINTFRONT")
            {
                if(q.sz) cout << q.front() << endl;
                else cout << "NONE\n";
            }
            else if(s == "POP" and q.sz) q.pop_front();
        }
    }
    return 0;
}



================================================
FILE: Queue/DSA08003 - HÀNG ĐỢI HAI ĐẦU (DEQUEUE).cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1;
    cin >> t;
    deque<int> dq;
    string s;
    while(cin >> s)
    {
        if(s == "PUSHBACK")
        {
            cin >> t;
            dq.push_back(t);
        }
        else if(s == "PUSHFRONT")
        {
            cin >> t;
            dq.push_front(t);
        }
        else if(s == "PRINTFRONT")
        {
            if(dq.empty()) cout << "NONE\n";
            else cout << dq.front() << endl;
        }
        else if(s == "POPFRONT" and dq.sz) dq.pop_front();
        else if(s == "PRINTBACK")
        {
            if(dq.empty()) cout << "NONE\n";
            else cout << dq.back() << endl;
        }
        else if(s == "POPBACK" and dq.sz) dq.pop_back();
    }
    return 0;
}



================================================
FILE: Queue/DSA08004 - GIÁ TRỊ NHỎ NHẤT CỦA XÂU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    string s;
    priority_queue<int> pq;
    while(t--)
    {
        cin >> n >> s;
        int f[30] = {};
        for(char &i : s) ++f[i - 'A'];
        for(int i = 0; i < 26; ++i) if(f[i]) pq.push(f[i]);
        while(n--)
        {
            x = pq.top();
            pq.pop();
            --x;
            pq.push(x);
        }
        ll res = 0;
        while(pq.sz)
        {
            res += 1LL * pq.top() * pq.top();
            pq.pop();
        }
        cout << res << endl;
    }
    return 0;
}


================================================
FILE: Queue/DSA08005 - SỐ NHỊ PHÂN TỪ 1 ĐẾN N.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, x, n;
    stack<int> st;
    vector<string> v(10005);
    string s;
    for(int i = 1; i <= 1e4; ++i)
    {
        s = "";
        x = i;
        while(x)
        {
            st.push(x & 1);
            x >>= 1;
        }
        while(st.sz)
        {
            s += to_string(st.top());
            st.pop();
        }
        v[i] = s;
    }
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 1 ; i<= n; ++i) cout << v[i] << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08006 - SỐ 0 VÀ SỐ 9.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    vll v;
    ll tmp = 9;
    v.pb(tmp);
    while(tmp * 10 <= 9000000999999)
    {
        int s = v.sz;
        tmp *= 10;
        v.pb(tmp);
        F(i, 0, s) v.pb(tmp + v[i]);
    }
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int idx = 0;
        while(v[idx] % n) ++idx;
        cout << v[idx] << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08007 - SỐ BDN 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    vll v;
    ll int tmp = 1;
    v.pb(tmp);
    while(tmp * 10 <= 1e17)
    {
        int s = v.sz;
        tmp *= 10;
        v.pb(tmp);
        for(int i = 0; i < s; ++i) v.pb(tmp + v[i]);
    }
    int t = 1;
    ll n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << upper_bound(all(v), n) - v.begin() << endl;
    }
    return 0;
}


================================================
FILE: Queue/DSA08008 - SỐ BDN 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll n;

bool check(string &s)
{
    ll tmp = 0;
    for(char &i : s)
    {
        tmp = tmp * 10 + i - '0';
        tmp %= n;
    }
    return !tmp;
}

string findNum()
{
    queue<string> q;
    q.push("1");
    string s;
    while(q.sz)
    {
        s = q.front();
        q.pop();
        if(check(s)) return s;
        q.push(s + "0");
        q.push(s + "1");
    }
    return "";
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << findNum() << endl;
    }
    return 0;
}


================================================
FILE: Queue/DSA08009 - BIẾN ĐỔI S – T.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int BFS(int a, int b)
{
    if(a > b) return a - b;
    int f[20005] = {};
    queue<int> q;
    q.push(a);
    int tmp;
    while(q.sz)
    {
        tmp = q.front();
        q.pop();
        if(tmp == b) return f[tmp];
        if((tmp << 1) < (b << 1) and !f[tmp << 1])
        {
            f[tmp << 1] = f[tmp] + 1;
            q.push(tmp << 1);
        }
        if(!f[tmp - 1])
        {
            f[tmp - 1] = f[tmp] + 1;
            q.push(tmp - 1);
        }
    }
    return -1;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        int a, b;
        cin >> a >> b;
        cout << BFS(a, b) << endl;
    }
    return 0;
}


================================================
FILE: Queue/DSA08010 - BIẾN ĐỔI SỐ TỰ NHIÊN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int BFS(int n)
{
    unordered_map<int, int> m;
    if(n == 1) return 0;
    queue<int> q;
    q.push(n);
    int sqr, top;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        sqr = sqrt(top);
        for(int i = 2; i <= sqr; ++i)
        {
            if(top % i == 0 and !m[top / i])
            {
                if(top / i == 1) return m[top] + 1;
                m[top / i] = m[top] + 1;
                q.push(top / i);
            }
        }
        if(top - 1 == 1) return m[top] + 1;
        if(!m[top - 1])
        {
            m[top - 1] = m[top] + 1;
            q.push(top - 1);
        }
    }
    return -1;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        cout << BFS(n) << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08011 - KHOẢNG CÁCH XÂU KÝ TỰ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string s, e;

inline void BFS(unordered_set<string> &mySet)
{
    queue<string> q;
    q.push(s);
    int ans = 1;
    string u;
    char ori;
    while(q.sz)
    {
        ++ans;
        queue<string> tmp = q;
        while(tmp.sz)
        {
            u = tmp.front();
            tmp.pop();
            q.pop();
            for(int i = 0; i < u.sz; ++i)
            {
                ori = u[i];
                for(char j = 'A'; j <= 'Z'; ++j)
                {
                    u[i] = j;
                    if(u == e)
                    {
                        cout << ans << endl;
                        return;
                    }
                    if(mySet.find(u) != mySet.end())
                    {
                        q.push(u);
                        mySet.erase(u);
                    }
                }
                u[i] = ori;
            }
        }
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    string x;
    while(t--)
    {
        cin >> n >> s >> e;
        unordered_set<string> mySet;
        while(n--)
        {
            cin >> x;
            mySet.insert(x);
        }
        if(s == e)
        {
            cout << 1 << endl;
            continue;
        }
        BFS(mySet);
    }
    return 0;
}


================================================
FILE: Queue/DSA08012 - TÌM SỐ K THỎA MÃN ĐIỀU KIỆN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool ok(string &s)
{
    int f[10] = {};
    for(char &i : s)
    {
        ++f[i - '0'];
        if(f[i - '0'] > 1) return 0;
    }
    return 1;
}

int main()
{
    faster();
    int t = 1, l, r, x, y;
    vi v;
    queue<string> q;
    q.push("");
    string top, cur;
    int tmp;
    bool check = 1;
    while(check)
    {
        top = q.front();
        q.pop();
        if(top == "0") continue;
        for(int i = 0; i <= 5; ++i)
        {
            cur = top + to_string(i);
            if(!ok(cur)) continue;
            q.push(cur);
            tmp = stoi(cur);
            if(tmp > 1e5)
            {
                check = 0;
                break;
            }
            v.pb(tmp);
        }
    }
    cin >> t;
    while(t--)
    {
        cin >> l >> r;
        x = lower_bound(all(v), l) - v.begin();
        y = lower_bound(all(v), r) - v.begin();
        if(y >= v.sz or v[y] > r) --y;
        cout << y - x + 1 << endl;
    }
    return 0;
}


================================================
FILE: Queue/DSA08013 - DI CHUYỂN TRÁNH VẬT CẢN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

char a[105][105];
int n, startX, startY, endX, endY;

int BFS()
{
    int f[105][105] = {}, tmpX, tmpY;
    queue<pair<int, int>> q;
    pair<int, int> p;
    f[startX][startY] = 1;
    q.push({startX, startY});
    while(q.sz)
    {
        p = q.front();
        q.pop();
        if(p.fi == endX and p.se == endY) return f[p.fi][p.se];
        tmpX = p.fi + 1;
        while(tmpX <= n)
        {
            if(!f[tmpX][p.se] and a[tmpX][p.se] == '.')
            {
                if(tmpX == endX and p.se == endY) return f[p.fi][p.se];
                f[tmpX][p.se] = f[p.fi][p.se] + 1;
                q.push({tmpX, p.se});
            }
            else break;
            ++tmpX;
        }
        tmpX = p.fi - 1;
        while(tmpX >= 1)
        {
            if(!f[tmpX][p.se] and a[tmpX][p.se] == '.')
            {
                if(tmpX == endX and p.se == endY) return f[p.fi][p.se];
                f[tmpX][p.se] = f[p.fi][p.se] + 1;
                q.push({tmpX, p.se});
            }
            else break;
            --tmpX;
        }
        tmpY = p.se + 1;
        while(tmpY <= n)
        {
            if(!f[p.fi][tmpY] and a[p.fi][tmpY] == '.')
            {
                if(p.fi == endX and tmpY == endY) return f[p.fi][p.se];
                f[p.fi][tmpY] = f[p.fi][p.se] + 1;
                q.push({p.fi, tmpY});
            }
            else break;
            ++tmpY;
        }
        tmpY = p.se - 1;
        while(tmpY >= 1)
        {
            if(!f[p.fi][tmpY] and a[p.fi][tmpY] == '.')
            {
                if(p.fi == endX and tmpY == endY) return f[p.fi][p.se];
                f[p.fi][tmpY] = f[p.fi][p.se] + 1;
                q.push({p.fi, tmpY});
            }
            else break;
            --tmpY;
        }
    }
    return -1;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= n; ++j)
                cin >> a[i][j];
        cin >> startX >> startY >> endX >> endY;
        ++startX;
        ++startY;
        ++endX;
        ++endY;
        if(startX == endX and startY == endY) cout << 0 << endl;
        else cout << BFS() << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08014 - GIEO MẦM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[505][505];
int n, m;

inline int BFS()
{
    int f[505][505] = {}, cnt1 = 0;
    queue<pair<int, int>> q;
    pair<int, int> p;
    for(int i = 1; i <= n; ++i)
    {
        for(int j = 1; j <= m; ++j)
        {
            cnt1 += a[i][j] == 1;
            if(a[i][j] == 2)
            {
                q.push({i, j});
                f[i][j] = 1;
            }
        }
    }
    if(!cnt1) return 0;
    while(q.sz)
    {
        p = q.front();
        q.pop();
        if(p.fi - 1 >= 1 and a[p.fi - 1][p.se] == 1)
        {
            a[p.fi - 1][p.se] = 2;
            --cnt1;
            if(!cnt1) return f[p.fi][p.se];
            f[p.fi - 1][p.se] = f[p.fi][p.se] + 1;
            q.push({p.fi - 1, p.se});
        }
        if(p.fi + 1 <= n and a[p.fi + 1][p.se] == 1)
        {
            a[p.fi + 1][p.se] = 2;
            --cnt1;
            if(!cnt1) return f[p.fi][p.se];
            f[p.fi + 1][p.se] = f[p.fi][p.se] + 1;
            q.push({p.fi + 1, p.se});
        }
        if(p.se - 1 >= 1 and a[p.fi][p.se - 1] == 1)
        {
            a[p.fi][p.se - 1] = 2;
            --cnt1;
            if(!cnt1) return f[p.fi][p.se];
            f[p.fi][p.se - 1] = f[p.fi][p.se] + 1;
            q.push({p.fi, p.se - 1});
        }
        if(p.se + 1 <= m and a[p.fi][p.se + 1] == 1)
        {
            a[p.fi][p.se + 1] = 2;
            --cnt1;
            if(!cnt1) return f[p.fi][p.se];
            f[p.fi][p.se + 1] = f[p.fi][p.se] + 1;
            q.push({p.fi, p.se + 1});
        }
    }
    return -1;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                cin >> a[i][j];
        cout << BFS() << endl;
    }
    return 0;
}


================================================
FILE: Queue/DSA08015 - DI CHUYỂN TRONG KHÔNG GIAN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a, b, c;
int f[35][35][35] = {};
char hcn[35][35][35];
pair<pair<int, int>, int> S, E;
int x[] = {1, -1, 0, 0, 0, 0};
int y[] = {0, 0, 1, -1, 0, 0};
int z[] = {0, 0, 0, 0, 1, -1};

inline bool check(int i, int j, int k)
{
    return (i >= 0 and i < a and j >= 0 and j < b and k >= 0 and k < c and hcn[i][j][k] != '#' and !f[i][j][k]);
}

inline int BFS()
{
    queue<pair<pair<int, int>, int>> q;
    q.push(S);
    f[S.fi.fi][S.fi.se][S.se] = 1;
    pair<pair<int, int>, int> top;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        for(int i = 0; i < 6; ++i)
        {
            if(check(top.fi.fi + x[i], top.fi.se + y[i], top.se + z[i]))
            {
                if(top.fi.fi + x[i] == E.fi.fi and top.fi.se + y[i] == E.fi.se and top.se + z[i] == E.se)
                    return f[top.fi.fi][top.fi.se][top.se];
                q.push({{top.fi.fi + x[i], top.fi.se + y[i]}, top.se + z[i]});
                f[top.fi.fi + x[i]][top.fi.se + y[i]][top.se + z[i]] = f[top.fi.fi][top.fi.se][top.se] + 1;
            }
        }
    }
    return -1;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> a >> b >> c;
        for(int i = 0; i < a; ++i)
        {
            for(int j = 0; j < b; ++j)
            {
                for(int z = 0; z < c; ++z)
                {
                    cin >> hcn[i][j][z];
                    if(hcn[i][j][z] == 'S')
                        S = {{i, j}, z};
                    else if(hcn[i][j][z] == 'E')
                        E = {{i, j}, z};
                }
            }
        }
        cout << BFS() << endl;
        memset(f, 0, sizeof(f));
    }
    return 0;
}



================================================
FILE: Queue/DSA08016 - HEXGAME.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int l1[] = {0, 4, 1, 3, 8, 5, 2, 7, 9, 6};
int r1[] = {3, 0, 2, 7, 4, 1, 6, 8, 5, 9};
int l2[] = {1, 5, 2, 0, 4, 8, 6, 3, 7, 9};
int r2[] = {0, 2, 6, 3, 1, 5, 9, 7, 4, 8};

inline string Change(string &s, int a[])
{
    string res = "";
    for (int i = 0; i < 10; ++i)
        res += s[a[i]];
    return res;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while (t--)
    {
        unordered_map<string, int> m;
        int ans = 1e9;
        string a, b = "1238004765";
        for (int i = 0; i < 10; ++i)
        {
            int x;
            cin >> x;
            a += to_string(x);
        }
        queue<pair<string, int>> q1, q2;
        q1.push({a, 0});
        q2.push({b, 0});
        pair<string, int> top;
        while (q1.size())
        {
            top = q1.front();
            q1.pop();
            pair<string, int> tmp = {Change(top.fi, l1), top.se + 1};
            if (!m[tmp.fi])
            {
                m[tmp.fi] = tmp.se;
                q1.push(tmp);
            }
            tmp.fi = Change(top.fi, r1);
            if (!m[tmp.fi])
            {
                m[tmp.fi] = tmp.se;
                q1.push(tmp);
            }
            if (tmp.se == 14)
                break;
        }
        while (q2.size())
        {
            top = q2.front();
            q2.pop();
            if (m[top.fi])
                ans = min(ans, m[top.fi] + top.se);
            pair<string, int> tmp = {Change(top.fi, l2), top.se + 1};
            q2.push(tmp);
            tmp.fi = Change(top.fi, r2);
            q2.push(tmp);
            if (tmp.se == 14)
                break;
        }
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08017 - SỐ LỘC PHÁT 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> n;
        deque<string> res;
        queue<string> q;
        q.push("6");
        q.push("8");
        res.push_back("6");
        res.push_back("8");
        while(q.front().sz < n)
        {
            queue<string> tmp;
            while(q.sz)
            {
                res.push_back(q.front() + '6');
                res.push_back(q.front() + '8');
                tmp.push(q.front() + '6');
                tmp.push(q.front() + '8');
                q.pop();
            }
            q = tmp;
        }
        while(res.sz)
        {
            cout << res.back() << ' ';
            res.pop_back();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08018 - SỐ LỘC PHÁT 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> n;
        deque<string> res;
        queue<string> q;
        q.push("6");
        q.push("8");
        res.push_back("6");
        res.push_back("8");
        while(q.front().sz < n)
        {
            queue<string> tmp;
            while(q.sz)
            {
                res.push_back(q.front() + '6');
                res.push_back(q.front() + '8');
                tmp.push(q.front() + '6');
                tmp.push(q.front() + '8');
                q.pop();
            }
            q = tmp;
        }
        cout << res.sz << endl;
        while(res.sz)
        {
            cout << res.front() << ' ';
            res.pop_front();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08019 - SỐ LỘC PHÁT 3.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> n;
        deque<string> res;
        queue<string> q;
        q.push("6");
        q.push("8");
        res.push_back("6");
        res.push_back("8");
        while(q.front().sz < n)
        {
            queue<string> tmp;
            while(q.sz)
            {
                res.push_back(q.front() + '6');
                res.push_back(q.front() + '8');
                tmp.push(q.front() + '6');
                tmp.push(q.front() + '8');
                q.pop();
            }
            q = tmp;
        }
        cout << res.sz << endl;
        while(res.sz)
        {
            cout << res.back() << ' ';
            res.pop_back();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08020 - BIẾN ĐỔI SỐ NGUYÊN TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bitset<100005> notPrime;

inline void sieve()
{
    int N = 1e5;
    int sqr = sqrt(N);
    for(int i = 2; i <= sqr; ++i)
        if(!notPrime[i])
            for(int j = i * i; j <= N; j += i)
                notPrime[j] = 1;
}

inline int BFS(string &a, string &b)
{
    queue<string> q;
    string top;
    unordered_map<string, int> m;
    q.push(a);
    m[a] = 1;
    int tmp;
    string ori;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        for(int i = 0; i < 4; ++i)
        {
            ori = top;
            for(char j = '0'; j <= '9'; ++j)
            {
                top[i] = j;
                tmp = stoi(top);
                if(!notPrime[tmp] and !m[top] and tmp >= 1000)
                {
                    if(top == b)
                        return m[ori];
                    m[top] = m[ori] + 1;
                    q.push(top);
                }
                top = ori;
            }
        }
    }
    return -1;
}

int main()
{
    faster();
    sieve();
    int t;
    cin >> t;
    string a, b;
    while(t--)
    {
        cin >> a >> b;
        if(a == b)
            cout << 0 << endl;
        else
            cout << BFS(a, b) << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08021 - DI CHUYỂN TRONG MA TRẬN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m, a[1005][1005];

inline int BFS()
{
    int M[1005][1005] = {};
    queue<pair<int, int>> q;
    pair<int, int> p;
    q.push({1, 1});
    M[1][1] = 0;
    while(q.sz)
    {
        p = q.front();
        q.pop();
        if(p.fi + a[p.fi][p.se] <= n and !M[p.fi + a[p.fi][p.se]][p.se])
        {
            if(p.fi + a[p.fi][p.se] == n and p.se == m) return M[p.fi][p.se] + 1;
            M[p.fi + a[p.fi][p.se]][p.se] = M[p.fi][p.se] + 1;
            q.push({p.fi + a[p.fi][p.se], p.se});
        }
        if(p.se + a[p.fi][p.se] <= m and !M[p.fi][p.se + a[p.fi][p.se]])
        {
            if(p.fi == n and p.se + a[p.fi][p.se] == m) return M[p.fi][p.se] + 1;
            M[p.fi][p.se + a[p.fi][p.se]] = M[p.fi][p.se] + 1;
            q.push({p.fi, p.se + a[p.fi][p.se]});
        }
    }
    return -1;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                cin >> a[i][j];
        cout << BFS() << endl;
    }
    return 0;
}


================================================
FILE: Queue/DSA08022 - BỘI SỐ LỚN NHẤT CỦA 3.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, x, sum;
    string res;
    cin >> t;
    while(t--)
    {
        cin >> n;
        priority_queue <int> pq;
        priority_queue <int, vector<int>, greater<int>> q1, q2;
        sum = 0;
        for(int i = 0; i < n; i++)
        {
            cin >> x;
            pq.push(x);
            sum += x;
            if(x % 3 == 1) q1.push(x);
            else if(x % 3 == 2) q2.push(x);
        }
        if((sum % 3 == 1 and q1.empty() and q2.sz < 2) or (sum % 3 == 2 and q2.empty() and q1.sz < 2))
            cout << -1;
        else
        {
            res = "";
            int s1 = -1, s2 = -1;
            if(sum % 3 == 1)
            {
                if(q1.empty())
                {
                    s1 = q2.top();
                    q2.pop();
                    s2 = q2.top();
                }
                else s1 = q1.top();
            }
            if(sum % 3 == 2)
            {
                if (q2.empty())
                {
                    s1 = q1.top();
                    q1.pop();
                    s2 = q1.top();
                }
                else s1 = q2.top();
            }
            while(pq.sz)
            {
                int tmp = pq.top();
                if(tmp != s1 and tmp != s2)
                    res += tmp + '0';
                else
                {
                    if (s1 == tmp) s1 = -1;
                    else if (s2 == tmp) s2 = -1;
                }
                pq.pop();
            }
            if(res.empty()) cout << -1;
            else
            {
                int idx = 0;
                while(res[idx] == '0')
                    ++idx;
                cout << res.substr(idx);
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08025 - QUÂN MÃ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int dx[] = {-2, -2, 2, 2, -1, -1, 1, 1};
int dy[] = {1, -1, -1, 1, 2, -2, -2, 2};

inline int BFS(pair<int, int> &st, pair<int, int> &en)
{
    int f[10][10] = {};
    pair<int, int> fr;
    queue<pair<int, int>> q;
    q.push(st);
    f[st.fi][st.se] = 1;
    while(q.sz)
    {
        fr = q.front();
        q.pop();
        for(int i = 0; i < 8; ++i)
        {
            if(fr.fi + dx[i] <= 8 and fr.fi + dx[i] >= 1 and fr.se + dy[i] <= 8 and fr.se + dy[i] >= 1 and !f[fr.fi + dx[i]][fr.se + dy[i]])
            {
                if(fr.fi + dx[i] == en.fi and fr.se + dy[i] == en.se)
                    return f[fr.fi][fr.se];
                f[fr.fi + dx[i]][fr.se + dy[i]] = f[fr.fi][fr.se] + 1;
                q.push({fr.fi + dx[i], fr.se + dy[i]});
            }
        }
    }
    return -1;
}

int main()
{
    faster();
    int t;
    string st, en;
    cin >> t;
    while(t--)
    {
        cin >> st >> en;
        pair<int, int> start, end;
        start = {st[0] - 'a' + 1, st[1] - '0'};
        end = {en[0] - 'a' + 1, en[1] - '0'};
        if(start == end)
            cout << 0 << endl;
        else
            cout << BFS(start, end) << endl;
    }
    return 0;
}



================================================
FILE: Queue/DSA08029 - QUAY HÌNH VUÔNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

class Matrix
{
private:
    int a[2][3];
    int cnt;
    
public:
    friend istream &operator >> (istream &is, Matrix &A)
    {
        for(int i = 0; i < 2; ++i)
            for(int j = 0; j < 3; ++j)
                is >> A.a[i][j];
        return is;
    }
    
    bool operator == (Matrix &A)
    {
        for(int i = 0; i < 2; ++i)
            for(int j = 0; j < 3; ++j)
                if(this -> a[i][j] != A.a[i][j])
                    return 0;
        return 1;
    }
    
    void rotateRight()
    {
        int x, y, z, t;
        x = this -> a[0][1];
        y = this -> a[0][2];
        z = this -> a[1][1];
        t = this -> a[1][2];
        this -> a[0][1] = z;
        this -> a[0][2] = x;
        this -> a[1][1] = t;
        this -> a[1][2] = y;
    }
    
    void rotateLeft()
    {
        int x, y, z, t;
        x = this -> a[0][0];
        y = this -> a[0][1];
        z = this -> a[1][0];
        t = this -> a[1][1];
        this -> a[0][0] = z;
        this -> a[0][1] = x;
        this -> a[1][0] = t;
        this -> a[1][1] = y;
    }
    
    int getCnt()
    {
        return this -> cnt;
    }
    
    void updateCnt(int x)
    {
        this -> cnt = x;
    }
};

Matrix S, E, u, tmp;

inline void BFS()
{
    queue<Matrix> q;
    q.push(S);
    S.updateCnt(0);
    vector<Matrix> v;
    v.pb(S);
    while(q.sz)
    {
        u = q.front();
        q.pop();
        tmp = u;
        tmp.rotateLeft();
        tmp.updateCnt(u.getCnt() + 1);
        if(tmp == E)
        {
            cout << tmp.getCnt() << endl;
            return;
        }
        q.push(tmp);
        tmp = u;
        tmp.rotateRight();
        tmp.updateCnt(u.getCnt() + 1);
        if(tmp == E)
        {
            cout << tmp.getCnt() << endl;
            return;
        }
        q.push(tmp);
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> S >> E;
        if(S == E)
        {
            cout << 0 << endl;
            continue;
        }
        BFS();
    }
    return 0;
}


================================================
FILE: Queue/DSA08045 - HÀNG RÀO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

const int inf = 1e9;
int x[3010], y[3010];
int t[3010];
int xz, yz;
char arr[6010][6010];
int gz;
int mx[4] = {-1, 0, 1, 0};
int my[4] = {0, -1, 0, 1};
stack<short> sx, sy;

inline int cmp(int a[3010], int z)
{
    memcpy(t, a, sizeof(t));
    sort(t, t + z);
    int nz = unique(t, t + z) - t;
    for (int i = 0; i < z; ++i)
        a[i] = (lower_bound(t, t + nz, a[i]) - t) * 2;
    return nz * 2;
}

void put(int x, int y)
{
    if (x < 0 || x >= xz || y < 0 || y >= yz)
        return;
    if (arr[x][y] == 'X')
        return;
    gz += (arr[x][y] == 'C');
    arr[x][y] = 'X';
    sx.push(x);
    sy.push(y);
}

void DFS(int startx, int starty)
{
    put(startx, starty);
    while (sx.size())
    {
        int x = sx.top();
        sx.pop();
        int y = sy.top();
        sy.pop();
        for (int i = 0; i < 4; ++i)
        {
            int nx = x + mx[i];
            int ny = y + my[i];
            put(nx, ny);
        }
    }
}

int main()
{
    faster();
    int t = 1, n, m;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        int z = 0;
        x[z] = y[z] = -inf;
        ++z;
        x[z] = y[z] = inf;
        ++z;
        int lm = n << 1;
        for (int i = 0; i < lm; ++i)
        {
            cin >> x[z] >> y[z];
            ++z;
        }
        for (int i = 0; i < m; ++i)
        {
            cin >> x[z] >> y[z];
            ++z;
        }
        xz = cmp(x, z);
        yz = cmp(y, z);
        memset(arr, '.', sizeof(arr));
        for (int i = 0; i < n; ++i)
        {
            int a = i * 2 + 2;
            int b = i * 2 + 3;
            int x1 = x[a], y1 = y[a], x2 = x[b], y2 = y[b];
            if (x1 == x2)
            {
                if (y1 > y2)
                    swap(y1, y2);
                while (y1 <= y2)
                {
                    arr[x1][y1] = 'X';
                    ++y1;
                }
            }
            else
            {
                if (x1 > x2)
                    swap(x1, x2);
                while (x1 <= x2)
                {
                    arr[x1][y1] = 'X';
                    ++x1;
                }
            }
        }
        for (int i = 0; i < m; ++i)
        {
            int a = i + 2 * n + 2;
            arr[x[a]][y[a]] = 'C';
        }
        int ans = 0;
        for (int i = 0; i < m; ++i)
        {
            int a = i + 2 * n + 2;
            gz = 0;
            DFS(x[a], y[a]);
            ans = max(ans, gz);
        }
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/CTDL_005 - XÓA DỮ LIỆU TRONG DSLK ĐƠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        cin >> x;
        for(int &i : a) if(i != x) cout << i << ' ';
    }
    return 0;
}



================================================
FILE: Sort and Search/CTDL_006 - LỌC DỮ LIỆU TRÙNG TRONG DSLK ĐƠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        unordered_map<int, bool> m;
        while(cin >> n)
        {
            if(!m[n])
            {
                cout << n << ' ';
                m[n] = 1;
            }
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06001 - SẮP XẾP XEN KẼ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        int a[n];
        for(int i = 0; i < n; ++i) cin >> a[i];
        sort(a , a + n);
        int i = 0, j = n - 1;
        while(i <= j )
        {
            if (i == j) cout << a[i] << ' ';
            else cout << a[j] << ' ' << a[i] << ' ';
            i++;
            j--;
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06002 - SẮP XẾP THEO GIÁ TRỊ TUYỆT ĐỐI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool cmp(pair<int, int> a, pair<int, int> b)
{
    return a.fi < b.fi;
}

int main()
{
    faster();
    int t, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        vector<pair<int, int>> vp(n);
        for(int i = 0; i < n; ++i)
        {
            cin >> vp[i].se;
            vp[i].fi = abs(vp[i].se - k);
        }
        stable_sort(all(vp), cmp);
        for(pair<int, int> i : vp) cout << i.se << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06003 - ĐỔI CHỖ ÍT NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, idx;
    cin >> t;
    while(t--)
    {
        int cnt = 0;
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        for(int i = 0; i < n; ++i)
        {
            idx = i;
            for(int j = i + 1; j < n; ++j) if(a[idx] > a[j]) idx = j;
            cnt += idx != i;
            swap(a[i], a[idx]);
        }
        cout << cnt << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06004 - HỢP VÀ GIAO CỦA HAI DÃY SỐ 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        vector<int> v1(n), v2(m);
        vector<int> ans;
        int a[100005] = {}, b[100005] = {};
        for(int &i : v1)
        {
            cin >> i;
            ++a[i];
        }
        for(int &i : v2)
        {
            cin >> i;
            ++b[i];
        }
        set<int> s;
        for(int i : v1)
        {
            if(b[i])
            {
                ans.pb(i);
                b[i] = 0;
            }
            s.insert(i);
        }
        for(int i : v2) s.insert(i);
        for(int i : s) cout << i << ' ';
        cout << endl;
        for(int i : ans) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06005 - HỢP VÀ GIAO CỦA HAI DÃY SỐ 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        set<int> Hop;
        cin >> n >> m;
        int a[100005] = {}, b[100005] = {};
        while(n--)
        {
            cin >> x;
            Hop.insert(x);
            ++a[x];
        }
        while(m--)
        {
            cin >> x;
            Hop.insert(x);
            ++b[x];
        }
        for(int i : Hop) cout << i << ' ';
        cout << endl;
        for(int i = 0; i <= 1e5; ++i) if(a[i] and b[i]) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06006 - SẮP XẾP [0 1 2].cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int f[3] = {};
        while(n--)
        {
            cin >> x;
            f[x]++;
        }
        for(int i = 0; i < 3; ++i) while(f[i]--) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06007 - SẮP XẾP DÃY CON LIÊN TỤC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<int> v1(n), v2(n);
        for(int i = 0; i < n; ++i) cin >> v1[i];
        v2 = v1;
        sort(all(v1));
        for(int i = 0; i < n; ++i)
        {
            if(v1[i] != v2[i])
            {
                cout << i + 1 << ' ';
                break;
            }
        }
        for(int i = n - 1; i; --i)
        {
            if(v1[i] != v2[i])
            {
                cout << i + 1 << endl;
                break;
            }
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06008 - ĐẾM CẶP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int count(int x, int y[], int n, int f[])
{
    if (!x) return 0;
    if (x == 1) return f[0];
    int* idx = upper_bound(y, y + n, x);
    int ans = (y + n) - idx;
    ans += (f[0] + f[1]);
    if (x == 2) ans -= (f[3] + f[4]);
    if (x == 3) ans += f[2];
    return ans;
}

int calc(int x[], int y[], int m, int n)
{
    int f[5] = {};
    F(i, 0, n) if (y[i] < 5) ++f[y[i]];
    sort(y, y + n);
    int ans = 0;
    F(i, 0, m) ans += count(x[i], y, n, f);
    return ans;
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        int m, n;
        cin >> m >> n;
        int x[m], y[n];
        for(int &i : x) cin >> i;
        for(int &i : y) cin >> i;
        cout << calc(x, y, m, n) << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06009 - CẶP SỐ TỔNG BẰNG K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        int f[105] = {};
        int cnt = 0;
        while(n--)
        {
            cin >> x;
            ++f[x];
        }
        if((k & 1) ^ 1 and f[k >> 1])
        {
            cnt += f[k >> 1] * (f[k >> 1] - 1) >> 1;
            f[k >> 1] = 0;
        }
        for(int i = 0; i <= k; ++i)
        {
            if(f[i])
            {
                cnt += f[i] * f[k - i];
                f[i] = f[k - i] = 0;
            }
        }
        cout << cnt << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06010 - SẮP XẾP CHỮ SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    string s;
    while(t--)
    {
        bool f[15] = {};
        cin >> n;
        while(n--)
        {
            cin >> s;
            for(char i : s) if(isdigit(i)) f[i - '0'] = 1;
        }
        for(int i = 0; i < 10; ++i) if(f[i]) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06011 - TỔNG GẦN 0 NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n + 1];
        FOR(i, 1, n) cin >> a[i];
        int ans = INT_MAX;
        FOR(i, 1, n) FOR(j, i + 1, n) if(abs(ans) > abs(a[i] + a[j])) ans = a[i] + a[j];
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06012 - PHẦN TỬ LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        vi a(n);
        for(int &i : a) cin >> i;
        sort(all(a));
        int idx = n - 1;
        while(k--) cout << a[idx--] << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06013 - SỐ LẦN XUẤT HIỆN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n >> x;
        int a[n];
        int f[1000005] = {};
        for(int &i : a)
        {
            cin >> i;
            ++f[i];
        }
        if(!f[x]) cout << -1 << endl;
        else cout << f[x] << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06014 - TỔNG CẶP SỐ NGUYÊN TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool notPrime[1000010] = {};

int calc(int &n)
{
    int mid = n >> 1;
    for(int i = 2; i <= mid; ++i) if(!notPrime[i] and !notPrime[n - i]) return i;
    return -1;
}

int main()
{
    faster();
    int t = 1, n, k;
    int N = 1e6 + 5;
    int sqr = sqrt(N);
    notPrime[0] = notPrime[1] = 1;
    for(int i = 2; i <= sqr; ++i)
        if(!notPrime[i])
            for(int j = i * i; j <= 1e6; j += i)
                notPrime[j] = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int ans = calc(n);
        if(ans == -1) cout << ans << endl;
        else cout << ans << ' ' << n - ans << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06015 - MERGE SORT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n], f[1000005] = {};
        for(int i = 0; i < n; ++i)
        {
            cin >> a[i];
            ++f[a[i]];
        }
        for(int i = 0; i <= 1e6; ++i) while(f[i]--) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06016 - TÍCH LỚN NHẤT - NHỎ NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        int minn = INT_MAX, maxx = INT_MIN;
        cin >> n >> m;
        while(n--)
        {
            cin >> x;
            maxx = max(maxx, x);
        }
        while(m--)
        {
            cin >> x;
            minn = min(minn, x);
        }
        cout << 1LL * maxx * minn << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06017 - TRỘN HAI DÃY.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        vi v;
        while(n--)
        {
            cin >> x;
            v.pb(x);
        }
        while(m--)
        {
            cin >> x;
            v.pb(x);
        }
        sort(all(v));
        for(int i : v) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06018 - BỔ SUNG PHẦN TỬ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int f[100005] = {};
        int mi = INT_MAX, ma = INT_MIN;
        while(n--)
        {
            cin >> x;
            ++f[x];
            mi = min(mi, x);
            ma = max(ma, x);
        }
        int cnt = 0;
        for(int i = mi; i <= ma; ++i) cnt += !f[i];
        cout << cnt;
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06019 - SẮP XẾP THEO SỐ LẦN XUẤT HIỆN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool cmp(pair<int, int> a, pair<int, int> b)
{
    if(a.se > b.se) return 1;
    else if(a.se < b.se) return 0;
    if(a.fi < b.fi) return 1;
    return 0;
}

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<pair<int, int>> vp;
        vi v;
        int dd[1000006] = {};
        FOR(i, 1, n)
        {
            cin >> x;
            if(!dd[x]) v.pb(x);
            ++dd[x];
        }
        for(int i : v) vp.pb(mp(i, dd[i]));
        sort(vp.begin(), vp.end(), cmp);
        for(auto i : vp) FOR(j, 1, i.se) cout << i.fi << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06020 - TÌM KIẾM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int bS(int a[], int &n, int &x)
{
    if(binary_search(a, a + n, x) == 1) return 1;
    return -1;
}

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        cin >> n >> x;
        int a[n];
        for(int i = 0; i < n; ++i) cin >> a[i];
        cout << bS(a, n, x) << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06021 - TÌM KIẾM TRONG DÃY SẮP XẾP VÒNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int binSearchMin(int a[], int l, int r, int n)
{
    int mid;
    while(l <= r)
    {
        mid = l + (r - l) / 2;
        if(a[mid] > a[n - 1]) l = mid + 1;
        else r = mid - 1;
    }
    return mid;
}

int binSearch(int a[], int l, int r, int x)
{
    int mid;
    while(l <= r)
    {
        mid = l + (r - l) / 2;
        if(a[mid] == x) return mid;
        if(a[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return mid;
}

int main()
{
    faster();
    int t = 1, n, m, x, posMin;
    cin >> t;
    while(t--)
    {
        cin >> n >> x;
        int a[n];
        for(int i = 0; i < n; ++i) cin >> a[i];
        posMin = binSearchMin(a, 0, n - 1, n);
        if(!posMin)
        {
            cout << binSearch(a, 0, n - 1, x) + 1 << endl;
            continue;
        }
        if(x < a[n - 1]) cout << binSearch(a, posMin, n - 1, x) + 1 << endl;
        else cout << binSearch(a, 0, posMin - 1, x) + 1 << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06022 - SỐ NHỎ NHẤT VÀ NHỎ THỨ HAI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        sort(a, a + n);
        if(a[0] == a[n - 1]) cout << -1 << endl;
        else
        {
            int idx = 1;
            while(a[idx] == a[0]) ++idx;
            cout << a[0] << ' ' << a[idx] << endl;
        }
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06023 - SẮP XẾP ĐỔI CHỖ TRỰC TIẾP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        vi v(n);
        for(int &i : v) cin >> i;
        int m = n - 1;
        for(int i = 0; i < m; ++i)
        {
            cout << "Buoc " << i + 1 << ": ";
            for(int j = i + 1; j < n; ++j) if(v[i] > v[j]) swap(v[i], v[j]);
            for(int i : v) cout << i << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06024 - SẮP XẾP CHỌN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        for(int i=0; i < n - 1; ++i)
        {
            int min_i=i;
            for(int j=i+1;j<n;j++)
            {
                if(a[j]<a[min_i])
                {
                    min_i=j;
                }
            }
            int temp=a[i];
            a[i]=a[min_i];
            a[min_i]=temp;
            printf("Buoc %d: ", i + 1);
            for(int z = 0; z < n; ++z) printf("%d ",a[z]);
            printf("\n");
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06025 - SẮP XẾP CHÈN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        multiset<int> s;
        for(int i = 0; i < n; ++i)
        {
            cin >> x;
            s.insert(x);
            cout << "Buoc " << i << ": ";
            for(int i : s) cout << i << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06026 - SẮP XẾP NỔI BỌT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

bool cmp(pair<int, int> a, pair<int, int> b)
{
    return a.fi < b.fi;
}

int main()
{
    faster();
    int t = 1, n;
    //cin >> t;
    while(t--)
    {
        int cnt = 1;
        cin >> n;
        vector<int> v(n);
        for(int &i : v) cin >> i;
        for(int i = 0; i < n - 1; ++i)
        {
            bool notSwap = 1;
            for(int j = 0; j < n - i - 1; ++j)
                if(v[j] > v[j + 1])
                {
                    swap(v[j], v[j + 1]);
                    notSwap = 0;
                }
            if(notSwap) break;
            cout << "Buoc " << cnt++ << ": ";
            for(int i : v) cout << i << ' ';
            cout << endl;
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06027 - SẮP XẾP ĐỔI CHỖ TRỰC TIẾP - LIỆT KÊ NGƯỢC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        vector<vector<int>> ans;
        for(int &i : a) cin >> i;
        for(int i = 0; i < n - 1; ++i)
        {
            for(int j = i + 1; j < n; ++j) if(a[i] > a[j]) swap(a[i], a[j]);
            vector<int> v(n);
            for(int z = 0; z < n; ++z) v[z] = a[z];
            ans.pb(v);
        }
        for(int i = ans.sz; i; --i)
        {
            cout << "Buoc " << i << ": ";
            for(int j : ans[i - 1]) cout << j << ' ';
            cout << endl;
        }
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06028 - SẮP XẾP CHỌN - LIỆT KÊ NGƯỢC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        vector<vector<int>> ans;
        for(int &i : a) cin >> i;
        for(int i=0; i < n - 1; ++i)
        {
            int min_i=i;
            for(int j=i+1;j<n;j++)
            {
                if(a[j]<a[min_i])
                {
                    min_i=j;
                }
            }
            swap(a[i], a[min_i]);
            vector<int> v(n);
            for(int z = 0; z < n; ++z) v[z] = a[z];
            ans.pb(v);
        }
        for(int i = ans.sz; i; --i)
        {
            cout << "Buoc " << i << ": ";
            for(int j : ans[i - 1]) cout << j << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06029 - SẮP XẾP CHÈN - LIỆT KÊ NGƯỢC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        m = n;
        set<int> s;
        vector<vector<int>> ans;
        for(int i = 0; i < n; ++i)
        {
            cin >> x;
            s.insert(x);
            vector<int> v;
            for(int i : s) v.pb(i);
            ans.pb(v);
        }
        for(int i = ans.sz; i; --i)
        {
            cout << "Buoc " << i - 1 << ": ";
            for(int j : ans[i - 1]) cout << j << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06030 - SẮP XẾP NỔI BỌT - LIỆT KÊ NGƯỢC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n], m = n - 1;
        for(int &i : a) cin >> i;
        vector<vector<int>> ans;
        for(int i = 0; i < m; ++i)
        {
            bool notSwap = 1;
            for(int j = 0; j < m - i; ++j)
                if(a[j] > a[j + 1])
                {
                    swap(a[j], a[j + 1]);
                    notSwap = 0;
                }
            if(notSwap) break;
            vector<int> v(n);
            for(int i = 0; i < n; ++i) v[i] = a[i];
            ans.pb(v);
        }
        for(int i = ans.sz; i; --i)
        {
            cout << "Buoc " << i << ": " << ' ';
            for(int j : ans[i - 1]) cout << j << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06031 - PHẦN TỬ LỚN NHẤT TRONG DÃY CON.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        deque<int> dq;
        cin >> n >> k;
        int a[n];
        for(int &i : a) cin >> i;
        dq.push_back(0);
        for(int i = 1; i < k; ++i)
        {
            while(!dq.empty() && a[dq.back()] < a[i]) dq.pop_back();
            dq.push_back(i);
        }
        cout << a[dq.front()] << ' ';
        for(int i = k; i < n; ++i)
        {
            while(!dq.empty() && a[dq.back()] < a[i]) dq.pop_back();
            dq.push_back(i);
            if(i - dq.front() < k) cout << a[dq.front()] << ' ';
            else
            {
                dq.pop_front();
                cout << a[dq.front()] << ' ';
            }
        }
        cout << endl;
    }
    return 0;
}




================================================
FILE: Sort and Search/DSA06032 - BỘ BA SỐ CÓ TỔNG NHỎ HƠN K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    ll n, k, a[5005], tmp, idx;
    while(t--)
    {
        ll cnt = 0;
        cin >> n >> k;
        for(int i = 0; i < n; ++i) cin >> a[i];
        sort(a, a + n);
        for(int i = 0; i < n; ++i)
        {
            if(a[i] > k) break;
            for(int j = i + 1; j < n; ++j)
            {
                idx = upper_bound(a + j + 1, a + n, k - a[i] - a[j] - 1) - a;
                if(idx > j) cnt += idx - j - 1;
                else break;
            }
        }
        cout << cnt << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06033 - KHOẢNG CÁCH XA NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a) cin >> i;
        int MAX[n], ans = -1;
        MAX[n - 1] = a[n - 1];
        for(int i = n - 2; i >= 0; --i) MAX[i] = max(MAX[i + 1], a[i]);
        int i, j;
        i = j = 0;
        while(i < n and j < n)
        {
            if(MAX[j] > a[i])
            {
                ans = max(ans, j - i);
                ++j;
            }
            else ++i;
        }
        if(!ans) ans = -1;
        cout << ans << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06034 - CẶP SỐ CÓ TỔNG BẰNG K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        unordered_map<ll, ll> f;
        vll v(n);
        ll cnt = 0;
        for(ll &i : v)
        {
            cin >> i;
            ++f[i];
        }
        if((k & 1) ^ 1 and f[k >> 1])
        {
            cnt += f[k >> 1] * (f[k >> 1] - 1) >> 1;
            f[k >> 1] = 0;
        }
        for(ll i : v)
        {
            if(f[i])
            {
                cnt += f[i] * f[k - i];
                f[i] = f[k - i] = 0;
            }
        }
        cout << cnt << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06035 - DÃY TAM GIÁC DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    int n, a[100005];
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i) cin >> a[i];
        int inc[n], dec[n];
        inc[0] = dec[n - 1] = 1;
        for(int i = 1; i < n; ++i)
        {
            if(a[i] > a[i - 1]) inc[i] = inc[i - 1] + 1;
            else inc[i] = 1;
        }
        for(int i = n - 2; i >= 0; --i)
        {
            if(a[i] > a[i + 1]) dec[i] = dec[i + 1] + 1;
            else dec[i] = 1;
        }
        int ans = -1;
        for(int i = 0; i < n; ++i) ans = max(ans, inc[i] + dec[i] - 1);
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06036 - BỘ BA SỐ BẰNG K.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline string calc(vi &a, int &k)
{
    int n = a.sz, l, r;
    for(int i = 0; i < n; ++i)
    {
        l = i + 1;
        r = n - 1;
        while(l < r)
        {
            if(a[i] + a[l] + a[r] == k) return "YES";
            if(a[i] + a[l] + a[r] < k) ++l;
            else --r;
        }
    }
    return "NO";
}

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        vi a(n);
        for(int &i : a) cin >> i;
        sort(all(a));
        cout << calc(a, k) << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06037 - SẮP XẾP ĐOẠN CON.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n);
        cin >> a[0];
        int m[n], M[n];
        M[0] = a[0];
        for(int i = 1; i < n; ++i)
        {
            cin >> a[i];
            M[i] = max(a[i], M[i - 1]);
        }
        m[n - 1] = a[n - 1];
        for(int i = n - 2; i >= 0; --i) m[i] = min(a[i], m[i + 1]);
        vi ans;
        --n;
        for(int i = 0; i < n; ++i) if(M[i] <= m[i + 1]) ans.pb(i + 1);
        if(ans.sz == 0) cout << 0 << endl << endl;
        else
        {
            cout << ans.sz << endl;
            for(int i : ans) cout << i << ' ';
            cout << endl;
        }
    }
    return 0;
}

// 2 1 2 5 4 3


================================================
FILE: Sort and Search/DSA06038 - CẶP SỐ.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int merge(int *a, int *b, int l, int r, int mid)
{
    int i = l, j = i, k = mid;
    int res = 0;
    while(i <= mid - 1 and k <= r)
    {
        if(a[i] <= a[k]) b[j++] = a[i++];
        else
        {
            b[j++] = a[k++];
            res += mid - i;
        }
    }
    while(i <= mid - 1) b[j++] = a[i++];
    while(k <= r) b[j++] = a[k++];
    for(i = l; i <= r; ++i) a[i] = b[i];
    return res;
}

inline int Sort(int *a, int *b, int l, int r)
{
    int mid, res = 0;
    if(l < r)
    {
        mid = (l + r) >> 1;
        res += Sort(a, b, l, mid);
        res += Sort(a, b, mid + 1, r);
        res += merge(a, b, l, r, mid + 1);
    }
    return res;
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        int a[n + 5], b[n + 5], c[n + 5];
        for (int i = 0; i < n; i++) cin >> a[i];
        int idx = 0;
        for (int i = 0; i < n; i++) if((a[i] & 1) ^ 1) c[idx++] = a[i];
        int res = Sort(c, b, 0, idx - 1);
        int cnt = 0;
        a[n] = 1;
        for (int i = 1; i <= n; i++)
        {
            if((a[i] & 1) ^ 1 and (a[i - 1] & 1) ^ 1) ++cnt;
            else if(a[i] & 1 and (a[i - 1] & 1) ^ 1)
            {
                res -= Sort(a, b, i - 1 - cnt, i - 1);
                cnt = 0;
            }
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06039 - SỐ ĐẦU TIÊN BỊ LẶP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string calc(int *a, int n, unordered_map<int, int> &m)
{
    for(int i = 0; i < n; ++i) if(m[a[i]] > 1) return to_string(a[i]);
    return "NO";
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    int n, a[100005];
    while(t--)
    {
        cin >> n;
        unordered_map<int, int> m;
        for(int i = 0; i < n; ++i)
        {
            cin >> a[i];
            ++m[a[i]];
        }
        cout << calc(a, n, m) << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06040 - GIAO CỦA BA DÃY SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, x, y, z, a;
    cin >> t;
    while(t--)
    {
        cin >> x >> y >> z;
        ll a[x], b[y], c[z];
        F(i, 0, x) cin >> a[i];
        F(i, 0, y) cin >> b[i];
        F(i, 0, z) cin >> c[i];
        int idxA, idxB, idxC;
        idxA = idxB = idxC = 0;
        multiset<ll> ans;
        while(idxA < x && idxB < y && idxC < z)
        {
            if(a[idxA] == b[idxB] && b[idxB] == c[idxC])
            {
                ans.insert(a[idxA]);
                ++idxA;
                ++idxB;
                ++idxC;
            }
            else if(a[idxA] < b[idxB]) ++idxA;
            else if(b[idxB] < c[idxC]) ++idxB;
            else ++idxC;
        }
        if(ans.empty()) cout << -1;
        else for(ll i : ans) cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06041 - SỐ XUẤT HIỆN NHIỀU NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n], idx = 0;
        int f[1000005] = {};
        for(int i = 0; i < n; ++i)
        {
            cin >> k;
            if(!f[k]) a[idx++] = k;
            ++f[k];
        }
        n >>= 1;
        int ans = -1, num;
        for(int i = 0; i < idx; ++i)
        {
            if(f[a[i]] > n and f[a[i]] > ans)
            {
                ans = f[a[i]];
                num = a[i];
            }
        }
        if(ans == -1) cout << "NO\n";
        else cout << num << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06043 - ĐIỂM CÂN BẰNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n, k, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n], f[n], sum = 0;
        cin >> a[0];
        f[0] = a[0];
        sum += a[0];
        for(int i = 1; i < n; ++i)
        {
            cin >> a[i];
            f[i] = f[i - 1] + a[i];
            sum += a[i];
        }
        bool check = 1;
        for(int i = 1; i < n; ++i)
        {
            if(f[i] - a[i] == sum - f[i])
            {
                cout << i + 1 << endl;
                check = 0;
                break;
            }
        }
        if(check) cout << -1 << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06044 - SẮP XẾP CHẴN LẺ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, m, x;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        vector<int> a(n);
        vector<int> b;
        vector<int> c;
        for(int i = 0; i < n; ++i) cin >> a[i];
        for(int i = 0; i < n; i += 2) b.pb(a[i]);
        for(int i = 1; i < n; i += 2) c.pb(a[i]);
        sort(all(c), greater<int>());
        sort(all(b));
        m = n;
        n >>= 1;
        for(int i = 0; i < n; ++i) cout << b[i] << ' ' << c[i] << ' ';
        if(m & 1) cout << b.back() << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Sort and Search/DSA06045 - XÂU TỐT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int n;
    string s;
    cin >> n >> s;
    ll total = (1LL * n * (n - 1)) >> 1;
    int cnt = 1;
    vi v;
    for(int i = 1; i < s.sz; ++i)
    {
        if(s[i] == s[i - 1])
            ++cnt;
        else
        {
            v.pb(cnt);
            cnt = 1;
        }
    }
    v.pb(cnt);
    for(int i = 1; i < v.sz; ++i)
        total -= (v[i] + v[i - 1] - 1);
    cout << total;
    return 0;
}



================================================
FILE: Sort and Search/DSA06046 - CHÊNH LỆCH NHỎ NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n);
        for(int &i : a) cin >> i;
        sort(all(a));
        int ans = INT_MAX;
        for(int i = 1; i < n; ++i) ans = min(ans, a[i] - a[i - 1]);
        cout << ans << endl;
    }
    return 0;
}




================================================
FILE: Sort and Search/DSA06047 - BỘ BA SỐ PYTAGO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int Bsearch(const vll &v , int l, int r , ll x)
{
    while(l <= r)
    {
        int mid = (r + l) / 2;
        if (v[mid] == x) return mid;
        else if (v[mid] < x) l = mid + 1;
        else r = mid - 1;
    }
    return -1;
}
 
bool check(const vll &v, int n)
{
    F(i, 0, n - 2)
    {
        F(j, i + 1, n - 1)
        {
            ll c = sqrt(v[i] * v[i] + v[j] * v[j]);
            if (c * c == v[i] * v[i] + v[j] * v[j])
            {
                int idx = Bsearch(v, j, n - 1, c);
                if (idx != -1) return 1;
            }
        }
    }
    return 0;
}
 
 
int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        int n;
        cin >> n;
        vll v(n);
        F(i, 0, n) cin >> v[i];
        sort(v.begin(), v.end());
        if(check(v, n)) cout << "YES\n";
        else cout << "NO\n";
    }
    return 0;
}




================================================
FILE: Sort and Search/DSA06048 - SỐ LẦN QUAY VÒNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        int ans = -1;
        cin >> n;
        vi a(n);
        for(int &i : a) cin >> i;
        --n;
        for(int i = 0; i < n; ++i) if(a[i] > a[i + 1]) ans = i + 1;
        if(ans == -1)
        {
            if(a[0] <= a[n - 1]) cout << 0 << endl;
            else cout << n << endl;
        }
        else cout << ans << endl;
    }
    return 0;
}


================================================
FILE: Sort and Search/DSA06049 - ĐẾM CẶP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    int n, a[100005], k;
    while(t--)
    {
        cin >> n >> k;
        for(int i = 0; i < n; ++i) cin >> a[i];
        sort(a, a + n);
        ll cnt = 0;
        for(int i = 0; i < n; ++i) cnt += lower_bound(a + i + 1, a + n, k + a[i]) - a - i - 1;
        cout << cnt << endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07001 - NGĂN XẾP 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    stack<int> st;
    int n;
    string s;
    while(cin >> s)
    {
        if(s == "pop" and st.sz) st.pop();
        else if(s == "push")
        {
            cin >> n;
            st.push(n);
        }
        else
        {
            if(st.empty()) cout << "empty" << endl;
            else
            {
                stack<int> tmp;
                while(st.sz)
                {
                    tmp.push(st.top());
                    st.pop();
                }
                while(tmp.sz)
                {
                    cout << tmp.top() << ' ';
                    st.push(tmp.top());
                    tmp.pop();
                }
                cout << endl;
            }
        }
    }
    return 0;
}



================================================
FILE: Stack/DSA07002 - NGĂN XẾP 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    stack<int> st;
    int n;
    string s;
    cin >> n;
    while(cin >> s)
    {
        if(s == "PUSH")
        {
            cin >> n;
            st.push(n);
        }
        else if(s == "POP" and st.sz) st.pop();
        else if(s == "PRINT")
        {
            if(st.sz) cout << st.top() << endl;
            else cout << "NONE\n";
        }
    }
    return 0;
}


================================================
FILE: Stack/DSA07003 - KIỂM TRA BIỂU THỨC SỐ HỌC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string calc(string &s)
{
    stack<char> st;
    bool check;
    char cur;
    for(char &i : s)
    {
        if(i == ')')
        {
            check = 0;
            cur = st.top();
            st.pop();
            while(cur != '(')
            {
                if(cur == '+' or cur == '-' or  cur == '*' or cur == '/') check = 1;
                cur = st.top();
                st.pop();
            }
            if(!check) return "Yes";
        }
        else st.push(i);
    }
    return "No";
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    cin.ignore();
    while(t--)
    {
        getline(cin, s);
        cout << calc(s) << endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07004 - ĐẾM SỐ DẤU NGOẶC ĐỔI CHIỀU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int calc(string &s)
{
    stack<char> st;
    int cnt1, cnt2;
    cnt1 = cnt2 = 0;
    for(char &i : s)
    {
        if(i == ')' and st.sz and st.top() == '(') st.pop();
        else st.push(i);
    }
    while(st.sz)
    {
        if(st.top() == '(') ++cnt1;
        else ++cnt2;
        st.pop();
    }
    return (cnt1 >> 1) + (cnt1 & 1) + (cnt2 >> 1) + (cnt2 & 1);
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        cout << calc(s) << endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07005 - BIỂU THỨC TƯƠNG ĐƯƠNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline string calc(string s)
{
    stack<char> st1, st2;
    s = '+' + s;
    st2.push('+');
    for(char &i : s)
    {
        if(isalpha(i)) st1.push(i);
        else
        {
            if(i == '+' or i == '-')
            {
                if(st2.top() == '+') st1.push(i);
                else st1.push((i == '+') ? '-' : '+');
            }
            if(i == '(') st2.push(st1.top());
            else if(i == ')') st2.pop();
        }
    }
    string res = "";
    while(st1.sz > 1)
    {
        res = st1.top() + res;
        st1.pop();
    }
    return res;
    
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        cout << calc(s) << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07006 - XÓA DẤU NGOẶC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<string> vs;
unordered_map<string, bool> m;

inline void Try(string s)
{
    stack<int> st;
    pair<int, int> p;
    vector<pair<int, int>> vp;
    for(int i = 0; i < s.sz; ++i)
    {
        if(s[i] == '(')
            st.push(i);
        else if(s[i] == ')')
        {
            p.fi = st.top();
            p.se = i;
            st.pop();
            vp.push_back(p);
        }
    }
    if(vp.empty())
        return;
    string tmp;
    for(pair<int, int> &i : vp)
    {
        tmp = s;
        tmp.erase(tmp.begin() + i.se);
        tmp.erase(tmp.begin() + i.fi);
        if(!m[tmp])
        {
            m[tmp] = 1;
            vs.pb(tmp);
            Try(tmp);
        }
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        Try(s);
        sort(all(vs));
        for(string &i : vs)
            cout << i << endl;
    }
    return 0;
}




================================================
FILE: Stack/DSA07007 - SO SÁNH BIỂU THỨC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline string calc(string s)
{
    stack<char> st1, st2;
    s = '+' + s;
    st2.push('+');
    for(char &i : s)
    {
        if(isalpha(i)) st1.push(i);
        else
        {
            if(i == '+' or i == '-')
            {
                if(st2.top() == '+') st1.push(i);
                else st1.push((i == '+') ? '-' : '+');
            }
            if(i == '(') st2.push(st1.top());
            else if(i == ')') st2.pop();
        }
    }
    string res = "";
    while(st1.sz > 1)
    {
        res = st1.top() + res;
        st1.pop();
    }
    return res;
    
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s1, s2;
    while(t--)
    {
        cin >> s1 >> s2;
        cout << ((calc(s1) == calc(s2)) ? "YES" : "NO") << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07008 - BIẾN ĐỔI TRUNG TỐ - HẬU TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int degree(char c)
{
    if(c == '^') return 5;
    if(c == '*' || c == '/') return 4;
    if(c == '+' || c == '-') return 3;
    return 2;
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        string res = "";
        cin >> s;
        stack<char> st;
        for(int i = 0; i < s.length(); i++)
        {
            if(isalpha(s[i])) res += s[i];
            else if(s[i] == '(') st.push(s[i]);
            else if(s[i] == ')')
            {
                while(st.size() && st.top() != '(')
                {
                    res += st.top();
                    st.pop();
                }
                st.pop();
            }
            else if(s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/' || s[i] == '^')
            {
                while(st.size() && degree(st.top()) >= degree(s[i]))
                {
                    res += st.top();
                    st.pop();
                }
                st.push(s[i]);
            }
        }
        while(st.size())
        {
            if(st.top() != '(') res += st.top();
            st.pop();
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07009 - BIẾN ĐỔI TIỀN TỐ - TRUNG TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    string s, tmp;
    cin >> t;
    while(t--)
    {
        cin >> s;
        stack<string> st;
        for(int i = s.sz - 1; i >= 0; --i)
        {
            tmp = "";
            if(s[i] == '+' or s[i] == '-' or s[i] == '*' or s[i] == '/')
            {
                tmp += '(' + st.top();
                st.pop();
                tmp += s[i] + st.top() + ')';
                st.pop();
                st.push(tmp);
            }
            else st.push(tmp + s[i]);
        }
        while(st.sz)
        {
            cout << st.top();
            st.pop();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07010 - BIẾN ĐỐI TIỀN TỐ - HẬU TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    string s, tmp;
    cin >> t;
    while(t--)
    {
        cin >> s;
        stack<string> st;
        for(int i = s.sz - 1; i >= 0; --i)
        {
            tmp = "";
            if(s[i] == '+' or s[i] == '-' or s[i] == '*' or s[i] == '/')
            {
                tmp += st.top();
                st.pop();
                tmp += st.top() + s[i];
                st.pop();
                st.push(tmp);
            }
            else st.push(tmp + s[i]);
        }
        while(st.sz)
        {
            cout << st.top();
            st.pop();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07011 - BIẾN ĐỔI HẬU TỐ - TIỀN TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s, tmp;
    while(t--)
    {
        cin >> s;
        stack<string> st;
        for(char &i : s)
        {
            if(isalpha(i)) st.push(string(1, i));
            else
            {
                tmp = st.top();
                st.pop();
                tmp = st.top() + tmp;
                st.pop();
                tmp = i + tmp;
                st.push(tmp);
            }
        }
        cout << st.top() << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07012 - BIẾN ĐỔI HẬU TỐ - TRUNG TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s, tmp;
    while(t--)
    {
        cin >> s;
        stack<string> st;
        for(char &i : s)
        {
            if(isalpha(i)) st.push(string(1, i));
            else
            {
                tmp = st.top();
                st.pop();
                tmp = st.top() + i + tmp;
                st.pop();
                tmp = '(' + tmp + ')';
                st.push(tmp);
            }
        }
        cout << st.top() << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07013 - TÍNH GIÁ TRỊ BIỂU THỨC HẬU TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    ll a, b;
    while(t--)
    {
        cin >> s;
        stack<ll> st;
        for(char &i : s)
        {
            if(isdigit(i)) st.push(i - '0');
            else
            {
                b = st.top();
                st.pop();
                a = st.top();
                st.pop();
                switch(i)
                {
                    case '+':
                    {
                        st.push(a + b);
                        break;
                    }
                    case '-':
                    {
                        st.push(a - b);
                        break;
                    }
                    case '*':
                    {
                        st.push(a * b);
                        break;
                    }
                    default:
                    {
                        st.push(a / b);
                        break;
                    }
                }
            }
        }
        cout << st.top() << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07014 - TÍNH GIÁ TRỊ BIỂU THỨC TIỀN TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    ll a, b;
    while(t--)
    {
        cin >> s;
        reverse(all(s));
        stack<ll> st;
        for(char &i : s)
        {
            if(isdigit(i)) st.push(i - '0');
            else
            {
                a = st.top();
                st.pop();
                b = st.top();
                st.pop();
                switch(i)
                {
                    case '+':
                    {
                        st.push(a + b);
                        break;
                    }
                    case '-':
                    {
                        st.push(a - b);
                        break;
                    }
                    case '*':
                    {
                        st.push(a * b);
                        break;
                    }
                    default:
                    {
                        st.push(a / b);
                        break;
                    }
                }
            }
        }
        cout << st.top() << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07015 - TÍNH TOÁN GIÁ TRỊ BIỂU THỨC TRUNG TỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int degree(char c)
{
    if(c == '*' || c == '/') return 2;
    if(c == '+' || c == '-') return 1;
    return 0;
}

ll calc(ll a, ll b, char c)
{
    switch(c)
    {
        case '+':
            return a + b;
        case '-':
            return a - b;
        case '*':
            return a * b;
        default:
            return a / b;
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        stack <ll> num;
        stack <char> op;
        ll val, val1, val2;
        char top;
        for(int i = 0; i < s.sz; ++i)
        {
            if(s[i] == '(')
                op.push(s[i]);
            else if(isdigit(s[i]))
            {
                val = 0;
                while(i < s.sz and isdigit(s[i]))
                {
                    val = val * 10 + s[i] - '0';
                    ++i;
                }
                num.push(val);
                --i;
            }
            else if(s[i] == ')')
            {
                while(op.sz and op.top() != '(')
                {
                    val2 = num.top();
                    num.pop();
                    val1 = num.top();
                    num.pop();
                    char top = op.top();
                    op.pop();
                    num.push(calc(val1, val2, top));
                }
                if(op.sz)
                   op.pop();
            }
            else
            {
                while(op.sz and degree(op.top()) >= degree(s[i]))
                {
                    val2 = num.top();
                    num.pop();
                    val1 = num.top();
                    num.pop();
                    top = op.top();
                    op.pop();
                    num.push(calc(val1, val2, top));
                }
                op.push(s[i]);
            }
        }
        while(op.sz)
        {
            val2 = num.top();
            num.pop();
            val1 = num.top();
            num.pop();
            top = op.top();
            op.pop();
            num.push(calc(val1, val2, top));
        }
        cout << num.top() << endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07016 - BIỂU THỨC TĂNG GIẢM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        string ans = "";
        stack<int> st;
        for(int i = 0; i <= s.sz; ++i)
        {
            st.push(i + 1);
            if (i == s.sz or s[i] == 'I')
            {
                while(!st.empty())
                {
                    stringstream ss;
                    string tmp;
                    ss << st.top();
                    ss >> tmp;
                    ans += to_string(st.top());
                    st.pop();
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07017 - PHẦN TỬ BÊN PHẢI NHỎ HƠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        int res[n];
        for(int &i : a) cin >> i;
        res[n - 1] = -1;
        stack<int> st;
        st.push(n - 1);
        for(int i = n - 2; i >= 0; --i)
        {
            if(st.sz and a[i] < a[st.top()])
            {
                res[i] = st.top();
                st.push(i);
            }
            else
            {
                while(st.sz and a[i] >= a[st.top()]) st.pop();
                if(st.sz) res[i] = st.top();
                else res[i] = -1;
                st.push(i);
            }
        }
        stack<int> st2;
        int ans[n];
        ans[n - 1] = -1;
        st2.push(n - 1);
        for(int i = n - 2; i >= 0; --i)
        {
            if(st2.sz and a[i] > a[st2.top()])
            {
                ans[i] = st2.top();
                st2.push(i);
            }
            else
            {
                while(st2.sz and a[i] <= a[st2.top()]) st2.pop();
                if(st2.sz) ans[i] = st2.top();
                else ans[i] = -1;
                st2.push(i);
            }
        }
        for(int i = 0; i < n; ++i)
        {
            if(res[i] != -1 and ans[res[i]] != -1) cout << a[ans[res[i]]] << ' ';
            else cout << -1 << ' ';
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07018 - TỔNG ĐA THỨC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int heSo, mu;
    Node *next;
};

typedef Node* node;

node createNode(int heSo, int mu)
{
    node res = new Node;
    res -> heSo = heSo;
    res -> mu = mu;
    res -> next = NULL;
    return res;
}

void addBack(node &a, int heSo, int mu)
{
    if(a == NULL)
    {
        a = createNode(heSo, mu);
        return;
    }
    node tmp = a;
    while(tmp -> next != NULL)
        tmp = tmp -> next;
    tmp -> next = createNode(heSo, mu);
}

void init(node &a)
{
    string s;
    getline(cin, s);
    stringstream ss(s);
    while(ss >> s)
    {
        if(s == "+")
            continue;
        int heSo, mu, i;
        heSo = mu = 0;
        for(i = 0; i < s.sz; ++i)
        {
            if(s[i] == '*')
                break;
            heSo = heSo * 10 + s[i] - '0';
        }
        i += 3;
        for(; i < s.sz; ++i)
            mu = mu * 10 + s[i] - '0';
        addBack(a, heSo, mu);
    }
}

int Find(node a, int x)
{
    while(a != NULL)
    {
        if(a -> mu == x)
            return a -> heSo;
        else if(a -> mu < x)
            return 0;
        a = a -> next;
    }
    return 0;
}

void print(node a)
{
    while(a != NULL)
    {
        if(a -> heSo)
            cout << a -> heSo << "*x^" << a -> mu;
        a = a -> next;
        if(a != NULL and a -> heSo)
            cout << " + ";
    }
}

int main()
{
    faster();
    int t = 1, muMax;
    cin >> t;
    cin.ignore();
    while(t--)
    {
        node A, B, C;
        A = B = C = NULL;
        init(A);
        init(B);
        muMax = max(A -> mu, B -> mu);
        for(int i = muMax; ~i; --i)
            addBack(C, Find(A, i) + Find(B, i), i);
        print(C);
        cout << endl;
        delete A;
        delete B;
        delete C;
    }
    return 0;
}


================================================
FILE: Stack/DSA07019 - HÌNH CHỮ NHẬT LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ll a[n];
        for(ll &i : a) cin >> i;
        stack<int> st1, st2;
        int l[n], r[n];
        st1.push(n - 1);
        for(int i = n - 1; ~i; --i)
        {
            while(st1.sz and a[i] <= a[st1.top()]) st1.pop();
            if(st1.sz) r[i] = st1.top() - 1;
            else r[i] = n - 1;
            st1.push(i);
        }
        for(int i = 0; i < n; ++i)
        {
            while(st2.sz and a[i] <= a[st2.top()]) st2.pop();
            if(st2.sz) l[i] = st2.top() + 1;
            else l[i] = 0;
            st2.push(i);
        }
        ll res = -1;
        for(int i = 0; i < n; ++i) res = max(res, 1LL * (r[i] - l[i] + 1) * a[i]);
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07021 - DÃY NGOẶC ĐÚNG DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'
 
int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        stack<int> st;
        st.push(-1);
        int res = -1;
        for(int i = 0; i < s.sz; ++i)
        {
            if(s[i] == '(') st.push(i);
            else
            {
                st.pop();
                if(st.empty()) st.push(i);
                else res = max(res, i - st.top());
            }
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07022 - PHẦN TỬ CÓ SỐ LẦN XUẤT HIỆN NHIỀU HƠN BÊN PHẢI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        unordered_map<int, int> f;
        for(int &i : a)
        {
            cin >> i;
            ++f[i];
        }
        stack<int> st;
        int res[n];
        res[n - 1] = -1;
        st.push(n - 1);
        for(int i = n - 2; ~i; --i)
        {
            if(st.sz and f[a[i]] < f[a[st.top()]])
            {
                res[i] = a[st.top()];
                st.push(i);
            }
            else
            {
                while(st.sz and f[a[i]] >= f[a[st.top()]]) st.pop();
                if(st.sz) res[i] = a[st.top()];
                else res[i] = -1;
                st.push(i);
            }
        }
        for(int &i : res) cout << i << ' ';
        cout << endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07023 - ĐẢO TỪ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    string s;
    cin >> t;
    cin.ignore();
    while(t--)
    {
        getline(cin, s);
        stringstream ss(s);
        stack<string> st;
        while(ss >> s) st.push(s);
        while(st.sz)
        {
            cout << st.top() << ' ';
            st.pop();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07024 - GHÉP VÁN GỖ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ll a[n];
        for(ll &i : a) cin >> i;
        stack<int> st1, st2;
        int l[n], r[n];
        st1.push(n - 1);
        for(int i = n - 1; ~i; --i)
        {
            while(st1.sz and a[i] <= a[st1.top()]) st1.pop();
            if(st1.sz) r[i] = st1.top() - 1;
            else r[i] = n - 1;
            st1.push(i);
        }
        for(int i = 0; i < n; ++i)
        {
            while(st2.sz and a[i] <= a[st2.top()]) st2.pop();
            if(st2.sz) l[i] = st2.top() + 1;
            else l[i] = 0;
            st2.push(i);
        }
        ll res = 0;
        for(int i = 0; i < n; ++i)
            if(r[i] - l[i] + 1 >= a[i])
                res = max(res, a[i]);
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07027 - PHẦN TỬ BÊN PHẢI ĐẦU TIÊN LỚN HƠN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        int res[n];
        for(int &i : a) cin >> i;
        res[n - 1] = -1;
        stack<int> st;
        st.push(a[n - 1]);
        for(int i = n - 2; i >= 0; --i)
        {
            if(st.sz and a[i] < st.top())
            {
                res[i] = st.top();
                st.push(a[i]);
            }
            else
            {
                while(st.size() and a[i] >= st.top()) st.pop();
                if(st.sz) res[i] = st.top();
                else res[i] = -1;
                st.push(a[i]);
            }
        }
        for(int &i : res) cout << i << ' ';
        cout << endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07028 - NHỊP CHỨNG KHOÁN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vi a(n + 5), c(n + 5);
        stack<int> st;
        for(int i = 1; i <= n; ++i) cin >> c[i];
        for(int i = 1; i <= n; ++i)
        {
            while(st.sz && c[i] >= c[st.top()]) st.pop();
            if(st.empty()) a[i] = 0;
            else a[i] = st.top();
            st.push(i);
        }
        for(int i = 1; i <= n; ++i) cout << i - a[i] << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Stack/DSA07029 - GIẢI MÃ XÂU KÝ TỰ.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        stack<char> st;
        string num, tmp, a, ans;
        ans = "";
        for(char &i : s)
        {
            if(i == ']')
            {
                num = tmp = "";
                while(st.sz and st.top() != '[')
                {
                    tmp += st.top();
                    st.pop();
                }
                if(st.sz)
                    st.pop();
                while(st.sz and isdigit(st.top()))
                {
                    num = st.top() + num;
                    st.pop();
                }
                a = "";
                if(num == "")
                    num = "1";
                int limit = stoi(num);
                for(int j = 1; j <= limit; ++j)
                    a += tmp;
                for(int j = a.sz - 1; ~j; --j)
                    st.push(a[j]);
            }
            else
                st.push(i);
        }
        while(st.sz)
        {
            ans = st.top() + ans;
            st.pop();
        }
        cout << ans << endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07030 - HÌNH CHỮ NHẬT 0-1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    cin >> t;
    int n, m;
    int a[505][505];
    while(t--)
    {
        cin >> n >> m;
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < m; ++j)
                cin >> a[i][j];
        for(int i = 0; i < m; ++i)
            for(int j = 1; j < n; ++j)
                a[j][i] = (a[j - 1][i] + 1) * a[j][i];
        int res = 0;
        for(int i = 0; i < n; ++i)
        {
            stack<int> st;
            int x[m], y[m];
            st.push(-1);
            for(int j = 0; j < m; ++j)
            {
                while(st.sz > 1 and a[i][st.top()] >= a[i][j])
                    st.pop();
                x[j] = st.top() + 1;
                st.push(j);
            }
            st = {};
            st.push(m);
            for(int j = m - 1; ~j; --j)
            {
                while(st.sz > 1 and a[i][st.top()] >= a[i][j])
                    st.pop();
                y[j] = st.top() - 1;
                st.push(j);
            }
            for(int j = 0; j < m; ++j)
                res = max(res, (y[j] - x[j] + 1) * a[i][j]);
        }
        cout << res << endl;
    }
    return 0;
}




================================================
FILE: Stack/DSA07041 - BIỂU THỨC ĐÚNG DÀI NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        int res = 0;
        stack<char> st;
        for(char &i : s)
        {
            if (st.empty() or i == '(')
                st.push(i);
            else if(st.top() == '(')
            {
                st.pop();
                res += 2;
            }
        }
        bool check = 0;
        while(st.sz)
        {
            if(st.top() == '(')
            {
                if(check)
                {
                    res += 2;
                    check = 0;
                }
                st.pop();
            }
            else
            {
                check = 1;
                st.pop();
            }
        }
        cout << res <<endl;
    }
    return 0;
}


================================================
FILE: Stack/DSA07045 - GÕ BÀN PHÍM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        stack<char> st1, st2;
        for(char &i : s)
        {
            switch(i)
            {
                case '>':
                {
                    if(st2.sz)
                    {
                        st1.push(st2.top());
                        st2.pop();
                    }
                    break;
                }
                case '<':
                {
                    if(st1.sz)
                    {
                        st2.push(st1.top());
                        st1.pop();
                    }
                    break;
                }
                case '-':
                {
                    if(st1.sz)
                        st1.pop();
                    break;
                }
                default:
                    st1.push(i);
            }
        }
        while(st1.sz)
        {
            st2.push(st1.top());
            st1.pop();
        }
        while(st2.sz)
        {
            cout << st2.top();
            st2.pop();
        }
    }
    return 0;
}



================================================
FILE: Stack/DSA07110 - KIỂM TRA DÃY NGOẶC ĐÚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline string calc(string &s)
{
    stack<char> st;
    for(char &i : s)
    {
        if(i == '(' or i == '[' or i == '{') st.push(i);
        else
        {
            if(i == ')')
            {
                if(st.sz and st.top() == '(') st.pop();
                else return "NO";
            }
            else if(i == ']')
            {
                if(st.sz and st.top() == '[') st.pop();
                else return "NO";
            }
            else
            {
                if(st.sz and st.top() == '{') st.pop();
                else return "NO";
            }
        }
    }
    if(st.sz) return "NO";
    return "YES";
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        cout << calc(s) << endl;
    }
    return 0;
}


================================================
FILE: Stack/.DS_Store
================================================
[Non-text file]


================================================
FILE: Thực hành/BIẾN ĐỔI DÃY SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<pair<ll, ll>> vp(n);
        for(pair<ll, ll> &i : vp)
            cin >> i.fi >> i.se;
        ll dp[n][2];
        dp[0][1] = vp[0].se;
        dp[0][0] = 0;
        for(int i = 1; i < n; ++i)
        {
            if(vp[i].fi == vp[i - 1].fi)
            {
                dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + vp[i].se;
                dp[i][0] = dp[i - 1][1];
            }
            else
            {
                dp[i][0] = min(dp[i - 1][0], dp[i - 1][1]);
                dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + vp[i].se;
            }
        }
        cout << min(dp[n - 1][0], dp[n - 1][1]) << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/BIẾN ĐỔI VỀ XÂU ĐỐI XỨNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    string s, s1, s2;
    while(t--)
    {
        cin >> s2;
        s1 = s2;
        reverse(all(s2));
        vector<vector<int>> dp(105, vector<int>(105, 0));
        for(int i = 0; i < s1.sz; ++i)
        {
            for(int j = 0; j < s2.sz; ++j)
            {
                if(s1[i] == s2[j])
                    dp[i + 1][j + 1] = dp[i][j] + 1;
                else
                    dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j]);
            }
        }
        cout << s1.sz - dp[s1.sz][s2.sz] << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/BIỂU THỨC ĐÚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool check(string &s)
{
    stack<char> st;
    for(char &i : s)
    {
        if(i == '(')
            st.push(i);
        else
        {
            if(st.empty())
                return 0;
            st.pop();
        }
    }
    return st.empty();
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        string tmp;
        cin >> tmp;
        string s = "";
        for(char &i : tmp)
            if(i == ')' or i == '(')
                s += i;
        if(!check(s))
        {
            cout << -1 << endl;
            continue;
        }
        int cnt = 0, res = 0;
        for(char &i : s)
        {
            if(i == '(')
            {
                ++cnt;
                res = max(res, cnt);
            }
            else
                --cnt;
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/CHIA CẮT ĐỒ THỊ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[105];
bitset<105> visited;

inline void DFS(int u)
{
    visited[u] = 1;
    for(int &i : a[u])
        if(!visited[i])
            DFS(i);
}

int main()
{
    faster();
    int t = 1, v, e, x, y;
    cin >> t;
    while(t--)
    {
        cin >> v >> e;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        int k = 0;
        for(int i = 1; i <= v; ++i)
        {
            if(!visited[i])
            {
                ++k;
                DFS(i);
            }
        }
        int res = 1e9;
        for(int i = 1; i <= v; ++i)
        {
            int cnt = 0;
            visited.reset();
            visited[i] = 1;
            for(int j = 1; j <= v; ++j)
            {
                if(!visited[j])
                {
                    ++cnt;
                    DFS(j);
                }
            }
            if(cnt > k)
            {
                res = i;
                k = cnt;
            }
        }
        if(res == 1e9)
            cout << 0 << endl;
        else
            cout << res << endl;
        for(int i = 1; i <= v; ++i)
            a[i].clear();
        visited.reset();
    }
    return 0;
}




================================================
FILE: Thực hành/CHÊNH LỆCH NHỎ NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    //cin >> t;
    while(t--)
    {
        cin >> n >> k;
        vector<string> vs(n);
        for(string &i : vs)
            cin >> i;
        vi v;
        for(int i = 0; i < k; ++i)
            v.pb(i);
        vector<vi> vvi;
        vvi.pb(v);
        while(next_permutation(all(v)))
            vvi.pb(v);
        int ans = 1e9, MAX, MIN, num;
        for(vi &i : vvi)
        {
            MAX = -1;
            MIN = 1e9;
            for(int j = 0; j < n; ++j)
            {
                string s = "";
                for(int &z : i)
                    s += vs[j][z];
                num = stoi(s);
                MAX = max(MAX, num);
                MIN = min(MIN, num);
            }
            ans = min(ans, MAX - MIN);
        }
        cout << ans << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/DI CHUYỂN TRONG MÊ CUNG.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
bool a[100][100];
bool check[100][100];
vector<string> res;

void Try(int i, int j, string s = "")
{
    if(!a[1][1] or !a[n][n]) return;
    if(i == n && j == n)
    {
        res.pb(s);
        return;
    }
    if(a[i + 1][j] and i != n and !check[i + 1][j])
    {
        check[i][j] = 1;
        Try(i + 1, j, s + "D");
        check[i][j] = 0;
    }
    if(a[i][j - 1] and j != 1 and !check[i][j - 1])
    {
        check[i][j] = 1;
        Try(i, j - 1, s + "L");
        check[i][j] = 0;
    }
    if(a[i][j + 1] and j != n and !check[i][j + 1])
    {
        check[i][j] = 1;
        Try(i, j + 1, s + "R");
        check[i][j] = 0;
    }
    if(a[i - 1][j] and i != 1 and !check[i - 1][j])
    {
        check[i][j] = 1;
        Try(i - 1, j, s + "U");
        check[i][j] = 0;
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        res.clear();
        for (int i = 1; i <= n; ++i)
        {
            for (int j = 1; j <= n; ++j)
            {
                cin >> a[i][j];
                check[i][j] = 0;
            }
        }
        Try(1, 1);
        if(res.empty()) cout << -1 << endl;
        else
        {
            cout << res.sz << ' ';
            for(string &i : res) cout << i << ' ';
            cout << endl;
        }
    }
    return 0;
}



================================================
FILE: Thực hành/DUYỆT CÂY THEO MỨC ĐẢO NGƯỢC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline void BFS(binTree T)
{
    queue<binTree> q;
    stack<int> st;
    q.push(T);
    binTree top;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        st.push(top -> val);
        if(top -> right)
            q.push(top -> right);
        if(top -> left)
            q.push(top -> left);
    }
    while(st.sz)
    {
        cout << st.top() << ' ';
        st.pop();
    }
}

int main()
{
    faster();
    int t = 1, n, child, par;
    char c;
    cin >> t;
    while(t--)
    {
        cin >> n;
        unordered_map<int, binTree> m;
        cin >> par >> child >> c;
        binTree T = createNode(par);
        if(c == 'L')
        {
            T -> left = createNode(child);
            m[child] = T -> left;
        }
        else
        {
            T -> right = createNode(child);
            m[child] = T -> right;
        }
        m[par] = T;
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            if(c == 'L')
            {
                m[par] -> left = createNode(child);
                m[child] = m[par] -> left;
            }
            else
            {
                m[par] -> right = createNode(child);
                m[child] = m[par] -> right;
            }
        }
        BFS(T);
        cout << endl;
    }
    return 0;
}




================================================
FILE: Thực hành/DÃY CON CÓ TỔNG BẰNG S.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, s, MIN = 35;
int a[35];
vector<int> v;

void Try(int i, ll sum = 0)
{
    if(sum == s)
    {
        MIN = min(MIN, (int) v.sz);
        return;
    }
    for(int j = i; j < n; ++j)
    {
        if(sum + a[j] <= s and v.sz < MIN)
        {
            v.pb(a[j]);
            Try(j + 1, sum + a[j]);
            v.pop_back();
        }
    }
}

int main()
{
    faster();
    cin >> n >> s;
    for(int i = 0; i < n; ++i)
        cin >> a[i];
    Try(0);
    if(MIN < 35)
    	cout << MIN;
    else
        cout << -1;
    return 0;
}


================================================
FILE: Thực hành/DÃY CON LIÊN TIẾP.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int n;
    cin >> n;
    int a[n];
    for(int &i : a)
        cin >> i;
    int MAX = -1;
    for(int i = 1; i < n; ++i)
        MAX = max(MAX, a[i]);
    int res = 0, cur = 0;
    for(int i = 0; i < n; ++i)
    {
        if(a[i] == MAX)
            ++cur;
        else
        {
            res = max(res, cur);
            cur = 0;
        }
    }
    cout << max(res, cur);
    return 0;
}



================================================
FILE: Thực hành/DÃY CON TĂNG DẦN.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
int a[25];
vector<int> v;
vector<string> res;

void Try(int i)
{
    if(v.sz > 1)
    {
        string s = "";
        for(int &i : v)
            s += to_string(i) + ' ';
        res.pb(s);
    }
    for(int j = i; j < n; ++j)
    {
        if(v.empty() or a[j] > v.back())
        {
            v.pb(a[j]);
            Try(j + 1);
            v.pop_back();
        }
    }
}

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i)
            cin >> a[i];
        Try(0);
        sort(all(res));
        for(string &i : res)
            cout << i << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/DÃY SỐ ĐẸP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ll res = 0;
        int a[n];
        for(int &i : a)
            cin >> i;
        int MAX, MIN;
        for(int i = 0; i < n - 1; ++i)
        {
            MAX = max(a[i], a[i + 1]);
            MIN = min(a[i], a[i + 1]);
            while(MAX > (MIN << 1))
            {
                ++res;
                MIN <<= 1;
            }
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/HOÁN VỊ NGƯỢC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        string s = "";
        for(int i = 1; i <= n; ++i)
            s += (char) i + '0';
        stack<string> st;
        st.push(s);
        while(next_permutation(all(s)))
            st.push(s);
        while(st.sz > 1)
        {
            cout << st.top() << ',';
            st.pop();
        }
        cout << st.top() << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/HÌNH CHỮ NHẬT ĐƠN SẮC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int n, m;
    cin >> n >> m;
    int a[m], b[m];
    for(int &i : a)
        cin >> i;
    for(int i = 0; i < m; ++i)
        b[i] = n - a[i];
    int l[m], r[m];
    stack<int> st1, st2, st3, st4;
    st1.push(m - 1);
    for(int i = m - 1; ~i; --i)
    {
        while(st1.sz and a[i] <= a[st1.top()])
            st1.pop();
        if(st1.sz)
            r[i] = st1.top() - 1;
        else
            r[i] = m - 1;
        st1.push(i);
    }
    for(int i = 0; i < m; ++i)
    {
        while(st2.sz and a[i] <= a[st2.top()])
            st2.pop();
        if(st2.sz)
            l[i] = st2.top() + 1;
        else
            l[i] = 0;
        st2.push(i);
    }
    ll res1 = 0, res2 = 0;
    for(int i = 0; i < m; ++i)
            res1 = max(res1, 1LL * a[i] * (r[i] - l[i] + 1));
    st3.push(m - 1);
    for(int i = m - 1; ~i; --i)
    {
        while(st3.sz and b[i] <= b[st3.top()])
            st3.pop();
        if(st3.sz)
            r[i] = st3.top() - 1;
        else
            r[i] = m - 1;
        st3.push(i);
    }
    for(int i = 0; i < m; ++i)
    {
        while(st4.sz and b[i] <= b[st4.top()])
            st4.pop();
        if(st4.sz)
            l[i] = st4.top() + 1;
        else
            l[i] = 0;
        st4.push(i);
    }
    for(int i = 0; i < m; ++i)
            res2 = max(res2, 1LL * b[i] * (r[i] - l[i] + 1));
    cout << max(res1, res2);
    return 0;
}




================================================
FILE: Thực hành/KIỂM TRA CÂU VIẾT ĐÚNG QUY TẮC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline string check(string &s)
{
    stack<char> st;
    for(char &i : s)
    {
        if(i == '(' or i == '[')
            st.push(i);
        if(i == ')')
        {
            if(st.sz and st.top() == '(')
                st.pop();
            else
                return "NO";
        }
        else if(i == ']')
        {
            if(st.sz and st.top() == '[')
                st.pop();
            else
                return "NO";
        }
    }
    if(st.empty())
        return "YES";
    return "NO";
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    cin.ignore();
    while(t--)
    {
        getline(cin, s);
        cout << check(s) << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/KIỂM TRA LIÊN THÔNG MẠNH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[10005], b[10005];
bitset<10005> visited;
int cnt, res;
int dis[10005] = {}, low[10005] = {};
int n, m;
stack<int> st;

inline void DFS(vector<int> c[], int u)
{
    visited[u] = 1;
    for(int &i : c[u])
        if(!visited[i])
            DFS(c, i);
}

inline void DFS2(int u)
{
    dis[u] = low[u] = cnt++;
    st.push(u);
    for(int &i : a[u])
    {
        if(dis[i])
            low[u] = min(low[u], dis[i]);
        else
        {
            DFS2(i);
            low[u] = min(low[u], low[i]);
        }
    }
    if(dis[u] == low[u])
    {
        ++res;
        int top = st.top();
        st.pop();
        dis[top] = low[top] = 1e9;
        while(top != u)
        {
            top = st.top();
            st.pop();
            dis[top] = low[top] = 1e9;
        }
    }
}

inline bool check()
{
    for(int i = 1; i <= n; ++i)
        if(!visited[i])
            return 0;
    return 1;
}

int main()
{
    faster();
    int t = 1, x, y;
    cin >> t;
    while(t--)
    {
        cin >> n >> m;
        while(m--)
        {
            cin >> x >> y;
            a[x].pb(y);
            b[y].pb(x);
        }
        DFS(a, 1);
        if(check())
        {
            visited.reset();
            DFS(b, 1);
            if(check())
                cout << "YES\n";
            else
                goto A;
        }
        else
        {
            A:
            cnt = 1;
            res = 0;
            for(int i = 1; i <= n; ++i)
                if(!dis[i])
                    DFS2(i);
            cout << "NO " << res << endl;
            memset(dis, 0, sizeof(low));
            memset(low, 0, sizeof(dis));
        }
        visited.reset();
        for(int i = 1; i <= n; ++i)
        {
            a[i].clear();
            b[i].clear();
        }
        st = {};
    }
    return 0;
}



================================================
FILE: Thực hành/LIÊN THÔNG MẠNH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[10005];
int cnt = 1, res = 0;
int dis[10005] = {}, low[10005] = {};
stack<int> st;

inline void DFS(int u)
{
    dis[u] = low[u] = cnt++;
    st.push(u);
    for(int &i : a[u])
    {
        if(dis[i])
            low[u] = min(low[u], dis[i]);
        else
        {
            DFS(i);
            low[u] = min(low[u], low[i]);
        }
    }
    if(dis[u] == low[u])
    {
        ++res;
        int i = st.top();
        st.pop();
        dis[i] = low[i] = 1e9;
        while(i != u)
        {
            i = st.top();
            st.pop();
            dis[i] = low[i] = 1e9;
        }
    }
}

int main()
{
    faster();
    int t = 1, n, m, x, y;
    //cin >> t;
    while(t--)
    {
        cin >> n >> m;
        while(m--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        res = 0;
        for(int i = 1; i <= n; ++i)
            if(!dis[i])
                DFS(i);
        cout << res;
    }
    return 0;
}




================================================
FILE: Thực hành/LŨY THỪA BẬC K.cpp
================================================
// Created by Nguyễn Mạnh Quân
// Code WA

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

ll mod = 1e9 + 7;

inline ll Mul(ll a, ll b, ll MOD)
{
    a %= MOD;
    b %= MOD;
    long double tmp = a * b;
    ll x = tmp / MOD;
    return (a * b - x * MOD) % MOD;
}

inline ll binPow(ll a, ll b)
{
    ll res = 1;
    while(b)
    {
        if(b & 1)
            res = (Mul(res, a, mod)) % mod;
        a = (Mul(a, a, mod)) % mod;
        b >>= 1;
    }
    return res % mod;
}

int main()
{
    faster();
    int t;
    cin >> t;
    ll n, k;
    while(t--)
    {
        cin >> n >> k;
        vector<ll> v(k + 5);
        v[0] = 1;
        for(int i = 1; i <= k + 1; ++i)
            v[i] = (v[i - 1] + binPow(i + 1, k));
        if(n <= k + 2)
        {
            cout << v[n - 1] << endl;
            continue;
        }
        vector<ll> fact(k + 5), inv(k + 5);
        fact[0] = 1;
        for(int i = 1; i <= k + 1; ++i)
            fact[i] = Mul(fact[i - 1], i, mod);
        inv[k + 1] = binPow(fact[k + 1], mod - 2);
        for(ll i = k; ~i; --i)
            inv[i] = Mul(inv[i + 1], i + 1, mod);
        ll x = 1;
        for(int i = 1; i <= k + 2; ++i)
            x = Mul(x, n - i, mod);
        ll res = 0, tmp1, tmp2;
        for(int i =  1; i <= k + 2; ++i)
        {
            if(((k - i) & 1) ^ 1)
                tmp1 = v[i - 1];
            else
                tmp1 = -v[i - 1];
            if(tmp1 < 0)
                tmp1 += mod;
            tmp2 = x * binPow(n - i, mod - 2) % mod * Mul(inv[k + 2 - i], inv[i - 1], mod);
            res = (res + Mul(tmp1, tmp2, mod)) % mod;
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/LŨY THỪA MA TRẬN 4.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, mod = 1e9 + 7;

struct matrix
{
    long long a[15][15];
    
    matrix operator * (matrix A)
    {
        matrix res, B = *this;
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                res.a[i][j] = 0;
                for(int z = 0; z < n; ++z)
                {
                    res.a[i][j] += A.a[i][z] * B.a[z][j] % mod;
                    res.a[i][j] %= mod;
                }
            }
        }
        return res;
    }
};

matrix binPow(matrix A, long long k)
{
    if(k == 1)
        return A;
    matrix res = binPow(A, k / 2);
    res = res * res;
    if(k % 2 == 1)
        res = res * A;
    return res;
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        long long k;
        cin >> n >> k;
        matrix A, res;
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                cin >> A.a[i][j];
        res = binPow(A, k);
        long long sum = 0;
        for(int i = 0; i < n; ++i)
            sum = (sum + res.a[0][i]) % mod;
        cout << sum % mod << endl;
    }
}


================================================
FILE: Thực hành/LŨY THỪA MA TRẬN 5.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, mod = 1e9 + 7;

struct matrix
{
    long long a[15][15];
    
    matrix operator * (matrix A)
    {
        matrix res, B = *this;
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                res.a[i][j] = 0;
                for(int z = 0; z < n; ++z)
                {
                    res.a[i][j] += A.a[i][z] * B.a[z][j] % mod;
                    res.a[i][j] %= mod;
                }
            }
        }
        return res;
    }
};

matrix binPow(matrix A, long long k)
{
    if(k == 1)
        return A;
    matrix res = binPow(A, k / 2);
    res = res * res;
    if(k % 2 == 1)
        res = res * A;
    return res;
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        long long k;
        cin >> n >> k;
        matrix A, res;
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                cin >> A.a[i][j];
        res = binPow(A, k);
        long long sum = 0;
        for(int i = 0; i < n; ++i)
            sum = (sum + res.a[n - 1][i]) % mod;
        cout << sum % mod << endl;
    }
}


================================================
FILE: Thực hành/LŨY THỪA MA TRẬN.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, mod = 1e9 + 7;

struct matrix
{
    long long a[15][15];
    
    matrix operator * (matrix A)
    {
        matrix res, B = *this;
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < n; ++j)
            {
                res.a[i][j] = 0;
                for(int z = 0; z < n; ++z)
                {
                    res.a[i][j] += A.a[i][z] * B.a[z][j] % mod;
                    res.a[i][j] %= mod;
                }
            }
        }
        return res;
    }
};

matrix binPow(matrix A, long long k)
{
    if(k == 1)
        return A;
    matrix res = binPow(A, k / 2);
    res = res * res;
    if(k % 2 == 1)
        res = res * A;
    return res;
}

int main()
{
    faster();
    int t;
    cin >> t;
    while(t--)
    {
        long long k;
        cin >> n >> k;
        matrix A, res;
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j)
                cin >> A.a[i][j];
        res = binPow(A, k);
        long long sum = 0;
        for(int i = 0; i < n; ++i)
            sum = (sum + res.a[i][n - i - 1]) % mod;
        cout << sum % mod << endl;
    }
}



================================================
FILE: Thực hành/MIN VÀ MAX.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int n;
    cin >> n;
    int a[n];
    stack<int> stL, stR;
    for(int &i : a)
        cin >> i;
    int L[n], R[n];
    for(int i = 0; i < n; ++i)
    {
        while(stL.sz and a[i] <= a[stL.top() - 1])
            stL.pop();
        if(stL.empty())
            L[i] = 0;
        else
            L[i] = stL.top();
        stL.push(i + 1);
    }
    for(int i = n - 1; ~i; --i)
    {
        while(stR.sz and a[i] <= a[stR.top() + 1])
            stR.pop();
        if(stR.empty())
            R[i] = n - 1;
        else
            R[i] = stR.top();
        stR.push(i - 1);
    }
    ll res = -1;
    for(int i = 0; i < n; ++i)
        res = max(res, 1LL * a[i] * (R[i] - L[i] + 1));
    cout << res;
    return 0;
}



================================================
FILE: Thực hành/MÃ SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

char t[7] = {};
bool dd[7] = {};
int x[7] = {}, n;
vector<string> v1, v2;

void printStr()
{
    string s = "";
    for(int i = 1; i <= n; ++i)
    {
        char tmp = (char) x[i] + 'A' - 1;
        s += tmp;
    }
    v1.pb(s);
}

void printInt()
{
    string s = "";
    for(int i = 1; i <= n; ++i)
        s += to_string(x[i]);
    v2.pb(s);
}

void TryInt(int i)
{
    for(int j = 1; j <= n; ++j)
    {
        x[i] = j;
        if(i < n)
            TryInt(i + 1);
        else
            printInt();
    }
}

void TryStr(int i)
{
    for(int j = 1; j <= n; ++j)
    {
        if(!dd[j])
        {
            dd[j] = 1;
            x[i] = j;
            if(i < n)
                TryStr(i + 1);
            else
                printStr();
            dd[j] = 0;
        }
    }
}

int main()
{
    faster();
    cin >> n;
    TryInt(1);
    TryStr(1);
    for(string i : v1)
        for(string j : v2)
            cout << i + j << endl;
    return 0;
}



================================================
FILE: Thực hành/NGƯỜI DU LỊCH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, MIN = INT_MAX;
int a[20][20];
bitset<20> bs;
vector<int> res, v;

void Try(int i, int sum = 0, int cnt = 1)
{
    if(sum > MIN)
        return;
    if(cnt == n)
    {
        if(MIN > sum + a[i][1])
        {
            MIN = sum + a[i][1];
            res = v;
        }
        return;
    }
    for(int j = 2; j <= n; ++j)
    {
        if(!bs[j])
        {
            bs[j] = 1;
            v[cnt] = j;
            Try(j, sum + a[i][j], cnt + 1);
            bs[j] = 0;
        }
    }
}

int main()
{
    faster();
    cin >> n;
    for(int i = 1; i <= n; ++i)
        for(int j = 1; j <= n; ++j)
            cin >> a[i][j];
    res.resize(n + 5);
    v.resize(n + 5);
    res[n] = v[n] = 1;
    bs[1] = 1;
    Try(1);
    cout << "(1,";
    for(int i = 1; i < n; ++i)
        cout << res[i] << ",";
    cout << res[n] << ")\n";
    cout << MIN;
    return 0;
}



================================================
FILE: Thực hành/PHẦN TỬ LỚN NHẤT TRONG DÃY CON.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, k;
    cin >> t;
    while(t--)
    {
        deque<int> dq;
        cin >> n >> k;
        int a[n];
        for(int &i : a) cin >> i;
        dq.push_back(0);
        for(int i = 1; i < k; ++i)
        {
            while(!dq.empty() && a[dq.back()] < a[i]) dq.pop_back();
            dq.push_back(i);
        }
        cout << a[dq.front()] << ' ';
        for(int i = k; i < n; ++i)
        {
            while(!dq.empty() && a[dq.back()] < a[i]) dq.pop_back();
            dq.push_back(i);
            if(i - dq.front() < k) cout << a[dq.front()] << ' ';
            else
            {
                dq.pop_front();
                cout << a[dq.front()] << ' ';
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/QUÂN VUA TRÊN BÀN CỜ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; ++i)
#define FORD(i, a, b) for(int i = a; i >= b; --i)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define vb vector<bool>
#define PI 3.141592653589793238
#define endl '\n'

int main()
{
    faster();
    int s1, s2, f1, f2;
    cin >> s1 >> s2 >> f1 >> f2;
    cout << max(abs(s1 - f1), abs(s2 - f2));
    return 0;
}


================================================
FILE: Thực hành/SẮP XẾP CHẴN LẺ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int n, x;
    cin >> n;
    bitset<1005> bs;
    vector<int> odd, even;
    for(int i = 0; i < n; ++i)
    {
        cin >> x;
        bs[i] = x & 1;
        if(bs[i])
            odd.pb(x);
        else
            even.pb(x);
    }
    sort(all(odd));
    sort(all(even), greater<int>());
    for(int i = 0; i < n; ++i)
    {
        if(bs[i])
        {
            cout << odd.back() << ' ';
            odd.pop_back();
        }
        else
        {
            cout << even.back() << ' ';
            even.pop_back();
        }
    }
    return 0;
}



================================================
FILE: Thực hành/SẮP XẾP QUÂN HẬU.cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int ans, n = 8;
bitset<16> x, y;
bitset<9> f;
vector<vi> a(9, vi (9));

void Try(int i, int sum = 0)
{
    if(i > n)
    {
        ans = max(ans, sum);
        return;
    }
    for(int j = 1; j <= n; ++j)
        if(!f[j] and !x[j + i - 1] and !y[j - i + n])
        {
            f[j] = 1;
            x[j + i - 1] = 1;
            y[j - i + n] = 1;
            Try(i + 1, sum + a[i][j]);
            f[j] = 0;
            x[j + i - 1] = 0;
            y[j - i + n] = 0;
        }
}

int main()
{
    faster();
    int t = 1, cnt = 1;
    cin >> t;
    while(t--)
    {
        ans = 0;
        for(int i = 1; i <= 8; i++)
            for(int j = 1; j <= 8; j++)
                cin >> a[i][j];
        Try(1);
        cout << "Test " << cnt++ << ": " << ans << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/SỐ 2 ƯU THẾ.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline bool check(string s)
{
    int cnt = 0;
    for(char &i : s)
        cnt += i == '2';
    return cnt > (s.sz >> 1);
}

int main()
{
    faster();
    queue<string> q;
    q.push("1");
    q.push("2");
    vector<string> res;
    string top;
    while(res.sz < 1e3)
    {
        top = q.front();
        q.pop();
        if(check(top))
            res.pb(top);
        for(char i = '0'; i <= '2'; ++i)
            q.push(top + i);
    }
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i)
            cout << res[i] << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/SỐ CẶP BẠN TỐT.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    const int nmax = 300005;
    int n, k, a[nmax], dp[nmax][25];
    string s;
    cin >> n >> k;
    for(int i = 1; i <= n; ++i)
    {
        cin >> s;
        a[i] = s.sz;
    }
    for(int i = 1; i <= n; ++i) dp[i][0] = 0;
    for(int i = 1; i <= 20; ++i) dp[0][i] = 0;
    for(int j = 1; j <= 20; ++j)
      for(int i = 1; i <= n; ++i)
        if(a[i] == j)
            dp[i][j] = dp[i - 1][j] + 1;
        else
            dp[i][j] = dp[i - 1][j];
    ll res = 0;
    int tmp;
    for(int i = 1; i <= n; ++i)
    {
        tmp = 0;
        tmp = max(i - k - 1, tmp);
        res += dp[i][a[i]] - dp[tmp][a[i]] - 1;
    }
    cout << res;
    return 0;
}



================================================
FILE: Thực hành/SỐ LƯỢNG DẤU NGOẶC VUÔNG LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        int cnt = 0, res = 0;
        stack<pair<char, int>> st;
        st.push({'*', 0});
        for(char &i : s)
        {
            if(st.sz and ((i == ')' and st.top().fi == '(') or (i == ']' and  st.top().fi == '[')))
            {
                st.pop();
                if(st.sz)
                    res = max(res, cnt - st.top().se);
            }
            else
            {
                cnt += i == '[';
                st.push({i, cnt});
            }
        }
        cout << res;
    }
    return 0;
}




================================================
FILE: Thực hành/SỐ LỘC PHÁT ĐỐI XỨNG CHẴN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    vector<string> vs;
    vs.pb("66");
    vs.pb("88");
    queue<string> q;
    q.push("6");
    q.push("8");
    string s1, s2, top;
    while(vs.sz < 10005)
    {
        top = q.front();
        q.pop();
        s1 = top + '6';
        s2 = top + '8';
        q.push(s1);
        q.push(s2);
        reverse(all(s1));
        vs.pb(top + '6' + s1);
        reverse(all(s2));
        vs.pb(top + '8' + s2);
    }
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i)
            cout << vs[i] << ' ';
        cout << endl;
    }
    return 0;
}




================================================
FILE: Thực hành/SỐ LỘC PHÁT.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, MAX;
    cin >> t;
    while(t--)
    {
        cin >> n;
        MAX = 1 << n;
        vector<ll> ans;
        for(int i = 0; i < MAX; ++i)
        {
            string s = "";
            for(int j = n - 1; ~j; --j)
                if((i >> j) & 1)
                    s += '8';
                else
                    s += '6';
            ans.pb(stoll(s));
        }
        cout << ans.sz << endl;
        for(ll &i : ans)
            cout << i << ' ';
        cout << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/SỐ MAY MẮN TIẾP THEO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        queue<ll> q;
        vll luckyNum;
        q.push(4);
        q.push(7);
        luckyNum.pb(4);
        luckyNum.pb(7);
        ll top, x, y;
        while(q.front() <= 1e9)
        {
            top = q.front();
            q.pop();
            x = top * 10 + 4;
            y = top * 10 + 7;
            q.push(x);
            q.push(y);
            luckyNum.pb(x);
            luckyNum.pb(y);
        }
        int a, b, idx;
        cin >> a >> b;
        ll res = 0, cnt = 0;
        idx = lower_bound(all(luckyNum), a) - luckyNum.begin();
        while(a <= b)
        {
            cnt = min(luckyNum[idx], 1LL * b) - a + 1;
            res += cnt * luckyNum[idx];
            a = luckyNum[idx] + 1;
            ++idx;
        }
        cout << res;
    }
    return 0;
}



================================================
FILE: Thực hành/SỐ NGUYÊN THỦY.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    vector<string> vs;
    vs.pb("44");
    vs.pb("55");
    queue<string> q;
    q.push("4");
    q.push("5");
    string s1, s2, top;
    while(vs.sz < 10005)
    {
        top = q.front();
        q.pop();
        s1 = top + '4';
        s2 = top + '5';
        q.push(s1);
        q.push(s2);
        reverse(all(s1));
        vs.pb(top + '4' + s1);
        reverse(all(s2));
        vs.pb(top + '5' + s2);
    }
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i)
            cout << vs[i] << ' ';
        cout << endl;
    }
    return 0;
}




================================================
FILE: Thực hành/SỐ THUẬN NGHỊCH.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> s;
        vector<bitset<1005>> dp(s.sz + 5);
        int res = 1;
        dp[s.sz - 1][s.sz - 1] = 1;
        for(int i = 0; i < s.sz - 1; ++i)
        {
            dp[i][i] = 1;
            if(s[i] == s[i + 1])
            {
                dp[i][i + 1] = 1;
                res = 2;
            }
        }
        int z;
        for(int i = 3; i <= s.sz; ++i)
        {
            for(int j = 0; j < s.sz - i + 1; ++j)
            {
                z = i + j - 1;
                if(s[j] == s[z] and dp[j + 1][z - 1])
                {
                    dp[j][z] = 1;
                    res = max(res, i);
                }
            }
        }
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/TRÒ CHƠI CARO "NGANG".cpp
================================================
#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

char c, dc;
string s;

inline bool check(vi &v)
{
    s = "";
    int cnt0 = 0, cnt1 = 0;
    int max1 = 0, max0 = 0;
    for(int &i : v)
    {
        if(i)
        {
            s += c;
            max0 = max(max0, cnt0);
            cnt0 = 0;
            ++cnt1;
        }
        else
        {
            s += dc;
            max1 = max(max1, cnt1);
            cnt1 = 0;
            ++cnt0;
        }
    }
    max0 = max(max0, cnt0);
    max1 = max(max1, cnt1);
    return (max1 > max0 and max1 >= 5);
}

int main()
{
    faster();
    int t = 1, n, MAX;
    cin >> t;
    while(t--)
    {
        cin >> n >> c;
        if(c == 'X')
            dc = 'O';
        else
            dc = 'X';
        MAX = 1 << n;
        vector<vi> v;
        for(int i = 31; i < MAX; ++i)
        {
            vi tmp;
            for(int j = n - 1; ~j; --j)
                tmp.pb((i >> j) & 1);
            v.pb(tmp);
        }
        vector<string> vs;
        for(vector<int> &i : v)
        {
            if(check(i))
                vs.pb(s);
        }
        sort(all(vs));
        for(string &i : vs)
            cout << i << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/TÍCH CHỮ SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    ll n;
    while(t--)
    {
        cin >> n;
        if(n < 10)
        {
            cout << n << endl;
            continue;
        }
        stack<int> st;
        int i = 9;
        while(n > 1 and i > 1)
        {
            while(n % i == 0)
            {
                st.push(i);
                n /= i;
            }
            --i;
        }
        if(st.empty() or n > 9)
        {
            cout << -1 << endl;
            continue;
        }
        while(st.sz)
        {
            cout << st.top();
            st.pop();
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/TỔ HỢP “NGƯỢC”.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, k;
stack<string> st;
int a[25];

void Try(int i, int idx = 1)
{
    for(int j = i; j <= n; ++j)
    {
        a[idx] = j;
        if(idx == k)
        {
            string s = "";
            for(int z = 1; z <= k; ++z)
                s += to_string(a[z]) + ' ';
            st.push(s);
        }
        else
            Try(j + 1, idx + 1);
    }
}

int main()
{
    int t;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        Try(1);
        while(st.sz)
        {
            cout << st.top() << endl;
            st.pop();
        }
    }
    return 0;
}



================================================
FILE: Thực hành/TỔNG CHỮ SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

string s;
ll n;
int k;

int calcSumDigit()
{
    int Sum = 0;
    for(char &i : s)
        Sum += i - '0';
    return Sum;
}

void bienDoi()
{
    int Sum = 0;
    for(int i = 1; i < s.size(); ++i)
    {
        Sum += s[i] - '0';
        if(Sum > k)
        {
            int idx = i - 1;
            while(s[idx] == '9')
                --idx;
            ++s[idx];
            for(int j = idx + 1; j < s.size(); ++j)
                s[j] = '0';
            break;
        }
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n >> k;
        s = '0' + to_string(n);
        while(calcSumDigit() > k)
            bienDoi();
        cout << stoll(s) - n << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/TỔNG CÁC SỐ TỰ NHIÊN.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
vi a;
vector<vi> ans;

void Try(int i, vi v, int sum = 0)
{
    if(sum > n)
        return ;
    if(sum == n)
    {
        ans.pb(v);
        return;
    }
    for(int j = i; j < a.sz; ++j)
    {
        v.pb(a[j]);
        Try(j, v, sum + a[j]);
        v.pop_back();
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        vi v;
        cin >> n;
        a.resize(n);
        for(int i = n; i > 0; --i)
            a[n - i] = i;
        Try(0, v);
        cout << ans.sz << endl;
        for(vector<int> &i : ans)
        {
            cout << '(';
            for(int j = 0; j < i.sz - 1; ++j)
                cout << i[j] << ' ' ;
            cout << i.back() << ')' << ' ';
        }
        cout << endl;
        ans.clear();
    }
    return 0;
}



================================================
FILE: Thực hành/TỔNG SỐ CÁCH DI CHUYỂN.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n, k;
    cin >> t;
    int mod = 1e9 + 7;
    while(t--)
    {
        cin >> n >> k;
        int dp[100005] = {};
        dp[0] = dp[1] = 1;
        for(int i = 2; i <= n; ++i)
        {
            for(int j = 1; j <= min(i, k); ++j)
            {
                dp[i] += dp[i - j];
                dp[i] %= mod;
            }
        }
        cout << dp[n] << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/TỔNG ƯỚC SỐ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int N, a, b, cnt = 0;
    cin >> a >> b;
    N = b;
    vll div(N + 5, 1);
    for(int i = 2; i <= N; ++i)
        for(int j = i; j <= N; j += i)
            div[j] += i;
    for(int i = a; i <= b; ++i)
        cnt += (div[i] - i > i);
    cout << cnt;
    return 0;
}



================================================
FILE: Thực hành/XÂU AB.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
vector<char> v;
string res;

void Try(int i)
{
    for(int j = 'A'; j <= 'B'; ++j)
    {
        v.pb(j);
        if(i == n)
        {
            for(char &x : v)
                res += x;
            res += ',';
        }
        else
            if(v.sz < n)
                Try(i + 1);
        v.pop_back();
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    while(t--)
    {
        cin >> n;
        res = "";
        Try(1);
        res.pop_back();
        cout << res << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/XÂU CON NHỎ NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> s;
        bitset<260> bs;
        for(char &i : s)
            bs[i] = 1;
        int m[260] = {};
        int l, r, cnt;
        l = r = cnt = 0;
        int res = s.sz;
        while(r < s.sz)
        {
            if(!m[s[r]])
                ++cnt;
            ++m[s[r]];
            if(cnt == bs.count())
            {
                while(cnt == bs.count() and l < r)
                {
                    --m[s[l]];
                    if(!m[s[l]])
                        --cnt;
                    ++l;
                }
                res = min(res, r - l + 2);
            }
            ++r;
        }
        if(cnt == bs.count())
        {
            while(cnt == bs.count() and l < r)
            {
                --m[s[l]];
                if(!m[s[l]])
                    --cnt;
                ++l;
            }
            res = min(res, r - l + 2);
        }
        cout << res << endl;
    }
    return 0;
}


================================================
FILE: Thực hành/ĐOẠN LIÊN TIẾP.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a)
            cin >> i;
        stack<int> st;
        int res[n];
        for(int i = 0; i < n; ++i)
        {
            if(st.sz and a[i] < a[st.top()])
            {
                res[i] = i - 1;
                st.push(i);
            }
            else
            {
                while(st.sz and a[i] >= a[st.top()])
                    st.pop();
                if(st.empty())
                    res[i] = -1;
                else
                    res[i] = st.top();
                st.push(i);
            }
        }
        cout << 1 << ' ';
        for(int i = 1; i < n; ++i)
            cout << i - res[i] << ' ';
        cout << endl;
    }
    return 0;
}




================================================
FILE: Thực hành/ĐÁNH SỐ THỨ TỰ CẶP DẤU NGOẶC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    string s;
    cin.ignore();
    while(t--)
    {
        getline(cin, s);
        int cnt = 1;
        stack<int> st;
        for(char &i : s)
        {
            if(i == '(')
            {
                st.push(cnt);
                cout << cnt << ' ';
                ++cnt;
            }
            else if(i == ')')
            {
                cout << st.top() << ' ';
                st.pop();
            }
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/ĐƯỜNG ĐI CÓ HƯỚNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[1005];
bitset<1005> visited;
int trace[1005] = {};

inline void BFS(int u)
{
    queue<int> q;
    q.push(u);
    visited[u] = 1;
    while(q.sz)
    {
        u = q.front();
        q.pop();
        for(int &i : a[u])
        {
            if(!visited[i])
            {
                visited[i] = 1;
                q.push(i);
                trace[i] = u;
            }
        }
    }
}

inline void findPath(int st, int en)
{
    if(!visited[en])
    {
        cout << -1 << endl;
        return;
    }
    stack<int> path;
    path.push(en);
    while(trace[en])
    {
        en = trace[en];
        path.push(en);
    }
    while(path.sz)
    {
        cout << path.top() << ' ';
        path.pop();
    }
    cout << endl;
}

int main()
{
    faster();
    int t = 1, v, e, x, y, st, en;
    cin >> t;
    while(t--)
    {
        cin >> v >> e >> st >> en;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        BFS(st);
        findPath(st, en);
        for(int i = 1; i <= v; ++i)
        {
            a[i].clear();
            visited[i] = 0;
        }
    }
    return 0;
}




================================================
FILE: Thực hành/ĐẢO TỬ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t;
    cin >> t;
    string s;
    cin.ignore();
    while(t--)
    {
        getline(cin, s);
        string tmp;
        stringstream ss(s);
        while(ss >> tmp)
        {
            reverse(all(tmp));
            cout << tmp << ' ';
        }
        cout << endl;
    }
    return 0;
}



================================================
FILE: Thực hành/ĐẾM SỐ VẬT CẢN TRÊN MÊ CUNG.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, m;
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, 1, -1};
vector<string> vs;

inline bool check(int x, int y)
{
    return (x >= 0 and y >= 0 and x < n and y < m and vs[x][y] == '#');
}

void DFS(int x, int y)
{
    if(check(x, y))
    {
        vs[x][y] = '.';
        for(int i = 0; i < 4; ++i)
            DFS(x + dx[i], y + dy[i]);
    }
}

int main()
{
    faster();
    cin >> n >> m;
    string s;
    while(cin >> s)
        vs.pb(s);
    int res = 0;
    for(int i = 0; i < n; ++i)
    {
        for(int j = 0; j < m; ++j)
        {
            if(vs[i][j] == '#')
            {
                ++res;
                DFS(i, j);
            }
        }
    }
    cout << res;
    return 0;
}



================================================
FILE: Thực hành/ĐỈNH THẮT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[105];
int u, v;

inline bool check(int x)
{
    bitset<105> visited;
    visited[x] = 1;
    queue<int> q;
    q.push(u);
    visited[u] = 1;
    while(q.sz)
    {
        x = q.front();
        q.pop();
        for(int &i : a[x])
        {
            if(!visited[i])
            {
                if(i == v)
                    return 1;
                q.push(i);
                visited[i] = 1;
            }
        }
    }
    return 0;
}

int main()
{
    faster();
    int t = 1, n, m, x, y;
    cin >> t;
    while(t--)
    {
        cin >> n >> m >> u >> v;
        while(m--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        int ans = 0;
        for(int i = 1; i <= n; ++i)
        {
            if(i == u or i == v)
                continue;
            ans += !check(i);
        }
        cout << ans << endl;
        for(int i = 1; i <= n; ++i)
            a[i].clear();
    }
    return 0;
}




================================================
FILE: Thực hành/ĐỈNH TRỤ VÀ CẠNH CẦU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[10005];
bitset<10005> visited;
int dis[10005] = {}, low[10005] = {}, par[10005] = {};
int cnt = 1, canhCau = 0;
set<int> dinhTru;

inline void DFS(int u)
{
    int child = 0;
    visited[u] = 1;
    dis[u] = low[u] = cnt++;
    for(int &i : a[u])
    {
        if(!visited[i])
        {
            ++child;
            par[i] = u;
            DFS(i);
            low[u] = min(low[u], low[i]);
            if(low[i] > dis[u])
                ++canhCau;
            if(low[i] >= dis[u] and par[u])
                dinhTru.insert(u);
        }
        else if(i != par[u])
            low[u] = min(low[u], dis[i]);
    }
    if(child > 1 and !par[u])
        dinhTru.insert(u);
}

int main()
{
    faster();
    int t = 1, v, e, x, y;
    //cin >> t;
    while(t--)
    {
        cin >> v >> e;
        while(e--)
        {
            cin >> x >> y;
            a[x].pb(y);
            a[y].pb(x);
        }
        for(int i = 1; i <= v; ++i)
            if(!visited[i])
                DFS(i);
        cout << dinhTru.sz << ' ' << canhCau;
    }
    return 0;
}




================================================
FILE: Tree/DSA11001 - CÂY BIỂU THỨC 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    char c;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(char c)
{
    binTree res = new Node;
    res -> c = c;
    res -> left = res -> right = NULL;
    return res;
}

inline void order(binTree a)
{
    if(a != NULL)
    {
        order(a -> left);
        cout << a -> c;
        order(a -> right);
    }
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> s;
        stack<binTree> st;
        for(char &i : s)
        {
            if(i == '+' or i == '-' or i == '*' or i == '/')
            {
                binTree tmp = createNode(i);
                tmp -> right = st.top();
                st.pop();
                tmp -> left = st.top();
                st.pop();
                st.push(tmp);
            }
            else st.push(createNode(i));
        }
        order(st.top());
        cout << endl;
    }
    return 0;
}


================================================
FILE: Tree/DSA11002 - CÂY BIỂU THỨC 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n;
string a[150];

struct Node
{
    string s;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(string s)
{
    binTree res = new Node;
    res -> s = s;
    res -> left = res -> right = NULL;
    return res;
}

inline binTree buildTree(binTree root, int i)
{
    if(i < n)
    {
        root = createNode(a[i]);
        root -> left = buildTree(root -> left , (i << 1) + 1);
        root -> right = buildTree(root -> right, (i << 1) + 2);
    }
    return root;
}

inline ll calc(binTree root)
{
    if(root -> s != "+" and root -> s != "-" and root -> s != "*" and root -> s != "/")
        return stoll(root -> s);
    if(root -> s == "+")
        return calc(root -> left) + calc(root -> right);
    else if(root -> s == "-")
        return calc(root -> left) - calc(root -> right);
    else if(root -> s == "*")
        return calc(root -> left) * calc(root -> right);
    else
        return calc(root -> left) / calc(root -> right);
}

int main()
{
    faster();
    int t = 1;
    cin >> t;
    string s;
    while(t--)
    {
        cin >> n;
        int i = 0;
        for(int i = 0; i < n; ++i)
            cin >> a[i];
        binTree A = NULL;
        A = buildTree(A, 0);
        cout << calc(A) << endl;
        delete A;
    }
    return 0;
}


================================================
FILE: Tree/DSA11003 - DUYỆT CÂY 1.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int pos = 0;

inline void print(int inorder[], int preorder[], int l, int r, unordered_map<int, int> &m)
{
    if(l <= r)
    {
        int idx = m[preorder[pos++]];
        print(inorder, preorder, l, idx - 1, m);
        print(inorder, preorder, idx + 1, r, m);
        cout << inorder[idx] << " ";
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int inorder[n], preorder[n];
        for(int &i : inorder)
            cin >> i;
        for(int &i : preorder)
            cin >> i;
        unordered_map<int, int> m;
        for (int i = 0; i < n; ++i)
            m[inorder[i]] = i;
        pos = 0;
        print(inorder, preorder, 0, n - 1, m);
        cout << endl;
    }
    return 0;
}


================================================
FILE: Tree/DSA11004 - DUYỆT CÂY THEO MỨC.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int x)
{
    binTree res = new Node;
    res -> val = x;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &A, char c, int par, int child)
{
    if(A != NULL)
    {
        if(A -> val == par)
        {
            if(c == 'L')
                A -> left = createNode(child);
            else
                A -> right = createNode(child);
        }
        buildTree(A -> left, c, par, child);
        buildTree(A -> right, c, par, child);
    }
}

inline void levelOrder(binTree root)
{
    queue<binTree> q;
    binTree top;
    q.push(root);
    while(q.sz)
    {
        top = q.front();
        q.pop();
        cout << top -> val << ' ';
        if(top -> left != NULL)
            q.push(top -> left);
        if(top -> right != NULL)
            q.push(top -> right);
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree root = NULL;
        int par, child;
        char c;
        cin >> par >> child >> c;
        root = createNode(par);
        buildTree(root, c, par, child);
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            buildTree(root, c, par, child);
        }
        levelOrder(root);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11005 - DUYỆT CÂY 2.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

binTree createNode(int x)
{
    binTree res = new Node;
    res -> val = x;
    res -> left = res -> right = NULL;
    return res;
}

binTree buildTree(int n, int *inorder, int *levelOrder, int st, int e)
{
    if(n > 0)
    {
        binTree root = createNode(levelOrder[0]);
        int idx = -1;
        unordered_map<int, int> m;
        for(int i = st; i <= e; ++i)
        {
            if(inorder[i] == levelOrder[0])
            {
                idx = i;
                break;
            }
            ++m[inorder[i]];
        }
        int L[m.sz], R[e - st - m.sz], l, r;
        l = r = 0;
        for(int i = 1; i < n; ++i)
        {
            if(m[levelOrder[i]])
                L[l++] = levelOrder[i];
            else
                R[r++] = levelOrder[i];
        }
        root -> left = buildTree(idx - st, inorder, L, st, idx - 1);
        root -> right = buildTree(e - idx, inorder, R, idx + 1, e);
        return root;
    }
    return NULL;
}

void postOrder(binTree root)
{
    if(root -> left != NULL)
        postOrder(root -> left);
    if(root -> right != NULL)
        postOrder(root -> right);
    cout << root -> val << ' ';
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int inorder[n], levelOrder[n];
        for(int &i : inorder)
            cin >> i;
        for(int &i : levelOrder)
            cin >> i;
        binTree root = buildTree(n, inorder, levelOrder, 0, n - 1);
        postOrder(root);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11006 - DUYỆT CÂY KIỂU XOẮN ỐC.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

binTree createNode(int x)
{
    binTree res = new Node;
    res -> val = x;
    res -> left = res -> right = NULL;
    return res;
}

void buildTree(binTree root, int par, int child, char x)
{
    if(root != NULL)
    {
        if(root -> val == par)
        {
            if(x == 'L')
                root -> left = createNode(child);
            else
                root -> right = createNode(child);
            return;
        }
        buildTree(root -> left, par, child, x);
        buildTree(root -> right, par, child, x);
    }
}

void spiralOrder(binTree root)
{
    stack<binTree> st1, st2;
    st1.push(root);
    binTree top;
    while(st1.sz or st2.sz)
    {
        while(st1.sz)
        {
            top = st1.top();
            st1.pop();
            cout << top -> val << ' ';
            if(top -> right != NULL)
                st2.push(top -> right);
            if(top -> left != NULL)
                st2.push(top -> left);
        }
        while(st2.sz)
        {
            top = st2.top();
            st2.pop();
            cout << top -> val << ' ';
            if(top -> left != NULL)
                st1.push(top -> left);
            if(top -> right != NULL)
                st1.push(top -> right);
        }
    }
}

int main()
{
    faster();
    int t, n;
    cin >> t;
    int child, par;
    char x;
    while(t--)
    {
        cin >> n;
        binTree root = NULL;
        cin >> par >> child >> x;
        root = createNode(par);
        buildTree(root, par, child, x);
        --n;
        while(n--)
        {
            cin >> par >> child >> x;
            buildTree(root, par, child, x);
        }
        spiralOrder(root);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11008 - KIỂM TRA NODE LÁ.cpp
================================================
// Created by Nguyễn Mạnh Quân
 
#include<bits/stdc++.h>
 
using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int x)
{
    binTree res = new Node;
    res -> val = x;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &A, char c, int par, int child)
{
    if(A != NULL)
    {
        if(A -> val == par)
        {
            if(c == 'L')
                A -> left = createNode(child);
            else
                A -> right = createNode(child);
        }
        buildTree(A -> left, c, par, child);
        buildTree(A -> right, c, par, child);
    }
}

inline int levelOrder(binTree root)
{
    int MAX = -1;
    queue<pair<binTree, int>> q;
    pair<binTree, int> top;
    q.push({root, 0});
    while(q.sz)
    {
        top = q.front();
        q.pop();
        if(top.fi -> left == NULL)
        {
            if(MAX == -1)
                MAX = top.se;
            else if(top.se != MAX)
                return 0;
        }
        else
            q.push({top.fi -> left, top.se + 1});
        if(top.fi -> right == NULL)
        {
            if(MAX == -1)
                MAX = top.se;
            else if(top.se != MAX)
                return 0;
        }
        else
            q.push({top.fi -> right, top.se + 1});
    }
    return 1;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree root = NULL;
        int par, child;
        char c;
        cin >> par >> child >> c;
        root = createNode(par);
        buildTree(root, c, par, child);
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            buildTree(root, c, par, child);
        }
        cout << levelOrder(root) << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11010 - CÂY NHỊ PHÂN HOÀN HẢO.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int x)
{
    binTree res = new Node;
    res -> val = x;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &root, int par, char c, int val)
{
    if(root == NULL)
        return;
    if(root -> val == par)
    {
        if(c == 'L')
            root -> left = createNode(val);
        else
            root -> right = createNode(val);
        return;
    }
    else
    {
        buildTree(root -> left, par, c, val);
        buildTree(root -> right, par, c, val);
    }
}

int Level[1005];
int a[35];

inline void order(binTree root, int lv = 0)
{
    if(root == NULL)
        return;
    ++Level[lv];
    order(root -> left, lv + 1);
    order(root -> right, lv + 1);
}

inline string check()
{
    for(int i = 0; i <= 30; ++i)
    {
        if(Level[i] == 0)
            return "Yes";
        if(Level[i] != a[i])
            return "No";
    }
    return "Yes";
}

int main()
{
    faster();
    int t, par, child, n;
    for(int i = 0; i <= 30; ++i)
        a[i] = 1 << i;
    char c;
    cin >> t;
    while(t--)
    {
        memset(Level, 0, sizeof(Level));
        cin >> n;
        binTree root;
        cin >> par >> child >> c;
        root = createNode(par);
        buildTree(root, par, c, child);
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            buildTree(root, par, c, child);
        }
        order(root);
        cout << check() << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11011 - CÂY NHỊ PHÂN ĐỦ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

bool check;

void order(binTree A)
{
    if(!check)
        return;
    if(A)
    {
        if((A -> left == NULL and A -> right) or (A -> left and A -> right == NULL))
        {
            check = 0;
            return;
        }
        if(A -> left)
            order(A -> left);
        if(A -> right)
            order(A -> right);
    }
}

int main()
{
    faster();
    int t = 1, n, par, child;
    char c;
    cin >> t;
    while(t--)
    {
        cin >> n;
        unordered_map<int, binTree> m;
        cin >> par >> child >> c;
        binTree T = createNode(par);
        m[par] = T;
        if(c == 'L')
        {
            m[par] -> left = createNode(child);
            m[child] = m[par] -> left;
        }
        else
        {
            m[par] -> right = createNode(child);
            m[child] = m[par] -> right;
        }
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            if(c == 'L')
            {
                m[par] -> left = createNode(child);
                m[child] = m[par] -> left;
            }
            else
            {
                m[par] -> right = createNode(child);
                m[child] = m[par] -> right;
            }
        }
        check = 1;
        order(T);
        cout << check << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11012 - CÂY NHỊ PHÂN BẰNG NHAU.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &root, int par, char c, int child)
{
    if(root == NULL)
        return;
    if(par == root -> val)
    {
        if(c == 'L')
            root -> left = createNode(child);
        else
            root -> right = createNode(child);
    }
    buildTree(root -> left, par, c, child);
    buildTree(root -> right, par, c, child);
}

bool check;

inline void order(binTree root1, binTree root2)
{
    if(!check or root1 == NULL or root2 == NULL)
        return;
    if(root1 -> val != root2 -> val)
    {
        check = 0;
        return;
    }
    if((root1 -> left == NULL and root2 -> left != NULL) or (root1 -> right == NULL and root2 -> right != NULL))
    {
        check = 0;
        return;
    }
    order(root1 -> left, root2 -> left);
    order(root1 -> right, root2 -> right);
}

int main()
{
    faster();
    int t, n, par, child, ori;
    char c;
    string s;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ori = n;
        binTree root1, root2;
        cin >> par >> child >> c;
        root1 = createNode(par);
        buildTree(root1, par, c, child);
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            buildTree(root1, par, c, child);
        }
        check = 1;
        cin >> n;
        if(n != ori)
        {
            cin.ignore();
            getline(cin, s);
            cout << 0 << endl;
            continue;
        }
        cin >> par >> child >> c;
        root2 = createNode(par);
        buildTree(root2, par, c, child);
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            buildTree(root2, par, c, child);
        }
        order(root1, root2);
        cout << check << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11014 - TỔNG NODE LÁ BÊN PHẢI.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

bool check;
ll sum;

bool isLeaf(binTree root)
{
    return root -> left == root -> right and root -> left == NULL;
}

inline void calc(binTree root)
{
    if(root == NULL)
        return;
    if(root -> right != NULL and isLeaf(root -> right))
        sum += root -> right -> val;
    if(root -> right != NULL and !isLeaf(root -> right))
        calc(root -> right);
    if(root -> left != NULL and !isLeaf(root -> left))
        calc(root -> left);
}

int main()
{
    faster();
    int t, n, par, child, ori;
    char c;
    cin >> t;
    while(t--)
    {
        cin >> n;
        ori = n;
        binTree root;
        unordered_map<int, binTree> m;
        cin >> par >> child >> c;
        root = createNode(par);
        if(c == 'L')
        {
            root -> left = createNode(child);
            m[child] = root -> left;
        }
        else
        {
            root -> right = createNode(child);
            m[child] = root -> right;
        }
        m[par] = root;
        --n;
        while(n--)
        {
            cin >> par >> child >> c;
            if(c == 'L')
            {
                m[par] -> left = createNode(child);
                m[child] = m[par] -> left;
            }
            else
            {
                m[par] -> right = createNode(child);
                m[child] = m[par] -> right;
            }
        }
        sum = 0;
        calc(root);
        cout << sum << endl;
        free(root);
    }
    return 0;
}


================================================
FILE: Tree/DSA11015 - TỔNG LỚN NHẤT.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int x)
{
    binTree res = new Node;
    res -> val = x;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &T, int par, int child, char c)
{
    if(T)
    {
        if(T -> val == par)
        {
            if(c == 'L')
                T -> left = createNode(child);
            else
                T -> right = createNode(child);
            return;
        }
        else
        {
            buildTree(T -> left, par, child, c);
            buildTree(T -> right, par, child, c);
        }
    }
}

int MAX;

inline int findMax(binTree T)
{
    if(T == NULL)
        return 0;
    int L = findMax(T -> left), R = findMax(T -> right);
    if(T -> left == NULL and T -> right == NULL)
        return T -> val;
    if(T -> left == NULL)
        return R + T -> val;
    if(T -> right == NULL)
        return L + T -> val;
    MAX = max(MAX, L + R + T -> val);
    return max(L, R) + T -> val;
}

int main()
{
    faster();
    int t = 1, n, par, child;
    char c;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree T = NULL;
        cin >> par >> child >> c;
        T = createNode(par);
        buildTree(T, par, child, c);
        while(--n)
        {
            cin >> par >> child >> c;
            buildTree(T, par, child, c);
        }
        MAX = -1e9;
        findMax(T);
        cout << MAX << endl;
    }
    return 0;
}


================================================
FILE: Tree/DSA11017 - DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

void buildTree(binTree &T, int val)
{
    if(T == NULL)
    {
        T = createNode(val);
        return;
    }
    if(T -> val > val)
        buildTree(T -> left, val);
    else
        buildTree(T -> right, val);
}

void order(binTree T)
{
    if(T -> left)
        order(T -> left);
    if(T -> right)
        order(T -> right);
    cout << T -> val << ' ';
}

int main()
{
    faster();
    int t = 1, n, val;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree T = NULL;
        while(n--)
        {
            cin >> val;
            buildTree(T, val);
        }
        order(T);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11018 - XÂY DỰNG LẠI CÂY NHỊ PHÂN TÌM KIẾM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &T, int val)
{
    if(T == NULL)
        T = createNode(val);
    else
    {
        if(T -> val > val)
            buildTree(T -> left, val);
        else
            buildTree(T -> right, val);
    }
}

inline void order(binTree T)
{
    if(T)
    {
        cout << T -> val << ' ';
        if(T -> left)
            order(T -> left);
        if(T -> right)
            order(T -> right);
    }
}

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree T = NULL;
        while(n--)
        {
            cin >> x;
            buildTree(T, x);
        }
        order(T);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11019 - DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &T, int val)
{
    if(T == NULL)
        T = createNode(val);
    else
    {
        if(T -> val > val)
            buildTree(T -> left, val);
        else
            buildTree(T -> right, val);
    }
}

inline void order(binTree T)
{
    if(T)
    {
        if(T -> left)
            order(T -> left);
        if(T -> right)
            order(T -> right);
        cout << T -> val << ' ';
    }
}

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree T = NULL;
        while(n--)
        {
            cin >> x;
            buildTree(T, x);
        }
        order(T);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11020 - KIỂM TRA CÂY NHỊ PHÂN TÌM KIẾM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int f[10005] = {};
        vector<int> v;
        int ori = n;
        while(n--)
        {
            cin >> x;
            if(!f[x])
                v.pb(x);
            f[x] = 1;
        }
        cout << (is_sorted(all(v)) and v.sz == ori) << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11021 - NODE LÁ CỦA CÂY NHỊ PHÂN TÌM KIẾM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &T, int val)
{
    if(T == NULL)
        T = createNode(val);
    else
    {
        if(T -> val > val)
            buildTree(T -> left, val);
        else
            buildTree(T -> right, val);
    }
}

set<int> leaf;

inline void order(binTree T)
{
    if(T)
    {
        if(T -> left == NULL and T -> right == NULL)
            leaf.insert(T -> val);
        else
        {
            if(T -> left)
                order(T -> left);
            if(T -> right)
                order(T -> right);
        }
    }
}

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree T = NULL;
        while(n--)
        {
            cin >> x;
            buildTree(T, x);
        }
        order(T);
        for(int i : leaf)
            cout << i << ' ';
        cout << endl;
        leaf.clear();
    }
    return 0;
}



================================================
FILE: Tree/DSA11022 - NODE TRUNG GIAN CỦA CÂY NHỊ PHÂN TÌM KIẾM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &T, int val)
{
    if(T == NULL)
        T = createNode(val);
    else
    {
        if(T -> val > val)
            buildTree(T -> left, val);
        else
            buildTree(T -> right, val);
    }
}

int cnt = 0;

inline void order(binTree T)
{
    if(T)
    {
        if(T -> left == NULL and T -> right == NULL)
            return;
        else
        {
            ++cnt;
            if(T -> left)
                order(T -> left);
            if(T -> right)
                order(T -> right);
        }
    }
}

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree T = NULL;
        while(n--)
        {
            cin >> x;
            buildTree(T, x);
        }
        cnt = 0;
        order(T);
        cout << cnt;
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11023 - ĐỘ SÂU CÂY NHỊ PHÂN TÌM KIẾM.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline void buildTree(binTree &T, int val)
{
    if(T == NULL)
        T = createNode(val);
    else
    {
        if(T -> val > val)
            buildTree(T -> left, val);
        else
            buildTree(T -> right, val);
    }
}

int MAX = -1;

inline void order(binTree T, int lv = 0)
{
    if(T)
    {
        if(T -> left == NULL and T -> right == NULL)
            MAX = max(MAX, lv);
        else
        {
            if(T -> left)
                order(T -> left, lv + 1);
            if(T -> right)
                order(T -> right, lv + 1);
        }
    }
}

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        binTree T = NULL;
        while(n--)
        {
            cin >> x;
            buildTree(T, x);
        }
        MAX = -1;
        order(T);
        cout << MAX;
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11024 - CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 1.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int main()
{
    faster();
    int t = 1, n, x;
    cin >> t;
    while(t--)
    {
        cin >> n;
        int a[n];
        for(int &i : a)
            cin >> i;
        sort(a, a + n);
        cout << a[(n - 1) >> 1] << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11025 - CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 2.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[1000005];

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline binTree buildTree(int l, int r)
{
    if(l > r)
        return NULL;
    int mid = (l + r) >> 1;
    binTree res = createNode(a[mid]);
    res -> left = buildTree(l, mid - 1);
    res -> right = buildTree(mid + 1, r);
    return res;
}

inline void order(binTree T)
{
    if(T)
    {
        cout << T -> val << ' ';
        if(T -> left)
            order(T -> left);
        if(T -> right)
            order(T -> right);
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i)
            cin >> a[i];
        sort(a, a + n);
        binTree T = buildTree(0, n - 1);
        order(T);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11026 - DUYỆT SAU CÂY TÌM KIẾM CÂN BẰNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[1000005];

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline binTree buildTree(int l, int r)
{
    if(l > r)
        return NULL;
    int mid = (l + r) >> 1;
    binTree res = createNode(a[mid]);
    res -> left = buildTree(l, mid - 1);
    res -> right = buildTree(mid + 1, r);
    return res;
}

inline void order(binTree T)
{
    if(T)
    {
        if(T -> left)
            order(T -> left);
        if(T -> right)
            order(T -> right);
        cout << T -> val << ' ';
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i)
            cin >> a[i];
        sort(a, a + n);
        binTree T = buildTree(0, n - 1);
        order(T);
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11027 - ĐẾM SỐ NODE LÁ CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int a[1005];

struct Node
{
    int val;
    Node *left, *right;
};

typedef Node* binTree;

inline binTree createNode(int val)
{
    binTree res = new Node;
    res -> val = val;
    res -> left = res -> right = NULL;
    return res;
}

inline binTree buildTree(int l, int r)
{
    if(l > r)
        return NULL;
    int mid = (l + r) >> 1;
    binTree res = createNode(a[mid]);
    res -> left = buildTree(l, mid - 1);
    res -> right = buildTree(mid + 1, r);
    return res;
}

int cnt;

inline void order(binTree T)
{
    if(T)
    {
        if(T -> left or T -> right)
        {
            if(T -> left)
                order(T -> left);
            if(T -> right)
                order(T -> right);
        }
        else
            ++cnt;
    }
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        for(int i = 0; i < n; ++i)
            cin >> a[i];
        sort(a, a + n);
        binTree T = buildTree(0, n - 1);
        cnt = 0;
        order(T);
        cout << cnt;
        cout << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11028 - ĐỘ CAO CỦA CÂY.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL);cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

inline int BFS(vector<int> a[])
{
    bitset<100005> bs;
    int res = -1;
    queue<int> q;
    int f[100005] = {};
    int top;
    q.push(1);
    bs[1] = 1;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        for(int &i : a[top])
        {
            if(!bs[i])
            {
                f[i] = f[top] + 1;
                res = max(res, f[i]);
                q.push(i);
            }
        }
    }
    return res;
}

int main()
{
    faster();
    int t, n, x, y;
    cin >> t;
    while(t--)
    {
        cin >> n;
        --n;
        vector<int> a[n + 5];
        while(n--)
        {
            cin >> x >> y;
            a[x].pb(y);
        }
        cout << BFS(a) << endl;
    }
    return 0;
}



================================================
FILE: Tree/DSA11029 - ĐƯỜNG ĐI TỚI NODE LÁ.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

void BFS(vector<int> a[], int trace[])
{
    queue<int> q;
    bitset<1005> visited;
    visited[1] = 1;
    q.push(1);
    int top;
    while(q.sz)
    {
        top = q.front();
        q.pop();
        for(int &i : a[top])
        {
            if(!visited[i])
            {
                visited[i] = 1;
                trace[i] = top;
                q.push(i);
            }
        }
    }
}

void findPath(int trace[], int E)
{
    stack<int> path;
    path.push(E);
    while(trace[E])
    {
        E = trace[E];
        path.push(E);
    }
    while(path.sz)
    {
        cout << path.top() << ' ';
        path.pop();
    }
    cout << endl;
}

int main()
{
    faster();
    int t = 1, n;
    cin >> t;
    while(t--)
    {
        cin >> n;
        vector<int> a[n + 5];
        int x, y;
        bitset<1005> f;
        for(int i = 1; i < n; ++i)
        {
            cin >> x >> y;
            a[x].pb(y);
            f[x] = 1;
        }
        int trace[1005] = {};
        BFS(a, trace);
        for(int i = 2; i <= n; ++i)
            if(!f[i])
                findPath(trace, i);
    }
    return 0;
}



================================================
FILE: Tree/DSA11030 - KHOẢNG CÁCH GIỮA HAI NODE.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

vector<int> a[1005];
bitset<1005> visited;
int res;
bool check;

inline void DFS(int u, int v, int cnt = 0)
{
    if(check)
        return;
    visited[u] = 1;
    if(u == v)
    {
        check = 1;
        res = cnt;
        return;
    }
    for(int &i : a[u])
        if(!visited[i])
            DFS(i, v, cnt + 1);
}

int main()
{
    faster();
    int t = 1, n, q, u, v;
    cin >> t;
    while(t--)
    {
        cin >> n;
        while(--n)
        {
            cin >> u >> v;
            a[u].pb(v);
            a[v].pb(u);
        }
        cin >> q;
        while(q--)
        {
            cin >> u >> v;
            res = 0;
            check = 0;
            DFS(u, v);
            cout << res << endl;
            visited.reset();
        }
        for(int i = 0; i <= 1e3; ++i)
            a[i].clear();
    }
    return 0;
}



================================================
FILE: Tree/DSAKT060 - TRUY VẤN ĐỐI XỨNG.cpp
================================================
// Created by Nguyễn Mạnh Quân

#include<bits/stdc++.h>

using namespace std;

#define mp make_pair
#define fi first
#define se second
#define pb push_back
#define sz size()
#define ll long long
#define FOR(i, a, b) for(int i = a; i <= b; i++)
#define FORD(i, a, b) for(int i = a; i >= b; i--)
#define F(i, a, b) for(int i = a; i < b; ++i)
#define FD(i, a, b) for(int i = a; i > b; --i)
#define faster() ios_base::sync_with_stdio(0); cin.tie(NULL); cout.tie(NULL);
#define vi vector<int>
#define vll vector<ll>
#define all(x) (x).begin(), (x).end()
#define endl '\n'

int n, q;
string s;
const int N = 1e5 + 5, Prime = 17;
ll Pow[N], Fenwick1[N], Fenwick2[N];

inline void Update(int idx, int x)
{
    ll val = Pow[idx] * x;
    for(int i = idx; i <= n; i += (i & -i))
        Fenwick1[i] += val;
    val = Pow[n - idx + 1] * x;
    while(idx)
    {
        Fenwick2[idx] += val;
        idx -= (idx & -idx);
    }
}

inline ll Get1(int idx)
{
    ll res = 0;
    while(idx)
    {
        res += Fenwick1[idx];
        idx -= (idx & -idx);
    }
    return res;
}

inline ll Get2(int idx)
{
    ll res = 0;
    while(idx <= n)
    {
        res += Fenwick2[idx];
        idx += (idx & -idx);
    }
    return res;
}
int main()
{
    faster();
    int t = 1;
    //cin >> t;
    while(t--)
    {
        cin >> s >> q;
        n = s.sz;
        s = "*" + s;
        Pow[0] = 1;
        for(int i = 1; i <= n; ++i)
            Pow[i] = Pow[i - 1] * Prime;
        for(int i = 1; i <= n; ++i)
            Update(i, s[i]);
        int l, r;
        char c, x;
        while(q--)
        {
            cin >> c;
            if(c == 'c')
            {
                cin >> l >> x;
                Update(l, x - s[l]);
                s[l] = x;
            }
            else
            {
                cin >> l >> r;
                if(((Get1(r) - Get1(l - 1)) * Pow[n - r + 1] == (Get2(l) - Get2(r + 1)) * Pow[l]))
                    cout << "YES\n";
                else
                    cout << "NO\n";
            }
        }
    }
    return 0;
}


================================================
FILE: Đề bài/README.md
================================================
# Đề cấu trúc dữ liệu và giải thuật

## Generation

### CTDL_001 - THUẬT TOÁN SINH

Một xâu nhị phân độ dài n được gọi là thuận nghịch hay đối xứng nếu đảo ngược xâu nhị phân đó ta vẫn nhận được chính nó. Cho số tự nhiên n (n nhập từ bàn phím). Hãy viết chương trình liệt kê tất cả các xâu nhị phân thuận nghịch có độ dài n. Hai phần tử khác nhau của xâu thuận nghịch được ghi cách nhau một khoảng trống.

Ví dụ với n = 4 ta tìm được 4 xâu nhị phân thuận nghịch như dưới đây.
```
0 0 0 0 
0 1 1 0   
1 0 0 1   
1 1 1 1
```

**input**
```
4
```

**output**
```
0 0 0 0
0 1 1 0
1 0 0 1
1 1 1 1
```

### CTDL_002 - Tổng dãy con = K

Cho dãy A[] gồm N số tự nhiên khác nhau và số tự nhiên K. Hãy viết chương trình liệt kê tất cả các dãy con của dãy số A[] sao cho tổng các phần tử trong dãy con đó đúng bằng K. Dữ liệu vào trên bàn phím (n=5, K=50), 5 số dòng thứ 2 là các phần tử dãy A:
```
5 50   
5 10 15 20 25
```
Các dãy con thoả mãn điều kiện tìm được liệt kê trên màn hình:
- Mỗi dòng ghi lại một dãy con. Hai phần tử khác nhau của dãy con được viết cách nhau bởi một khoảng trống.
- Dòng cuối cùng ghi lại số các dãy con có tổng các phần tử đúng bằng K tìm được.
```
10 15 25
5 20 25
5 10 15 20
3
```

### CTDL_003 - PHƯƠNG ÁN TỐI ƯU

Cho a<sub>i</sub>, c<sub>i</sub>, W, N (i =1, 2,..,N; N£100) là những số nguyên dương và tập hợp

![download](https://user-images.githubusercontent.com/64203006/163585339-596099cc-2785-4081-a14b-02fade62c9a4.png)

Hãy viết chương trình tìm phương án tối ưu XOPT =(x<sub>1</sub>,x<sub>2</sub>,..,x<sub>N</sub>) và giá trị tối ưu FOPT=F(XOPT) của hàm mục tiêu

![download](https://user-images.githubusercontent.com/64203006/163585512-e3d93877-5c6f-4a50-bb73-6b6c5d718902.png)

Dữ liệu vào cho bởi file data.in theo khuôn dạng sau:

- Dòng đầu tiên ghi lại số tự nhiên N và W. Hai số được viết cách nhau một vài khoảng trống;
- Dòng kế tiếp ghi lại N số cj (j=1,2,..,N). Hai số được viết cách nhau một vài khoảng trống;
- Dòng kế tiếp ghi lại N số aj (j=1,2,..,N). Hai số được viết cách nhau một vài khoảng trống;

Giá trị tối ưu FOPT và phương án XOPT tìm được sẽ liệt kê trên màn hình theo khuôn dạng:

- Dòng đầu tiên ghi lại giá trị tối ưu FOPT;
- Dòng kế tiếp ghi lại phương án tối ưu XOPT. Hai phần tử khác nhau của phương án tối ưu được viết cách nhau bởi một khoảng trống.

**input**
```
4 10                
6 5 3 7  
5 4 6 5
```

**output**
```
13
1 0 0 1
```

### CTDL_004 - DÃY CON TĂNG DẦN BẬC K

Cho dãy gồm N số phân biệt AN = {a1, a2, .., aN } và số tự nhiên K (K<=N<=100). Ta gọi một dãy con tăng dần bậc K của dãy số AN là một dãy các số gồm K phần tử trong dãy đó thỏa mãn tính chất tăng dần. Bài toán được đặt ra là in ra màn hình số các dãy con tăng dần bậc K của dãy số AN. Ví dụ :

**Input:**
- Dòng đầu tiên ghi lại hai số N và K tương ứng với số phần tử của dãy số và bậc của dãy con.
- Dòng kế tiếp : N số của dãy số AN, các số trong dãy không lớn hơn 100. 

**Output:**
- In ra ra kết quả tìm được.

**input**
```
5 3
2 5 15 10 20 
```

**output**
```
7
```

### DSA01001 - XÂU NHỊ PHÂN KẾ TIẾP

Cho xâu nhị phân X[], nhiệm vụ của bạn là hãy đưa ra xâu nhị phân tiếp theo của X[]. Ví dụ X[] =”010101” thì xâu nhị phân tiếp theo của X[] là “010110”.

Input:
- Dòng đầu tiên đưa vào số lượng test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu nhi phân X.
- T, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤length(X)≤10<sup>3</sup>.

Output:
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
010101
111111
```

**output**
```
010110
000000
```

### DSA01002 - TẬP CON KẾ TIẾP

Cho hai số N, K và một tập con K phần tử X[] =(X1, X2,.., XK) của 1, 2, .., N. Nhiệm vụ của bạn là hãy đưa ra tập con K phần tử tiếp theo của X[]. Ví dụ N=5, K=3, X[] ={2, 3, 4} thì tập con tiếp theo của X[] là {2, 3, 5}.

Input:

* Dòng đầu tiên đưa vào số lượng test T.
* Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu nhi phân X.
* T, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤length(X)≤10<sup>3</sup>.

Output:

* Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5 3
1 4 5
5 3
3 4 5
```

**output**
```
2 3 4
1 2 3
```

### DSA01003 - HOÁN VỊ KẾ TIẾP

Cho số tự nhiên N và một hoán vị X\[\] của 1, 2, .., N. Nhiệm vụ của bạn là đưa ra hoán vị tiếp theo của X\[\]. Ví dụ N=5, X\[\] = {1, 2, 3, 4, 5} thì hoán vị tiếp theo của X\[\] là {1, 2, 3, 5, 4}.

Input:

* Dòng đầu tiên đưa vào số lượng test T.
* Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là số N; dòng tiếp theo đưa vào hoán vị X\[\] của 1, 2, .., N.
* T, N, X\[\] thỏa mãn ràng buộc: 1≤T≤100; 1≤ N≤10<sup>3</sup>.

Output:

* Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5 
1 2 3 4 5
5
5 4 3 2 1
```

**output**
```
1 2 3 5 4
1 2 3 4 5
```

### DSA01004 - SINH TỔ HỢP

Cho hai số nguyên dương N và K. Nhiệm vụ của bạn là hãy liệt kê tất cả các tập con K phần tử của 1, 2, .., N. Ví dụ với N=5, K=3 ta có 10 tập con của 1, 2, 3, 4, 5 như sau: {1, 2, 3}, {1, 2, 4},{1, 2, 5},{1, 3, 4},{1, 3, 5},{1, 4, 5},{2, 3, 4},{2, 3, 5},{2, 4, 5},{3, 4, 5}.

Input:

* Dòng đầu tiên đưa vào số lượng test T.
* Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một cặp số tự nhiên N, K được viết trên một dòng.
* T, n thỏa mãn ràng buộc: 1≤T≤100; 1≤k ≤ n≤15.

Output:

* Đưa ra kết quả mỗi test theo từng dòng.


**input**
```
2
4 3
5 3
```

**output**
```
123 124 134 234
123 124 125 134 135 145 234 235 245 345
```

### DSA01005 - SINH HOÁN VỊ

Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các hoán vị của 1, 2, .., N. Ví dụ với N = 3 ta có kết quả: 123, 132, 213, 231, 312, 321.

Input:

* Dòng đầu tiên đưa vào số lượng test T.
* Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
* T, n thỏa mãn ràng buộc: 1≤T, N≤10.

Output:

* Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
2
3
```

**output**
```
12 21
123 132 213 231 312 321
```

### DSA01006 - HOÁN VỊ NGƯỢC

Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các hoán vị của 1, 2, .., N theo thứ tự ngược. Ví dụ với N = 3 ta có kết quả: 321, 312, 231, 213, 132, 123.

Input:

* Dòng đầu tiên đưa vào số lượng test T.
* Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
* T, n thỏa mãn ràng buộc: 1≤T, N≤10.

Output:

* Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
2
3
```

**output**
```
21 12 
321 312 231 213 132 123
```

### DSA01007 - XÂU AB CÓ ĐỘ DÀI N

Xâu ký tự str được gọi là xâu AB nếu mỗi ký tự trong xâu hoặc là ký tự ‘A’ hoặc là ký tự ‘B’. Ví dụ xâu str=”ABBABB” là xâu AB độ dài 6. Nhiệm vụ của bạn là hãy liệt kê tất cả các xâu AB có độ dài n.

Input:

* Dòng đầu tiên đưa vào số lượng test T.
* Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên n.
* T, n thỏa mãn ràng buộc: 1≤T≤10; 1≤n≤10.

Output:

* Đưa ra kết quả mỗi test theo từng dòng. Mỗi xâu cách nhau 1 khoảng trống.

**input**
```
2
2
3
```

**output**
```
AA AB BA BB
AAA AAB ABA ABB BAA BAB BBA BBB
```

### DSA01008 - XÂU NHỊ PHÂN CÓ K BIT 1

Hãy in ra tất cả các xâu nhị phân độ dài N, có K bit 1 theo thứ tự từ điển tăng dần.

Input: Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test gồm 2 số nguyên N, K (1 ≤ K ≤ N ≤ 16).

Output:  Với mỗi test, in ra đáp án tìm được, mỗi xâu in ra trên một dòng.

**input**
```
2
4 2
3 2
```

**output**
```
0011
0101
0110
1001
1010
1100
011
101
110
```

### DSA01009 - XÂU AB ĐẶC BIỆT

Một xâu kí tự S = (s1, s2, .., sn) được gọi là xâu AB độ dài n nếu với mọi si∈S thì si hoặc là kí tự A hoặc si là kí tự B . Ví dụ xâu S = “ABABABAB” là một xâu AB độ dài 8. Cho số tự nhiên N và số tự nhiên K (1£K<N£15 được nhập từ bàn phím), hãy viết chương trình liệt kê tất cả các xâu AB có độ dài N chứa duy nhất một dãy K kí tự A liên tiếp.

**Input:** 
chỉ có một dòng ghi hai số N và K.

**Output:**
- Dòng đầu tiên ghi lại số các xâu AB thỏa mãn yêu cầu bài toán;
- Những dòng kế tiếp, mỗi dòng ghi lại một xâu AB thỏa mãn. Các xâu được ghi ra theo thứ tự từ điển.

**input**
```
5 3
```

**output**
```
5
AAABA
AAABB
ABAAA
BAAAB
BBAAA
```

### DSA01011 - HOÁN VỊ TIẾP THEO CỦA CHUỖI SỐ

Hãy viết chương trình nhận vào một chuỗi (có thể khá dài) các ký tự số và đưa ra màn hình hoán vị kế tiếp của các ký tự số đó (với ý nghĩa là hoán vị có giá trị lớn hơn tiếp theo nếu ta coi chuỗi đó là một giá trị số nguyên). Chú ý: Các ký tự số trong dãy có thể trùng nhau.

Ví dụ:           

123 -> 132

279134399742 -> 279134423799  

Cũng có trường hợp sẽ không thể có hoán vị kế tiếp. Ví dụ như khi đầu vào là chuỗi 987.  

**Input:** 
Dòng đầu tiên ghi số nguyên  t là số bộ test (1 ≤ t ≤ 1000).  Mỗi bộ test có một dòng, đầu tiên là số thứ tự bộ test, một dấu cách, sau đó là chuỗi các ký tự số, tối đa 80 phần tử.  

**Output:**
Với mỗi bộ test hãy đưa ra một dòng gồm thứ tự bộ test, một dấu cách, tiếp theo đó là hoán vị kế tiếp hoặc chuỗi “BIGGEST” nếu không có hoán vị kế tiếp. 

**input**
```
3
1 123
2 279134399742
3 987
```

**output**
```
1 132
2 279134423799
3 BIGGEST
```

### DSA01012 - MÃ GRAY 1

Số nhị phân được xem là cách mặc định biểu diễn các số. Tuy nhiên, trong nhiều ứng dụng của điện tử và truyền thông lại dùng một biến thể của mã nhị phân đó là mã Gray. Mã Gray độ dài n có mã đầu tiên là n số 0, mã kế tiếp của nó là một xâu nhị phân độ dài n khác biệt với xâu trước đó một bít. Ví dụ với n=3 ta có 2<sup>3</sup> mã Gray như sau: 000, 001, 011, 010, 110, 111, 101, 100. Hãy viết chương trình liệt kê các mã Gray có độ dài n.

**Input:** 
- Dòng đầu tiên là số lượng test T.
- T dòng kế tiếp ghi lại mỗi dòng một test. Mỗi test là một số tự nhiên n.
- T, n thỏa mãn ràng buộc: 1≤T, n≤10.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
3
4
```

**output**
```
000 001 011 010 110 111 101 100
0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000
```

### DSA01013 - MÃ GRAY 2

Số nhị phân được xem là cách mặc định biểu diễn các số. Tuy nhiên, trong nhiều ứng dụng của điện tử và truyền thông lại dùng một biến thể của mã nhị phân đó là mã Gray. Mã Gray độ dài n có mã đầu tiên là n số 0, mã kế tiếp của nó là một xâu nhị phân độ dài n khác biệt với xâu trước đó một bít. Ví dụ với n=3 ta có 2<sup>3</sup> mã Gray như sau: 000, 001, 011, 010, 110, 111, 101, 100. Hãy viết chương trình chuyển đổi một xâu mã Gray X có độ dài n thành một xâu mã nhị phân.


**Input:** 
- Dòng đầu tiên là số lượng test T.
- T dòng kế tiếp ghi lại mỗi dòng một test. Mỗi test là một số tự nhiên n.
- T, n thỏa mãn ràng buộc: 1≤T, n≤10.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
01101
01011
```

**output**
```
01001
01101
```

### DSA01014 - TẬP HỢP

Xét tất cả các tập hợp các số nguyên dương có các phần tử khác nhau và không lớn hơn số n cho trước. Nhiệm vụ của bạn là hãy đếm xem có tất cả bao nhiêu tập hợp có số lượng phần tử bằng k và tổng của tất cả các phần tử trong tập hợp bằng s?

Các tập hợp là hoán vị của nhau chỉ được tính là một.

Ví dụ với n = 9, k = 3, s = 23, {6, 8, 9} là tập hợp duy nhất thỏa mãn.

**Input:** 
- Gồm nhiều bộ test (không quá 100 test).
- Mỗi bộ test gồm 3 số nguyên n, k, s với 1 ≤ n ≤ 20, 1 ≤ k ≤ 10 và 1 ≤ s ≤ 155. Input kết thúc bởi 3 số 0.

**Output:**
- Với mỗi test in ra số lượng các tập hợp thỏa mãn điều kiện đề bài.

**input**
```
9 3 23
9 3 22
10 3 28
16 10 107
20 8 102
20 10 105
20 10 155
3 4 3
4 2 11
0 0 0
```

**output**
```
1
2
0
20
1542
5448
1
0
0
```

### DSA01015 - TÌM BỘI SỐ

Cho số nguyên N. Nhiệm vụ của bạn cần tìm số nguyên X nhỏ nhất là bội của N, và X chỉ chứa hai chữ số 0 và 9.

**Input:** 
Dòng đầu tiên là số lượng bộ test T (T ≤ 10000). Mỗi bộ test chứa số nguyên N trên một dòng (1 ≤ N ≤ 500).

**Output:**
Với mỗi test in ra đáp án tìm được trên một dòng.

**input**
```
3
2
5
11
```

**output**
```
90
90
99
```

### DSA01016 - PHÂN TÍCH SỐ 1

Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các cách phân tích số tự nhiên N thành tổng các số tự nhiên nhỏ hơn hoặc bằng N. Phép hoán vị vủa một cách được xem là giống nhau. Ví dụ với N = 5 ta có kết quả là: (5), (4, 1), (3, 2), (3, 1, 1), (2, 2, 1), (2, 1, 1, 1), (1, 1, 1, 1, 1) .

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
- T, n thỏa mãn ràng buộc: 1≤T, N≤10.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4
5
```

**output**
```
(4) (3 1) (2 2) (2 1 1) (1 1 1 1)
(5) (4 1) (3 2) (3 1 1) (2 2 1) (2 1 1 1) (1 1 1 1 1)
```

### DSA01017 - MÃ GRAY 3

Số nhị phân được xem là cách mặc định biểu diễn các số. Tuy nhiên, trong nhiều ứng dụng của điện tử và truyền thông lại dùng một biến thể của mã nhị phân đó là mã Gray. Mã Gray độ dài n có mã đầu tiên là n số 0, mã kế tiếp của nó là một xâu nhị phân độ dài n khác biệt với xâu trước đó một bít. Ví dụ với n=3 ta có 2<sup>3</sup> mã Gray như sau: 000, 001, 011, 010, 110, 111, 101, 100. Hãy viết chương trình chuyển đổi một xâu mã nhị phân X có độ dài n thành một xâu mã Gray.

**Input:** 
- Dòng đầu tiên là số lượng test T.
- T dòng kế tiếp ghi lại mỗi dòng một test. Mỗi test là một số tự nhiên n.
- T, n thỏa mãn ràng buộc: 1≤T, n≤10.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
01001
01101
```

**output**
```
01101
01011
```

### DSA01018 - TẬP CON LIỀN KỀ PHÍA TRƯỚC

Cho hai số N, K và một tập con K phần tử X[] =(X1, X2,.., XK) của 1, 2, .., N. Nhiệm vụ của bạn là hãy đưa ra tập con K phần tử trước đó của X[]. Ví dụ N=5, K=3, X[] ={2, 3, 5} thì tập con trước đó của X[] là {2, 3, 4}. Chú ý nếu tập con trong input là đầu tiên thì trước đó là tập con cuối cùng.

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là hai số N và K; dòng tiếp theo đưa vào K phần tử của X[] là một tập con K phần tử của 1, 2, .., N.
- T, K, N, X[] thỏa mãn ràng buộc: 1≤T≤100; 1≤K≤N≤10<sup>3</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5  3
2  3  5
5  3
1  2  3
```

**output**
```
2 3 4
3 4 5
```

### DSA01019 - HAHAHA

Khi chat chit vui vẻ, anh em chiến hữu thường hay gõ HAHA để thể hiện sự sảng khoái. Đôi khi cũng có thể gõ HAHAAAAA chẳng hạn cho thêm phần nhấn mạnh.

Giả sử một xâu ký tự được coi là HAHA nếu thỏa mãn các điều kiện:

*   Ký tự đầu tiên phải là chữ H, ký tự cuối cùng phải là chữ A
*   Không có hai chữ H nào liền nhau

Cho trước độ dài N, hãy liệt kê tất cả các xâu ký tự HAHA theo thứ tự từ điển.

**Input**

*   Dòng đầu ghi số bộ test T (không quá 10)
*   Mỗi bộ test ghi độ dài N (2 <= N < 16)

**Output**

*   Với mỗi bộ test, ghi ra tất cả các xâu HAHA tìm được theo thứ tự từ điển, mỗi xâu viết trên một dòng.

**Ví dụ**

**input**
```
2
2
4
```

**output**
```
HA
HAAA
HAHA
```

### DSA01020 - XÂU NHỊ PHÂN TRƯỚC

Cho xâu nhị phân X\[\], nhiệm vụ của bạn là hãy đưa ra xâu nhị phân trước của X\[\]. Ví dụ X\[\] =”111111” thì xâu nhị phân trước của X\[\] là “111110”. Với xâu X\[\] =“000001” thì xâu nhị trước của X\[\] là “000000”. Chú ý: nếu xâu dữ liệu trong input là xâu đầu tiên thì trước nó sẽ là xâu cuối cùng.

**Input:**

*   Dòng đầu tiên đưa vào số lượng test T.
*   Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu nhi phân X.
*   T, X\[\] thỏa mãn ràng buộc: 1≤T≤100; 1≤length(X)≤10<sup>3</sup>.

**Output:**

*   Đưa ra kết quả mỗi test theo từng dòng.

**Ví dụ:**

**input**
```
2
010101
111111
```

**output**
```
010100
111110
```

### DSA01021 - TỔ HỢP TIẾP THEO - DSA01010 - TẬP QUÂN SỰ

Cho số nguyên dương (1<N<40) và số nguyên dương K<N. Với 1 tổ hợp chập K phần tử của N, hãy cho biết tổ hợp tiếp theo sẽ có bao nhiêu phần tử mới. Nếu tổ hợp đã cho là cuối cùng thì kết quả là K.  

**Dữ liệu vào:** Dòng đầu ghi số bộ test, không quá 20. Mỗi bộ test viết trên hai dòng

*   Dòng 1: hai số nguyên dương N và K (K<N)
*   Dòng 2 ghi K số của tổ hợp ban đầu. Theo đúng thứ tự tăng dần, không có số nào trùng nhau.

**Kết quả:** Với mỗi bộ dữ liệu in ra số lượng phần tử mới.

 **Ví dụ:**

**input**
```
3
5 3
1 3 5
5 3
1 4 5
6 4
3 4 5 6
```

**output**
```
1
2
4
```

### DSA01022 - SỐ THỨ TỰ HOÁN VỊ

Cho một hoán vị của N số nguyên dương đầu tiên.

Hãy xác định xem đó là hoán vị thứ bao nhiêu nếu liệt kê theo thứ tự tăng dần (tính từ 1).

**Input**

Dòng đầu ghi số T là số bộ test (T < 10)

Mỗi bộ test gồm 2 dòng

*   Dòng đầu ghi số nguyên dương N (3 < N < 10)
*   Dòng tiếp theo ghi một hoán vị của các số nguyên dương từ 1 đến N.  

**Output**

Với mỗi bộ test, ghi ra trên một dòng số thứ tự của hoán vị (tính từ 1, theo thứ tự liệt kê tăng dần).

**Ví dụ**

**input**
```
2
4
1 4 3 2
4
1 2 3 4
```

**output**
```
6
1
```

### DSA01023 - SỐ THỨ TỰ TỔ HỢP

Cho một tổ hợp chập K của N số nguyên dương đầu tiên (2 < K < N < 15).

Hãy xác định xem đó là tổ hợp thứ bao nhiêu nếu liệt kê tất cả các tổ hợp theo thứ tự tăng dần (tính từ 1).

**Input**

Dòng đầu ghi số T là số bộ test (T < 10)

Mỗi bộ test gồm 2 dòng

*   Dòng đầu ghi 2 số nguyên dương N và K (2 < K < N < 15)
*   Dòng tiếp theo ghi một tổ hợp chập K của các số nguyên dương từ 1 đến N.  

**Output**

Với mỗi bộ test, ghi ra trên một dòng số thứ tự của tổ hợp (tính từ 1, theo thứ tự liệt kê tăng dần).

**Ví dụ**

**input**
```
2
6 4
1 3 5 6
6 4
2 3 4 6
```

**output**
```
9
12
```

### DSA01025 - ĐẶT TÊN - 2

Vương quốc PTIT sử dụng bảng chữ cái gồm N chữ cái Latinh viết hoa. Quy tắc đặt tên của gia đình Hoàng gia  PTIT là chọn ra K chữ cái (không trùng nhau) và sắp xếp lại theo thứ tự từ điển.

Hãy liệt kê tất cả các cái tên có thể có của gia đình Hoàng gia PTIT

**Input**

*   Dòng đầu ghi số bộ test T (không quá 10)
*   Mỗi bộ test ghi 2 số N và K (3 < K < N < 16)

**Output**

*   Với mỗi bộ test, ghi ra tất cả các cái tên có thể được tạo ra, mỗi kết quả viết trên một dòng.

**Ví dụ**

**input**
```
1
4 2
```

**output**
```
AB
AC
AD
BC
BD
CD
```

### DSA01026 - PHÁT LỘC

Một xâu ký tự số chỉ bao gồm các chữ số 6 và 8 sẽ được gọi là “phát lộc” nếu thỏa mãn các điều kiện sau:

*   Độ dài xâu ít nhất là 6
*   Chữ số đầu tiên là chữ số 8, chữ số cuối cùng là chữ số 6
*   Không có 2 chữ số 8 nào ở cạnh nhau
*   Không có nhiều hơn 3 chữ số 6 ở cạnh nhau.

Viết chương trình liệt kê các xâu ký tự phát lộc độ dài N theo thứ tự tăng dần.

**Input**

Chỉ có 1 dòng ghi số N (5 < N < 16).

**Output**

Ghi ra các xâu ký tự phát lộc độ dài N, mỗi xâu trên một dòng.

**Ví dụ**

**input**
```
6
```

**output**
```
866686
866866
868666
868686
```

### DSA01027 - HOÁN VỊ DÃY SỐ

Cho dãy số A\[\] có N phần tử là các số nguyên dương khác nhau từng đôi một. Hãy liệt kê tất cả các hoán vị của dãy số A\[\] theo thứ tự tăng dần, tức là hoán vị đầu tiên có giá trị tăng dần từ trái qua phải, hoán vị cuối cùng giảm dần từ trái qua phải.

**Input**

Dòng đầu ghi số N (1 < N < 9)

Dòng thứ 2 ghi N số của dãy A\[\] (0 < A\[i\] < 10000)

**Output**

Ghi mỗi hoán vị của dãy số trên một dòng

**Ví dụ**

**input**
```
3
88 77 99
```

**output**
```
77 88 99
77 99 88
88 77 99
88 99 77
99 77 88
99 88 77
```

### DSA01028 - LIỆT KÊ TỔ HỢP

Cho dãy số A\[\] có N phần tử. Hãy liệt kê tất cả các tổ hợp chập K của tập các phần tử khác nhau trong A\[\]. Các tổ hợp cần liệt kê theo thứ tự từ điển (tức là trong mỗi tổ hợp thì giá trị từ nhỏ đến lớn, và tổ hợp sau lớn hơn tổ hợp trước).

**Input**

Dòng đầu ghi hai số N và K.

Dòng thứ 2 ghi N số của mảng A\[\]. Các giá trị không quá 1000.

Dữ liệu đảm bảo số phần tử khác nhau của A\[\] không quá 20 và K không quá 10.

**Output**

Ghi ra lần lượt các tổ hợp tìm được, mỗi tổ hợp trên một dòng.

**Ví dụ**

**input**
```
8 3
2 4 4 3 5 1 3 4
```

**output**
```
1 2 3
1 2 4
1 2 5
1 3 4
1 3 5
1 4 5
2 3 4
2 3 5
2 4 5
3 4 5
```

### DSA02008 - CHỌN SỐ TỪ MA TRẬN VUÔNG CẤP N

Cho ma trận vuông Ci,j cấp N (1<= i, j <= N<10) gồm N<sup>2</sup> số tự nhiên và số tự nhiên K (các số trong ma trận không nhất thiết phải khác nhau và đều không quá 100, K không quá 10<sup>4</sup>). Hãy viết chương trình lấy mỗi hàng, mỗi cột duy nhất một phần tử sao cho tổng các phần tử này đúng bằng K.

**Input:** 
Dòng 1 ghi hai số N và K. N dòng tiếp theo ghi ma trận C. 

**Output:** 
Dòng đầu ghi số cách tìm được. Mỗi dòng tiếp theo ghi một cách theo vị trí của số đó trong lần lượt từng hàng của ma trận. Xem ví dụ để hiểu rõ hơn. 

**input**
```
3 10
2 4 3
1 3 6
4 2 4
```

**output**
```
2
1 3 2
3 2 1
```

## Backtracking


### DSA01024 - ĐẶT TÊN - 1

Kỳ thi ICPC có K đội của PTIT tham gia và đội tuyển đang rất đau đầu không biết chọn các cái tên như thế nào cho các đội. Yêu cầu phải đảm bảo tên không có khoảng trống và không được trùng nhau. Sau khi thảo luận, có N cái tên được đề xuất (có thể bị trùng nhau). Với K<15 và 4 < N < 30.

Hãy liệt kê tất cả danh sách các tổ hợp K cái tên khác nhau có thể được tạo ra theo thứ tự từ điển.

**Input**

Dòng đầu ghi 2 số N và K.

Tiếp theo là 1 dòng ghi N cái tên, mỗi cái tên có độ dài không quá 15 và cách nhau một khoảng trống. Tất cả đều là ký tự in hoa.

**Output**

Ghi ra tất cả các tổ hợp tên có thể được lựa chọn theo thứ tự từ điển.

Tức là các tên trong mỗi tổ hợp liệt kê theo thứ tự từ điển và các tổ hợp cũng được liệt kê theo thứ tự từ điển.

**Ví dụ**

**input**
```
6 2
DONG TAY NAM BAC TAY BAC
```

**ouput**
```
BAC DONG
BAC NAM
BAC TAY
DONG NAM
DONG TAY
NAM TAY
```

### DSA02001 - DÃY SỐ 1

Cho dãy số A\[\] gồm n số nguyên dương. Tam giác đặc biệt của dãy số A\[\] là tam giác được tạo ra bởi n hàng, trong đó hàng thứ 1 là dãy số A\[\], hàng i là tổng hai phần tử liên tiếp của hàng i-1 (2≤i≤n). Ví dụ A\[\] = {1, 2, 3, 4, 5}, khi đó tam giác được tạo nên như dưới đây:

\[1, 2, 3, 4, 5 \]

\[3, 5, 7, 9 \]

\[8, 12, 16\]

\[20, 28\]

\[48\]

**Input:**

*   Dòng đầu tiên đưa vào số lượng bộ test T.
*   Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N là số lượng phần tử của dãy số A\[\]; dòng tiếp theo đưa vào N số của mảng A\[\].
*   T, N, A\[i\] thỏa mãn ràng buộc: 1≤T≤100; 1≤N, A\[i\] ≤10;

**Output:**

*   Đưa ra tam giác tổng của mỗi test theo từng dòng. Mỗi dòng của tam giác tổng được bao bởi ký tự \[, \].

**input**
```
1
5
1 2 3 4 5
```

**output**
```
[1 2 3 4 5]
[3 5 7 9]
[8 12 16]
[20 28]
[48]
```

### DSA02002 - DÃY SỐ 2

Cho dãy số A\[\] gồm n số nguyên dương. Tam giác đặc biệt của dãy số A\[\] là tam giác được tạo ra bởi n hàng, trong đó hàng thứ n là dãy số A\[\], hàng i là tổng hai phần tử liên tiếp của hàng i+1 (1≤i≤n-1). Ví dụ A\[\] = {1, 2, 3, 4, 5}, khi đó tam giác được tạo nên như dưới đây:

\[48\]

\[20, 28\]

\[8, 12, 16\]     

\[3, 5, 7, 9 \]

\[1, 2, 3, 4, 5 \]

**Input:**

*   Dòng đầu tiên đưa vào số lượng bộ test T.
*   Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N là số lượng phần tử của dãy số A\[\]; dòng tiếp theo đưa vào N số của mảng A\[\].
*   T, N, A\[i\] thỏa mãn ràng buộc: 1≤T≤100; 1≤N, A\[i\] ≤10;

**Output:**

*   Đưa ra kết quả mỗi test theo từng dòng. Mỗi dòng của tam giác tổng được bao bởi ký tự \[, \].

**input**
```
1
5
1 2 3 4 5
```

**output**
```
[48] [20 28] [8 12 16] [3 5 7 9] [1 2 3 4 5]
```

### DSA02003 - DI CHUYỂN TRONG MÊ CUNG 1

Cho một mê cung bao gồm các khối được biểu diễn như một ma trận nhị phân A\[N\]\[N\]. Một con chuột đi từ ô đầu tiên góc trái (A\[0\]\[0\]) đến ô cuối cùng góc phải (A\[N-1\]\[N-1\]) theo nguyên tắc:

*   Down (D): Chuột được phép xuống dưới nếu ô dưới nó có giá trị 1.
*   Right (R): Chuột được phép sang phải dưới nếu ô bên phải nó có giá trị 1.

Hãy đưa ra một hành trình của con chuột trên mê cung. Đưa ra -1 nếu chuột không thể đi đến đích.

**Input:**

*   Dòng đầu tiên đưa vào số lượng bộ test T.
*   Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là kích cỡ của mê cung; dòng tiếp theo đưa vào ma trận nhị phân A\[N\]\[N\].
*   T, N, A\[i\]\[j\] thỏa mãn ràng buộc: 1≤T ≤10; 2≤N≤10; 0≤A\[i\]\[j\] ≤1.

**Output:**

*   Đưa ra tất cả đường đi của con chuột trong mê cung theo thứ tự từ điển. Đưa ra -1 nếu chuột không đi được đến đích.

**input**
```
2
4
1 0 0 0
1 1 0 1 
0 1 0 0 
1 1 1 1
5
1 0 0 0 0
1 1 1 1 1
1 1 0 0 1
0 1 1 1 1
0 0 0 1 1
```

**output**
```
DRDDRR
DDRDRRDR DDRDRRRD DRDDRRDR DRDDRRRD DRRRRDDD
```

### DSA02004 - DI CHUYỂN TRONG MÊ CUNG 2

Cho một mê cung bao gồm các khối được biểu diễn như một ma trận nhị phân A[N][N]. Một con chuột đi từ ô đầu tiên góc trái (A[0][0]) đến ô cuối cùng góc phải (A[N-1][N-1]) theo nguyên tắc:

- Down (D): Chuột được phép xuống dưới nếu ô dưới nó có giá trị 1.
- Right (R): Chuột được phép sang phải dưới nếu ô bên phải nó có giá trị 1.
- Left (L): Chuột được phép sang trái dưới nếu ô bên trái nó có giá trị 1.
- Up (U): Chuột được phép lên trên nếu ô trên nó có giá trị 1.

Hãy đưa ra tất cả các hành trình của con chuột trên mê cung. Đưa ra -1 nếu chuột không thể đi đến đích.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là kích cỡ của mê cung; dòng tiếp theo đưa vào ma trận nhị phân A[N][N].
- T, N, A[i][j] thỏa mãn ràng buộc: 1≤T ≤10; 2≤N≤8; 0≤A[i][j] ≤1.

**Output:**
- Đưa ra các xâu ký tự được sắp xếp, trong đó mỗi xâu là một đường đi của con chuột trong mê cung. In ra đáp án theo thứ tự từ điển. Đưa ra -1 nếu chuột không đi được đến đích.

**input**
```
3
4
1 0 0 0
1 1 0 1
0 1 0 0
0 1 1 1
4
1 0 0 0
1 1 0 1
1 1 0 0
0 1 1 1
5
1 0 0 0 0
1 1 1 1 1
1 1 1 0 1
0 0 0 0 1
0 0 0 0 1
```

**output**
```
DRDDRR
DDRDRR DRDDRR
DDRRURRDDD DDRURRRDDD DRDRURRDDD DRRRRDDD
```

### DSA02005 - HOÁN VỊ XÂU KÝ TỰ

Cho xâu ký tự S bao gồm các ký tự in hoa khác nhau. Hãy đưa ra tất cả các hoán vị của xâu ký tự S. Ví dụ S=”ABC” ta có kết quả {ABC ACB BAC BCA CAB CBA}. 

**Input:**

*   Dòng đầu tiên đưa vào số lượng bộ test T.
*   Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test là một xâu ký tự S được viết trên 1 dòng.
*   T, S thỏa mãn ràng buộc: 1≤T≤10; 1≤length(S) ≤10;

**Output:**

*   Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2  
AB
ABC
```

**output**
```
AB BA
ABC ACB BAC BCA CAB CBA
```

### DSA02006 - DÃY CON TỔNG BẰNG K

Cho dãy số A\[\] = (a1, a2, .., an) và số tự nhiên K. Hãy đưa ra tất cả các dãy con của dãy số A\[\] sao cho tổng các phần tử của dãy con đó đúng bằng K. Các phần tử của dãy số A\[\] được giả thuyết là nguyên dương và không có các phần tử giống nhau. Ví dụ với dãy con A\[\] = {5, 10, 15, 20, 25}, K = 50 ta có 3 dãy con {5, 10, 15, 20}, {5, 20, 25}, {10, 15, 25}.

**Input:**

*   Dòng đầu tiên đưa vào số lượng bộ test T.
*   Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là số lượng phần tử của dãy số A\[\] và số K; dòng tiếp theo đưa vào N phần tử của dãy số A\[\].
*   T, N, A\[i\] thỏa mãn ràng buộc: 1≤T ≤100; 1≤N≤10; 1≤ K, A\[i\] ≤100.

**Output:**

*   Đưa ra tất cả các dãy con của dãy số A\[\] thỏa mãn yêu cầu bài toán theo thứ tự từ điển, trong đó mỗi dãy con được bao bởi các ký tự \[, \]. Nếu không có dãy con nào thỏa mãn yêu cầu bài toán, hãy đưa ra -1.

**input**
```
2  
5 50
5  10 15 20  25  
8  53  
15  22  14  26  32  9  16  8
```

**output**
```
[5 10 15 20] [5 20 25] [10 15 25]  
[8 9 14 22] [8 14 15 16] [15 16 22]
```

### DSA02007 - ĐỔI CHỖ CÁC CHỮ SỐ

Cho số tự nhiên K và xâu ký tự các chữ số S.  Nhiệm vụ của bạn là đưa ra số lớn nhất bằng cách thực hiện nhiều nhất K lần đổi chỗ các ký tự trong S. Ví dụ K =3 và S = “1234567” ta được “7654321”.

**Input:**

- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là số K; dòng tiếp theo là xâu ký tự S.
- T, K, S thỏa mãn ràng buộc: 1≤T ≤100; 1≤K≤10; 1≤.lenght(S)≤7.

**Output:**

- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
4
1234567
3
3435335
2
1034
```

**output**
```
3
4
1234567
3
3435335
2
1034
```

### DSA02009 - CHIA MẢNG

Cho mảng các số nguyên A[] gồm N phần tử. Hãy chia mảng số nguyên A[] thành K tập con khác rỗng sao cho tổng các phần tử của mỗi tập con đều bằng nhau. Mỗi phần tử thuộc tập con xuất hiện duy nhất một lần trong tất cả các tập con. Ví dụ với A[] = {2, 1, 4, 5, 6}, K =3 ta có kết quả {2, 4}, {1, 5}, {6}.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số N và K; dòng tiếp theo đưa vào N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, K, A[i] thỏa mãn ràng buộc: 1≤T ≤100; 1≤N, K≤20, 0≤A[i]≤100.

**Output:**
- Đưa ra 1 nếu có thể chia tập con thành K tập thỏa mãn yêu cầu bài toán, ngược lại đưa ra 0.

**input**
```
2
5 3
2 1 4 5 6
5 3
2 1 5 5 6
```

**output**
```
1
0
```

### DSA02010 - TỔ HỢP SỐ CÓ TỔNG BẰNG X

Cho mảng A[] gồm N số nguyên dương phân biệt và số X. Nhiệm vụ của bạn là tìm phép tổ hợp các số trong mảng A[] có tổng bằng X. Các số trong mảng A[] có thể được sử dụng nhiều lần. Mỗi tổ hợp các số của mảng A[] được in ra theo thứ tự không giảm các số. Ví dụ với A[] = {2, 4, 6, 8}, X = 8 ta có các tổ hợp các số như sau:

[2, 2, 2, 2], [2, 2, 4], [2, 6], [4, 4], [8].

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số N và X; dòng tiếp theo đưa vào N số của mmảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, X, A[i] thỏa mãn ràng buộc: 1≤T ≤10; 1≤X, A[i]≤100. N ≤ 20.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng. Mỗi đường tổ hợp được bao bởi cặp ký tự [, ]. Đưa ra -1 nếu không có tổ hợp nào thỏa mãn yêu cầu bài toán.

**input**
```
1
4 8
2 4 6 8
```

**output**
```
[2 2 2 2][2 2 4][2 6][4 4][8]
```

### DSA02011 - MÁY ATM

Một máy ATM hiện có n (n ≤ 30) tờ tiền có giá trị t[1], t[2], …, t[n]. Hãy tìm cách trả ít tờ nhất với số tiền đúng bằng S (các tờ tiền có giá trị bất kỳ và có thể bằng nhau, mỗi tờ tiền chỉ được dùng một lần).

**Input:**

Dòng đầu tiên ghi số bộ test T (T<10). Mỗi bộ test gồm 2 số nguyên n và S (S ≤ 10<sup>9</sup>). Dòng thứ hai chứa n số nguyên t[1], t[2], …, t[n] (t[i] ≤ 10<sup>9</sup>)

**Output:**

Với mỗi bộ test ghi ra số tờ tiền ít nhất phải trả.

Nếu không thể tìm được kết quả, in ra -1.
**input**
```
1
3 5
1 4 5
```

**output**
```
1
```

### DSA02012 - DI CHUYỂN TRONG MA TRẬN

Cho ma trận A\[M\]\[N\]. Nhiệm vụ của bạn là đếm tất cả các đường đi từ phần tử A\[0\]\[0\] đến phần tử A\[M-1\]\[N-1\]. Bạn chỉ được phép dịch chuyển xuống dưới hoặc sang phải phần tử liền kề với vị trí hiện tại.

**Input:**

*   Dòng đầu tiên đưa vào số lượng bộ test T.
*   Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số M, N tương ứng với số hàng và số cột của ma trận; dòng tiếp theo đưa vào các phần tử của ma trận A\[\]\[\]; các số được viết cách nhau một vài khoảng trống.
*   T, M, N, A\[i\]\[j\] thỏa mãn ràng buộc: 1≤T ≤10; 1≤M, N, A\[i\]\[j\]≤100.

**Output:**

*   Đưa ra số cách di chuyển của mỗi test theo từng dòng.
*   Giải thích test 1: Có 3 cách di chuyển là \[1 4 5 6\], \[1 2 5 6\] và \[1 2 3 6\].

**input**
```
2  
2 3
1 2 3 
4 5 6  
2 2
1 2 
3 4
```

**output**
```
3
2
```

### DSA02013 - SỐ NGUYÊN TỐ

Cho ba số N, P, S. Trong đó, P là một số nguyên tố. Nhiệm vụ của bạn là đưa ra tất cả N số nguyên tố tính từ P có tổng bằng S. Ví dụ với S = 28, P=7, N =2 ta có kết quả 11 + 17 = 28. Với N = 3, P = 2, S = 23 ta có kết quả : {3, 7, 13}, {5, 7, 11}

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ ba số S, P, N được viết trên một dòng.
- S, P, N thỏa mãn ràng buộc: 1≤T ≤100; 1 ≤ N ≤ 10; 2≤S, P≤200.

**Output:**
- Với mỗi test, dòng đầu tiên in ra số lượng đáp án tìm được. Mỗi dòng tiếp theo in ra kết quả tìm được theo thứ tự từ điển.

**input**
```
2
2 7 28
3 2 23
```

**output**
```
1
11 17
2
3 7 13
5 7 11
```

### DSA02014 - TỪ ĐIỂN

Cho tập từ ghi trong trừ điển dic[] và một bảng hai chiều A[M][N] các ký tự. Hãy tạo nên tất cả các từ có mặt trong từ điển dic[] bằng cách nối các ký tự kề nhau trong mảng A[][]. Chú ý, phép nối các ký tự kề nhau trong mảng A[][] được thực hiện theo 8 hướng nhưng không có phần tử A[i][j] nào được lặp lại. Ví dụ với từ điển dic[] ={ “GEEKS”, “FOR”, “QIUZ”, “GO”} và mảng A[][] dưới đây sẽ cho ta kết quả: “GEEKS”, “QUIZ”

| G | I | Z |
|---|---|---|
| U | E | K |
| Q | S | E |

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào ba số K, M, N tương ứng với số từ của từ điển dic[], số hàng và số cột của ma trận ký tự A[M][N]; dòng tiếp theo đưa vào K từ của từ điển dic[]; dòng cuối cùng đưa vào các phần tử A[i][j].
- T, K, M, N thỏa mãn ràng buộc: 1≤T ≤10; 1≤K≤100; 1≤ M, N ≤3.

**Output:**
- Đưa ra theo thứ tự tăng dần các từ có mặt trong từ điển dic[] được tạo ra từ ma trận A[][]. Đưa ra -1 nếu không thể tạo ra từ nào thuộc dic[] từ A[][].

**input**
```
1
4 3 3
GEEKS FOR QUIZ GO
G I Z
U E K
Q S E
```

**output**
```
GEEKS QUIZ
```

### DSA02015 - LOẠI BỎ DẤU NGOẶC

Cho biểu thức P chỉ chứa các ký tự ‘(’, ‘)’ và các ký tự. Không có phép toán nào trong biểu thức P. Nhiệm vụ của bạn là thực hiện ít nhất các phép loại bỏ các ký tự ‘(’, ‘)’ để P trở thành biểu thức đúng. Chú ý: một biểu thức chỉ có 1 ký tự chữ (không có dấu ngoặc) hoặc một biểu thức rỗng thì không được xem là biểu thức đúng.

Nếu có nhiều hơn một biểu thức đúng với cùng số phép loại bỏ ít nhất hãy đưa ra tất cả các biểu thức đúng theo thứ tự từ điển.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một biểu thức P được viết trên một dòng.
- T, P thỏa mãn ràng buộc: 1≤T ≤100; 1≤length(P)≤100.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng. Nếu không có đáp án, in ra -1.

**input**
```
2
()())()
(u)())()
```

**output**
```
(())() ()()()
(u())() (u)()() 
```

### DSA02016 - SẮP XẾP QUÂN HẬU 1

Cho một bàn cờ vua có kích thước n * n, ta biết ràng quân hậu có thể di chuyển theo chiều ngang, dọc, chéo. Vấn đề đặt ra rằng, có n quân hậu, bạn cần đếm số cách đặt n quân hậu này lên bàn cờ sao cho với 2 quân hậu bất kì, chúng không “ăn” nhau.

**Input:** Dòng đầu ghi số bộ test T (T<5). Mỗi bộ test ghi một số nguyên dương n duy nhất (không quá 10)

**Output:**  Ghi kết quả mỗi bộ test trên một dòng. Số cách đặt quân hậu.

Ví dụ:

**input**
```
1
4
```

**output**
```
2
```

### DSA02017 - SẮP XẾP QUÂN HẬU 2

Cho một bàn cờ 8 x 8, mỗi ô có một giá trị A[i][j] nhất định (0 ≤ A[i][j] ≤ 100), tương ứng với điểm số đạt được nếu như bạn đặt một quân cờ vào đó.

Nhiệm vụ của bạn là đặt 8 quân hậu lên bàn cờ, sao cho không có 2 quân nào ăn nhau, và số điểm đạt được là lớn nhất.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 8 dòng, mỗi dòng 8 số nguyên mô tả bàn cờ.

**Output:** 
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
1
1 2 3 4 5 6 7 8
9 10 11 12 13 14 15 16
17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32
33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
48 50 51 52 53 54 55 56
57 58 59 60 61 62 63 64
```

**output**
```
260
```

### DSA02018 - BIỂU THỨC TOÁN HỌC

Cho 5 số nguyên dương A, B, C, D, E. Bạn có thể hoán vị các phần tử cho nhau, hãy đặt các dấu biểu thức +, -, * sao cho biểu thức sau đúng:

[[[A o(1) B] o(2) C] o(3) D] o(4) E = 23

Trong đó: o(1) … o(4) là các phép toán +, -, *.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 5 số nguyên dương A, B, C, D, E có giá trị không vượt quá 100.

**Output:** 
- Với mỗi test, in ra đáp án tìm được, mỗi xâu in ra trên một dòng.

**input**
```
3
1 1 1 1 1
1 2 3 4 5
2 3 5 7 11
```

**output**
```
NO
YES
YES
```

### DSA02019 - ĐƯỜNG ĐI DÀI NHẤT

Cho đồ thị vô hướng có N đỉnh và M cạnh. Bạn hãy tìm đường đi dài nhất trên đồ thị, sao cho mỗi cạnh chỉ được đi qua nhiều nhất 1 lần.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test bắt đầu bằng số nguyên N và M (1 ≤ N, M ≤ 20). 
- Các đỉnh đánh dấu từ 0, 1, …, N-1. M dòng tiếp theo, mỗi dòng gồm 2 số u, v cho biết có cạnh nối giữa uàv.

**Output:** 
- Với mỗi test, in ra đáp án tìm được, mỗi xâu in ra trên một dòng.

**input**
```
2
3 2
0 1
1 2
15 16
0 2
1 2
2 3
3 4
3 5
4 6
5 7
6 8
7 8
7 9
8 10
9 11
10 12
11 12
10 13
12 14
```

**output**
```
2
12
```

### DSA02020 - SỐ NHỎ NHẤT CÓ N ƯỚC SỐ

Cho số nguyên dương N. Nhiệm vụ của bạn là tìm số K nhỏ nhất, sao cho K có đúng N ước. Input đảm bảo rằng đáp án không vượt quá 10<sup>18</sup>.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤  20).
- Mỗi test gồm 1 số nguyên N ( 1 ≤  N ≤  1000).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
4
6
```

**output**
```
6
12
```

### DSA02021 - KÝ TỰ ĐẶC BIỆT

Cho một xâu s. Xâu F(s) được xác định bằng cách ghép xâu xâu s ban đầu với xâu s sau khi đã được quay vòng sang bên phải 1 kí tự (kí tự cuối cùng của s được chuyển lên đầu).

Thực hiện liên tiếp các bước cộng xâu như trên với xâu mới thu được, ta có được xâu X.

![download](https://user-images.githubusercontent.com/64203006/163589667-637e3c59-f78e-4c8e-ba7e-3f88b283f2fc.png)

Nhiệm vụ của bạn là hãy xác định kí tự thứ N trong xâu X là kí tự nào?



**Input:** 
Dòng đầu ghi số bộ test T (T<10). Mỗi bộ test gồm một xâu s có độ dài không vượt quá 30 kí tự và số nguyên N (1 ≤ N ≤ 10<sup>18</sup>).

**Output:** 
Với mỗi bộ test ghi ra trên một dòng kí tự tìm được.

**input**
```
1
COW 8
```

**output**
```
C
```

Giải thích test: COW -> COWWCO -> COWWCOOCOWWC. Kí tự thứ 8 là ‘C’.

### DSA02022 - NGÀY ĐẶC BIỆT


Hôm nay là ngày 22/02/2022. Một ngày đặc biệt. Chỉ có hai chữ số là 0 và 2. Đồng thời viết xuôi viết ngược tám chữ số ta đều được cùng một kết quả.

Nhiệm vụ của bạn trong ngày đặc biệt này là hãy liệt kê hết tất cả các ngày hợp lệ chỉ có 2 chữ số 0 và 2.

Một số chú ý:

- Luôn có đủ 8 chữ số của ngảy tháng năm và hai dấu gạch chéo.
- Ngày và tháng có thể có chữ số 0 ở đầu nhưng với năm thì không được phép. Tức là ta chỉ tính các ngày bắt đầu từ năm 2000 trở về sau.


Bài toán không có dữ liệu vào. Bạn chỉ cần liệt kê kết quả gồm tất cả các ngày tháng hợp lệ. Coi dãy ký tự ngày tháng là một xâu ký tự. Hãy liệt kê theo đúng thứ tự từ điển tăng dần.


### DSA02023 - ĐẶT TÊN

Kỳ thi ICPC có K đội của PTIT tham gia và đội tuyển đang rất đau đầu không biết chọn các cái tên như thế nào cho các đội. Yêu cầu phải đảm bảo tên không có khoảng trống và không được trùng nhau. Sau khi thảo luận, có N cái tên được đề xuất (có thể bị trùng nhau). Với K<15 và 4 < N < 30.

Hãy liệt kê tất cả danh sách các tổ hợp K cái tên khác nhau có thể được tạo ra theo thứ tự từ điển.

**Input**

Dòng đầu ghi 2 số N và K.

Tiếp theo là 1 dòng ghi N cái tên, mỗi cái tên có độ dài không quá 15 và cách nhau một khoảng trống. Tất cả đều là ký tự in hoa.

**Output**

Ghi ra tất cả các tổ hợp tên có thể được lựa chọn theo thứ tự từ điển.

Tức là các tên trong mỗi tổ hợp liệt kê theo thứ tự từ điển và các tổ hợp cũng được liệt kê theo thứ tự từ điển.

**input**
```
6 2
DONG TAY NAM BAC TAY BAC
```

**output**
```
BAC DONG
BAC NAM
BAC TAY
DONG NAM
DONG TAY
NAM TAY
```

### DSA02024 - DÃY CON TĂNG DẦN

Cho dãy số a[] có n phần tử là các số nguyên dương khác nhau từng đôi một. Hãy liệt kê tất cả các dãy con có từ 2 phần tử trở lên của dãy a[] thỏa mãn tính chất tăng dần.

Dãy con tạo được bằng cách lấy ra các phần tử trong dãy a[] nhưng vẫn giữ nguyên thứ tự ban đầu.

Coi mỗi dãy con như một xâu ký tự với các phần tử cách nhau một khoảng trống, hãy liệt kê theo thứ tự từ điển.

**Input**
- Dòng đầu ghi số n (không quá 20)
- Dòng thứ 2 ghi n số của dãy a[]. Các số khác nhau từng đôi một và có giá trị không quá 100.

**Output**

Ghi ra lần lượt các dãy con tăng dần theo thứ tự từ điển.

**input**
```
4
6 3 7 11
```

**output**
```
3 11
3 7
3 7 11
6 11
6 7
6 7 11
7 11
```

### DSA02025 - KÝ TỰ LẶP

Cho một dãy các xâu ký tự chỉ bao gồm các chữ cái in hoa từ A đến Z, trong đó các ký tự trong mỗi xâu đều đã được sắp xếp theo thứ tự từ điển và mỗi chữ cái chỉ xuất hiện nhiều nhất một lần (tức là độ dài xâu tối đa là 26). Nếu một ký tự xuất hiện trong hai xâu liên tiếp thì được coi là một lần lặp. Hãy tìm cách sắp xếp lại thứ tự các xâu sao cho số lần lặp là nhỏ nhất có thể. Ví dụ dưới đây là cùng một dãy xâu nhưng với cách sắp xếp lại thì số lần lặp chỉ còn 2.

ABC

ABEF

DEF

ABCDE

FGH

=> Số lần lặp là 6

ABEF

DEF

ABC

FGH

ABCDE

=> Số lần lặp là 2.

**Input** 
Dòng đầu tiên ghi số N (2 ≤ N ≤ 10) là số xâu ký tự. N dòng tiếp theo, mỗi dòng ghi một xâu. 

**Output** 
In ra trên một dòng số lần lặp nhỏ nhất có thể. 

**input**

test 1
```
5
ABC
ABEF
DEF
ABCDE
FGH
```
test 2
```
6
BDE
FGH
DEF
ABC
BDE
ABEF
```
test 3
```
4
XYZ
XYZ
ABYZ
Z
```

**output**

test 1
```
2
```
test 2
```
3
```
test 3
```
4
```

### DSA02026 - PHÉP TOÁN CƠ BẢN

Cho một biểu thức trong phạm vi hai chữ số với các phép toán cộng trừ nhân chia. Các toán hạng và kết quả đảm bảo là số nguyên dương có hai chữ số, nếu có phép chia thì phải thỏa mãn tính chia hết.

Người ta có thể ẩn đi một số chữ số hoặc phép toán bằng cách điền dấu chấm hỏi (?). Nhiệm vụ của bạn là khôi phục các dấu chấm hỏi và in ra phép toán chính xác ban đầu. Nếu không thể có kết quả đúng thì ghi ra WRONG PROBLEM!

**Input**
- Dòng đầu ghi số bộ test T (1 ≤ T ≤ 100).
- T dòng tiếp theo, mỗi dòng là một biểu thức có thể có các dấu ?.

*Nếu có thể có nhiều kết quả đúng thì in ra kết quả đầu tiên theo thứ tự từ điển, tức là số nhỏ nhất có thể tính từ trái sang phải.*

**Output**
- Với mỗi bộ test, ghi ra biểu thức đúng tìm được. Hoặc WRONG PROBLEM!

**input**
```
2
?0 ? 12 = 28
40 / ?3 = ??
```

**output**
```
40 - 12 = 28
WRONG PROBLEM!
```

### DSA02027 - NGƯỜI DU LỊCH

Cho n thành phố đánh số từ 1 đến n và các tuyến đường giao thông hai chiều giữa chúng, mạng lưới giao thông này được cho bởi mảng C[1…n, 1…n] ở đây C[i][j] = C[j][i] là chi phí đi đoạn đường trực tiếp từ thành phố i đến thành phố j.

Một người du lịch xuất phát từ thành phố 1, muốn đi thăm tất cả các thành phố còn lại mỗi thành phố đúng 1 lần và cuối cùng quay lại thành phố 1. Hãy chỉ ra chi phí ít nhất mà người đó phải bỏ ra.

**Input** 
Dòng đầu tiên là số nguyên n – số thành phố (n ≤ 15); n dòng sau, mỗi dòng chứa n số nguyên thể hiện cho mảng 2 chiều C.

**Output** 
Chi phí mà người đó phải bỏ ra.

**input**
```
4
0 20 35 10
20 0 90 50
35 90 0 12
10 50 12 0
```

**output**
```
117
```

### DSA02028 - CHIA ĐỀU

Cho dãy số A có N phần tử và số K. Hãy đếm số cách chia dãy A thành K nhóm các phần tử liên tiếp sao cho tổng giá trị của mỗi nhóm đều bằng nhau.

**Input**
- Dòng đầu ghi hai số N và K (0 < N ≤ 12; 0 < K < N ).
- Dòng thứ 2 ghi N số của dãy A (-10000 ≤ A[i] ≤ 10000)

**Output**
- In ra số cách thỏa mãn

**input**

test 1
```
3 2
-2 0 -2
```
test 2
```
3 2
1 2 3
```

**output**

test 1
```
2
```
test 2
```
1
```

### DSA02029 - THÁP HÀ NỘI

Bài toán Tháp Hà Nội đã rất nổi tiểng. Bắt đầu có các đĩa xếp chồng lên cột A theo thứ tự kích thước giảm dần, nhỏ nhất ở trên cùng. Cột B và cột C ban đầu không có đĩa nào cả.

Mục tiêu của bạn là di chuyển toàn bộ các đĩa theo đúng thứ tự về cột C, tuân theo các quy tắc sau:

- Mỗi lần chỉ có thể di chuyển một đĩa.
- Mỗi lần di chuyển sẽ lấy đĩa trên từ một trong các cột và đặt nó lên trên một cột khác.
- Không được đặt đĩa lên trên đĩa nhỏ hơn..

**Input**

Số tự nhiên  0 < N < 10

**Output**

In ra lần lượt từng bước theo mẫu trong ví dụ. Chú ý giữa các chữ cái và dấu -> có khoảng trống.

**input**
```
3
```

**output**
```
A -> C
A -> B
C -> B
A -> C
B -> A
B -> C
A -> C
```

### DSA02030 - LIỆT KÊ XÂU KÝ TỰ

Cho chữ cái c in hoa (‘A’ < c < ’K’) và số nguyên K (0 < K < (c – ‘A’)).

Hãy tìm cách  liệt kê tất cả các xâu ký tự khác nhau được tạo ra bởi các chữ cái tính từ ‘A’ đến ký tự c. Các ký tự được phép lặp lại nhưng không tính các xâu là hoán vị của xâu nào đó đã liệt kê trước đó.

Xem ví dụ để hiểu thêm yêu cầu đề bài.

**Input**

Chỉ có một dòng ghi chữ cái c và số nguyên K thỏa mãn ràng buộc đề bài.

**Output**

Ghi ra lần lượt các xâu ký tự kết quả theo thứ tự từ điển, mỗi xâu trên một dòng.

**input**
```
D 2
```

**output**
```
AA
AB
AC
AD
BB
BC
BD
CC
CD
DD
```

### DSA02031 - GHÉP CHỮ CÁI

Trong 8 chữ cái Tiếng Anh đầu tiên (ABCDEFGH) thì có 2 nguyên âm là ‘A’, ‘E’, còn lại là phụ âm.

Người ta muốn ghép các chữ cái bắt đầu từ chữ cái ‘A’ cho đến chữ cái c (‘D’ <= c <= ‘H’) sao cho mỗi chữ cái được sử dụng đúng một lần và xâu kết quả không có nguyên âm nào bị kẹp giữa bởi hai phụ âm.

Hãy liệt kê các xâu thỏa mãn theo thứ tự từ điển.

**Input**

Chỉ có một dòng ghi chữ cái c (đảm bảo từ ‘D’ đến ‘H’).

**Output**

Liệt kê các xâu thỏa mãn, mỗi xâu trên một dòng.

**input**
```
D
```

**output**
```
ABCD
ABDC
ACBD
ACDB
ADBC
ADCB
BCDA
BDCA
CBDA
CDBA
DBCA
DCBA
```

### DSA02032 - TỔ HỢP SỐ CÓ TỔNG BẰNG X

Cho mảng A[] gồm N số nguyên dương phân biệt và số X. Nhiệm vụ của bạn là tìm phép tổ hợp các số trong mảng A[] có tổng bằng X. Các số trong mảng A[] có thể được sử dụng nhiều lần. Mỗi tổ hợp các số của mảng A[] được in ra theo thứ tự không giảm các số. Ví dụ với A[] = {2, 4, 6, 8}, X = 8 ta có các tổ hợp các số như sau:

{2, 2, 2, 2}, {2, 2, 4}, {2, 6}, {4, 4}, {8}.

**Input**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số N và X; dòng tiếp theo đưa vào N số của mmảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, X, A[i] thỏa mãn ràng buộc: 1≤T ≤10; 1≤X, A[i]≤100. N ≤ 20.

**Output**
- Đưa ra kết quả mỗi test theo từng dòng. 
- Đầu tiên là số lượng tổ hợp thỏa mãn. Mỗi tổ hợp được bao bởi cặp ký tự { } và cách nhau một dấu cách. Đưa ra -1 nếu không có tổ hợp nào thỏa mãn yêu cầu bài toán.

**input**
```
2
4  8
2  4  6  8
2 9
10 11
```

**output**
```
5 {2 2 2 2} {2 2 4} {2 6} {4 4} {8}
-1
```

### DSA02033 - SỐ XA CÁCH

Cho số nguyên dương N (2 < N <10). Một số nguyên dương K có N chữ số được gọi là số xa cách nếu thỏa mãn:

*   K không chứa chữ số 0
*   Tất cả các chữ số từ 1 đến N đều xuất hiện trong K đúng 1 lần
*   Không có hai chữ số liên tiếp nào trong K có hiệu bằng 1. 

Hãy liệt kê tất cả các số thỏa mãn theo thứ tự tăng dần.

**Input**

*   Dòng đầu ghi số bộ test (không quá 10)
*   Mỗi bộ test là 1 số nguyên dương N (2 < N < 10)

**Output**

Liệt kê tất cả các số thỏa mãn, mỗi số trên một dòng.

Sau mỗi test in ra một khoảng trống.

**Ví dụ**

**input**
```
2
3
4
```

**output**
```
2413
3142
```

### DSA02034 - TRÒ CHƠI VỚI CÁC CON SỐ

Nam có N thẻ bài, mỗi thẻ ghi một con số từ 1 tới N. Không có 2 thẻ nào ghi hai số trùng nhau. Nam muốn xếp thứ tự các thẻ bài sao cho không có hai con số nào liền kề nhau ở cạnh nhau.

Ví dụ với N = 4 thì cách xếp 3142 là hợp lệ nhưng cách xếp 1324 không hợp lệ.

Hãy giúp Nam liệt kê tất cả các cách xếp thỏa mãn theo thứ tự từ điển.  

**Input**
- Dòng đầu ghi số bộ test T (không quá 10)
- Mỗi bộ test ghi số N (3 < N < 10)

**Output**
- Với mỗi bộ test, ghi ra tất cả các cách xếp thứ tự thỏa mãn, mỗi cách trên một dòng.

**input**
```
1
4
```

**output**
```
2413
3142
```

### DSA02035 - HOÁN VỊ CÁC CHỮ SỐ

Độ chênh lệch của một dãy số nguyên dương được định nghĩa là hiệu của số lớn nhất trừ đi số nhỏ nhất trong dãy.

Cho hai số nguyên dương n và k, với 1 <= n, k <= 8.

Với n xâu ký tự số có độ dài k, có thể có chữ số 0 ở đầu. Hãy tìm cách duyệt tất cả hoán vị các chữ số của từng số trong danh sách sao cho độ chênh lệch của dãy số tạo được là bé nhất có thể.

**Input:**
- Dòng đầu ghi hai số n và k.
- Tiếp theo là n dòng, mỗi dòng ghi một xâu ký tự đúng k chữ số.

**Output:**
- Ghi ra độ chênh lệch bé nhất có thể.

**input**
```
6 4
5237
2753
7523
5723
5327
2537
```

**output**
```
2700
```

### DSA02036 - DÃY CON CÓ TỔNG LẺ

Cho dãy số A[] có N phần tử là các số nguyên dương khác nhau từng đôi một.

Hãy sắp xếp dãy theo thứ tự giảm dần, sau đó liệt kê tất cả các dãy con (đúng thứ tự trước sau) của A[] có tổng các phần tử là số lẻ.

Các dãy con được liệt kê theo thứ tự từ điển tăng dần.

**Input:**

Dòng đầu ghi số bộ test, mỗi test có 2 dòng:
- Dòng đầu ghi số N (2 < N <15)
- Dòng thứ 2 ghi N số của dãy A[], các số đều nguyên dương, nhỏ hơn 100 và khác nhau từng đôi một.

**Output:** 
Với mỗi test, liệt kê tất cả các dãy con có tổng các phần tử là số lẻ theo thứ tự từ điển tăng dần, mỗi dãy con trên một dòng.  

**input**
```
1
4
2 3 4 5
```

**output**
```
3
3 2
4 3
4 3 2
5
5 2
5 4
5 4 2
```

### DSA02037 - DÃY CON CÓ TỔNG NGUYÊN TỐ

Cho dãy số A[] có N phần tử là các số nguyên dương khác nhau từng đôi một. Hãy liệt kê tất cả các dãy con của A[] có tổng các phần tử là số nguyên tố.

Các dãy con được liệt kê theo thứ tự từ điển tăng dần.

**Input:**

Dòng đầu ghi số bộ test, mỗi test có 2 dòng:
- Dòng đầu ghi số N (2 < N <15)
- Dòng thứ 2 ghi N số của dãy A[], các số đều nguyên dương, nhỏ hơn 100 và khác nhau từng đôi một.

**Output:** 
Với mỗi test, liệt kê tất cả các dãy con có tổng các phần tử là số lẻ theo thứ tự từ điển tăng dần, mỗi dãy con trên một dòng.  

**input**
```
1
4
3 2 5 4
```

**output**
```
2
3
3 2
4 3
5
5 2
5 4 2
```

### DSA02038 - DÃY CON CÓ K PHẦN TỬ TĂNG DẦN

Cho dãy số A[] có N phần tử là các số nguyên dương khác nhau từng đôi một và một số K < N.

Hãy liệt kê tất cả các dãy con khác nhau có K phần tử của A[], mỗi dãy đều được sắp xếp theo thứ tự tăng dần.

Các dãy con được liệt kê lần lượt theo thứ tự từ điển.

**Input:**

Dòng đầu ghi số bộ test, mỗi test có 2 dòng:
- Dòng đầu ghi số N (2 < N <15)
- Dòng thứ 2 ghi N số của dãy A[], các số đều nguyên dương, nhỏ hơn 100 và khác nhau từng đôi một.

**Output:** 
Với mỗi test, liệt kê tất cả các dãy con thỏa mãn, mỗi dãy con trên một dòng. 

**input**
```
1
4 3
3 2 5 4
```

**output**
```
2 3 4
2 3 5
2 4 5
3 4 5
```

### DSA02039 - PHÂN TÍCH SỐ 2

Cho số nguyên dương N. Nhiệm vụ của bạn là hãy liệt kê tất cả các cách phân tích số tự nhiên N thành tổng các số tự nhiên nhỏ hơn hoặc bằng N. Phép hoán vị của một cách được xem là giống nhau. Ví dụ với N = 5 ta có kết quả là: (5), (4, 1), (3, 2), (3, 1, 1), (2, 2, 1), (2, 1, 1, 1), (1, 1, 1, 1, 1) .

**Input:**
- Dòng đầu tiên đưa vào số lượng test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
- T, n thỏa mãn ràng buộc: 1≤T, N≤10.

**Output:** 
- Dòng đầu tiên là số lượng cách phân tích thỏa mãn. Dòng tiếp theo liệt kê đáp án theo mẫu ví dụ đã cho.

**input**
```
2
4
5
```

**output**
```
5
(4) (3 1) (2 2) (2 1 1) (1 1 1 1)
7
(5) (4 1) (3 2) (3 1 1) (2 2 1) (2 1 1 1) (1 1 1 1 1)
```

### DSA02041 - BIẾN ĐỔI VỀ 1

Cho số nguyên dương N. Hãy đếm số bước ít nhất để đưa N về 1 bằng cách thực hiện ba thao tác dưới đây:
- Nếu N chia hết cho 2 bạn có thể giảm N = N/2.
- Nếu N chia hết cho 3 bạn có thể giảm N = N/3.
- Giảm N đi 1.

**Input:**
- Dòng đầu tiên đưa vào số lượng test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số N được viết trên một dòng.
- T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤100000.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
10
6
```

**output**
```
3
2
```

### DSA02045 - TẬP CON CỦA XÂU KÝ TỰ

Cho một xâu ký tự S không có ký tự lặp lại. Hãy đưa ra tất cả các tập con của xâu ký tự S theo thứ tự từ điển.

**Input:**
- Dòng đầu tiên đưa vào số lượng test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự.
- T, S thỏa mãn ràng buộc: 1≤T≤100; 1≤length(S)≤16.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
3
abc
```

**output**
```
a ab abc ac b bc c
```

### DSA05009 - TẬP CON BẰNG NHAU

Cho tập các số A[] = (a1, a2, .., an). Hãy kiểm tra xem ta có thể chia tập A[] thành hai tập con sao cho tổng các phần tử của hai tập con bằng nhau hay không. Đưa ra YES nếu có thể thực hiện được, ngược lại đưa ra NO.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N là số lượng phần tử của dãy số A[]; dòng tiếp theo đưa vào N phần tử của dãy số A[].
- T, N, A[i] thỏa mãn ràng buộc: 1≤T ≤100; 1≤N≤100; 1≤ A[i] ≤100.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4
1 5 11 5
3
1 3 5 
```

**output**
```
YES
NO
```

### DSAKT012 - ĐỔI TIỀN

Có n tờ tiền có giá trị t[1], t[2], …, t[n].

Hãy tìm cách trả ít tờ tiền nhất với số tiền đúng bằng S

Chú ý: Các tờ tiền có giá trị bất kỳ và có thể bằng nhau, mỗi tờ tiền chỉ được dùng một lần.

**Input:**
- Mỗi bộ test gồm 2 số nguyên n và S (n ≤ 30; S ≤ 10<sup>9</sup>).
- Dòng thứ hai chứa n số nguyên t[1], t[2], …, t[n] (t[i] ≤ 10<sup>9</sup>)

**Output:**
- Ghi ra trên một dòng số tờ tiền ít nhất phải trả.
- Nếu không thể tìm được kết quả, in ra -1.

**input**
```
3 5
1 4 5 
```

**output**
```
1
```

## Greedy

### DSA03001 - ĐỔI TIỀN

Tại ngân hàng có các mệnh giá bằng 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000. Tổng số tiền cần đổi có giá trị bằng N.  Hãy xác định xem có ít nhất bao nhiêu tờ tiền sau khi đổi tiền?

**input**

Dòng đầu tiên là số lượng bộ test T (T ≤ 50).  Mỗi test gồm 1 số nguyên N ( 1 ≤ N ≤ 100 000).

**output** Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
70
121
```

**output**
```
2
3
```

### DSA03002 - NHẦM CHỮ SỐ

Trong một buổi học toán, giáo viên viết 2 số nguyên, A và B, và yêu cầu Tèo thực hiện phép cộng. Tèo không bao giờ tính toán sai, nhưng thỉnh thoảng cậu ta chép các con số một cách không chính xác. Lỗi duy nhất của là ghi nhầm '5' thành '6' hoặc ngược lại.  Cho hai số, A và B, tính tổng nhỏ nhất và lớn nhất mà Tèo có thể nhận được.

**Input:**
Có một dòng chứa hai số nguyên dương A và B ( 1 ≤ A, B ≤ 1 000 000).

**Output:**
In ra 2 số nguyên cách nhau một dấu cách, tổng nhỏ nhất và lớn nhất có thể nhận được.

| | Test 1 | Test 2 | Test 3 |
| --- | --- | --- | --- |
| input | 11 25 | 1430 4862 | 16796 58786 |
| output | 36 37 | 6282 6292 | 74580 85582 |

### DSA03003 - TÌM MAX

Cho mảng A[] gồm N phần tử. Nhiệm vụ của bạn là tìm **max = for(i: 0 to n - 1) A<sub>i</sub> * i** bằng cách sắp đặt lại các phần tử trong mảng. Chú ý, kết quả của bài toán có thể rất lớn vì vậy bạn hãy đưa ra kết quả lấy modulo với 10<sup>9</sup>+7.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N, A[i] ≤10<sup>7</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5
5 3 2 4 1
3
1 2 3
```

**output**
```
40
8
```

### DSA03004 - TỔNG NHỎ NHẤT

Cho mảng A[] gồm các số từ 0 đến 9. Nhiệm vụ của bạn là tìm tổng nhỏ nhất của hai số được tạo bởi các số trong mảng A[]. Chú ý, tất cả các số trong mảng A[] đều được sử dụng để tạo nên hai số.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤20; 0≤A[i]≤9.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
6
6 8 4 5 2 3
5
5 3 0 7 4
```

**output**
```
604
82
```

### DSA03005 - CHIA MẢNG THÀNH HAI MẢNG CON CÓ TỔNG LỚN NHẤT

Cho mảng A[] gồm N số nguyên không âm và số K. Nhiệm vụ của bạn là hãy chia mảng A[] thành hai mảng con có kích cỡ K và N-K sao cho hiệu giữa tổng hai mảng con là lớn nhất. Ví dụ với mảng A[] = {8, 4, 5, 2, 10}, K=2 ta có kết quả là 17 vì mảng A[] được chia thành hai mảng {4, 2} và { 8, 5,10} có hiệu của hai mảng con là 23-6=17 là lớn nhất.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N và số K; dòng tiếp theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, K, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ K<N ≤50; 0≤A[i]≤1000.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5 2
8 4 5 2 10
8 3
1 1 1 1 1 1 1 1
```

**output**
```
17
2
```

### DSA03006 - SẮP XẾP THAM LAM

Cho mảng A[] gồm N số và thực hiện các thao tác theo nguyên tắc dưới đây:

- Ta chọn một mảng con sao cho phần tử ở giữa của mảng con cũng là phần tử ở giữa của mảng A[] (trong trường hợp N lẻ).
- Đảo ngược mảng con đã chọn trong mảng A[]. Ta được phép chọn mảng con và phép đảo ngược mảng con bao nhiêu lần tùy ý.

Ví dụ với mảng A[] = {1, 6, **3, 4, 5**, 2, 7} ta có câu trả lời là Yes vì: ta chọn mảng con {3, 4, 5} và đảo ngược để nhận được mảng A[]={1, 6, **5, 4, 3**, 2, 7}, chọn tiếp mảng con {6, 5, 4, 3, 2} và đảo ngược ta nhận được mảng A[]={1, 2, 3, 4, 5, 6, 7}. Hãy cho biết ta có thể sắp xếp được mảng A[] bằng cách thực hiện các thao tác kể trên hay không?

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp theo đưa vào N số A[i] tương ứng với các phần tử của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N ≤50; 0≤A[i]≤1000.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
7
1 6 3 4 5 2 7
7
1 6 3 4 5 7 2
```

**output**
```
Yes
No
```

### DSA03007 - GIÁ TRỊ NHỎ NHẤT CỦA BIỂU THỨC

Cho mảng A[], B[] đều có N phần tử. Nhiệm vụ của bạn là tìm giá trị nhỏ nhất của  biểu thức P = A[0] * B[0] + A[1] * B[1] + ..+A[N-1] * B[N-1] bằng cách tráo đổi vị trí các phần tử của cả mảng A[] và B[].

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số phần tử của mảng N; dòng tiếp theo đưa vào N số A[i]; dòng cuối cùng đưa vào N số B[i] các số được viết cách nhau một vài khoảng trống.
- T, N, A[i], B[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N ≤10<sup>7</sup>; 0≤A[i], B[i] ≤10<sup>18</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
7
1 6 3 4 5 2 7
1 1 1 2 3 4 3
7
1 6 3 5 5 2 2
0 1 9 0 1 2 3
```

**output**
```
45
27
```

### DSA03008 - SẮP XẾP CÔNG VIỆC 1

Cho hệ gồm N hành động. Mỗi hành động được biểu diễn như một bộ đôi <S<sub>i</sup>, F<sub>i</sub>> tương ứng với thời gian bắt đầu và thời gian kết thúc của mỗi hành động. Hãy tìm phương án thực hiện nhiều nhất các hành động được thực hiện bởi một máy hoặc một người sao cho hệ không xảy ra mâu thuẫn.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số lượng hành động N; dòng tiếp theo đưa vào N số S<sub>i</sub> tương ứng với thời gian bắt đầu mỗi hành động; dòng cuối cùng đưa vào N số F<sub>i</sub> tương ứng với thời gian kết thúc mỗi hành động; các số được viết cách nhau một vài khoảng trống.
- T, N, S<sub>i</sub>, F<sub>i</sub> thỏa mãn ràng buộc: 1≤T≤100;  1≤N, F<sub>i</sub>, S<sub>i</sub>≤1000.

**Output:**
- Đưa số lượng lớn nhất các hành động có thể được thực thi bởi một máy hoặc một người.

**input**
```
1
6
1  3  0  5  8  5
2  4  6  7  9  9
```

**output**
```
4
```

### DSA03009 - SẮP XẾP CÔNG VIỆC 2

Cho N công việc. Mỗi công việc được biểu diễn như một bộ 3 số nguyên dương <JobId, Deadline, Profit>, trong đó JobId là mã của việc, Deadline là thời gian kết thúc của việc, Profit là lợi nhuận đem lại nếu hoàn thành việc đó đúng hoặc trước thời gian. Thời gian tối thiểu để hoàn thành mỗi công việc là 1 đơn vị thời gian. Hãy cho biết lợi nhuận lớn nhất có thể thực hiện các việc với giả thiết mỗi việc được thực hiện đơn lẻ.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là số lượng Job N; phần thứ hai đưa vào 3×N số tương ứng với N job.
- T, N, JobId, Deadline, Profit thỏa mãn ràng buộc:1≤T≤100;  1≤N≤1000; 1≤ JobId ≤1000; 1≤ Deadline ≤1000; 1≤ Profit ≤1000.

**Output:**
- Đưa số lượng công việc tương ứng và lợi nhuận lớn nhất có thể đạt được.

**input**
```
2
4
1 4 20
2 1 10
3 1 40
4 1 30
5
1 2 100
2 1 19
3 2 27
4 1 25
5 1 15
```

**output**
```
2 60
2 127
```

### DSA03010 - NỐI DÂY 1

Cho N sợi dây với độ dài khác nhau được lưu trong mảng A[]. Nhiệm vụ của bạn là nối N sợi dây thành một sợi sao cho tổng chi phí nối dây là nhỏ nhất. Biết chi phí nối sợi dây thứ i và sợi dây thứ j là tổng độ dài hai sợi dây A[i] và A[j].

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào số lượng sợi dây N; dòng tiếp theo đưa vào N số A[i] là độ dài của các sợi dây; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤10<sup>6</sup>; 0≤A[i]≤10<sup>6</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4
4 3 2 6
5
4 2 7 6 9
```

**output**
```
29
62
```

### DSA03011 - NỐI DÂY 2

Cho N sợi dây với độ dài khác nhau được lưu trong mảng A[]. Nhiệm vụ của bạn là nối N sợi dây thành một sợi sao cho tổng chi phí nối dây là nhỏ nhất. Biết chi phí nối sợi dây thứ i và sợi dây thứ j là tổng độ dài hai sợi dây A[i] và A[j].

**Input:**
- Dòng đầu ghi số bộ test T (T<10). Mỗi bộ test gồm 2 dòng. Dòng đầu tiên là số nguyên N (N ≤ 2*10<sup>6</sup>).
- Dòng tiếp theo gồm N số nguyên dương c[i] (1 ≤ A[i] ≤ 10<sup>9</sup>).

**Output:**
- In ra đáp án của bộ test trên từng dòng, theo modulo 10<sup>9</sup>+7.

**input**
```
1
7
2 4 1 2 10 2 3
```

**output**
```
59
```

### DSA03012 - SẮP ĐẶT XÂU KÝ TỰ 1

Cho xâu ký tự S bao gồm các ký tự in thường. Nhiệm vụ của bạn là kiểm tra xem ta có thể sắp đặt lại các ký tự trong S để hai ký tự giống nhau đều không kề nhau hay không? Đưa ra 1 nếu có thể sắp đặt lại các ký tự trong S thỏa mãn yêu cầu bài toán, ngược lại đưa ra -1.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự S được viết trên một dòng.
- T, S thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤10000.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
geeksforgeeks
bbbabaaacd
bbbbb
```

**output**
```
1
1
-1
```

### DSA03013 - SẮP ĐẶT XÂU KÝ TỰ 2

Cho xâu ký tự S bao gồm các ký tự và số D. Nhiệm vụ của bạn là kiểm tra xem ta có thể sắp đặt lại các ký tự trong S để tất cả các ký tự giống nhau đều có khoảng cách là D hay không? Đưa ra 1 nếu có thể sắp đặt lại các ký tự trong S thỏa mãn yêu cầu bài toán, ngược lại đưa ra -1.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là số D; dòng tiếp theo là xâu S.
- T, S, D thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤10000; 1≤D≤100.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
2
ABB
2
AAA
```

**output**
```
1
-1
```

### DSA03014 - SỐ KHỐI LẬP PHƯƠNG

Một số X được gọi là số khối lập phương nếu X là lũy thừa bậc 3 của số Y (X= Y<sup>3</sup>). Cho số nguyên dương N, nhiệm vụ của bạn là tìm số khối lập phương lớn nhất bằng cách loại bỏ đi các chữ số của N. Ví dụ số 4125 ta có kết quả là 125 = 5<sup>3</sup>.


**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một số tự nhiên N được viết trên một dòng.
- T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤10<sup>18</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng. Nếu không tìm được đáp án in ra -1.

**input**
```
2
4125
976
```

**output**
```
125
-1
```

### DSA03015 - MUA LƯƠNG THỰC

Giả sử bạn là một người nghèo trong địa phương của bạn. Địa phương của bạn có duy nhất một cửa hàng bán lương thực. Cửa hàng của bạn mở cửa tất cả các ngày trong tuần ngoại trừ chủ nhật. Cho bộ ba số N, S, M thỏa mãn ràng buộc sau:

- N : số đơn vị lương thực nhiều nhất bạn có thể mua trong ngày.
- S : số lượng ngày bạn cần được sử dụng lương thực để tồn tại.
- M : số đơn vị lương thực cần có mỗi ngày để bạn tồn tại.

Giả sử bạn đang ở ngày thứ 2 trong tuần và cần tồn tại trong S ngày tới. Hãy cho biết số lượng ngày ít nhất bạn cần phải mua lương thực từ của hàng để tồn tại hoặc bạn sẽ bị chết đói trong S ngày tới.


**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ 3 số N, S, M được viết trên một dòng.
- T, N, S, M thỏa mãn ràng buộc: 1≤T≤100;  1≤N, S, M ≤30.

**Output:**
- Đưa ra số ngày ít nhất bạn có thể mua lương thực để tồn tại hoặc đưa ra -1 nếu bạn bị chết đói.

**input**
```
2
16 10 2
20 10 30
```

**output**
```
2
-1
```

### DSA03016 - SỐ NHỎ NHẤT

Cho hai số nguyên dương S và D, trong đó S là tổng các chữ số và D là số các chữ số của một số. Nhiệm vụ của bạn là tìm số nhỏ nhất thỏa mãn S và D? Ví dụ với S = 9, D = 2 ta có số nhỏ nhất thỏa mãn S và D là 18.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ 2 số S và D được viết trên một dòng.
- T, S, D thỏa mãn ràng buộc: 1≤T≤100;  1≤ S,D≤1000.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng. Nếu không có đáp án, in ra -1.

**input**
```
2
9 2
20 3
```

**output**
```
18
299
```

### DSA03017 - GIÁ TRỊ NHỎ NHẤT CỦA XÂU

Cho xâu ký tự S. Ta gọi giá trị của xâu S là tổng bình phương số lần xuất hiện mỗi ký tự trong S. Hãy tìm giá trị nhỏ nhất của xâu S sau khi thực hiện K lần loại bỏ ký tự.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là số K; phần thứ hai là một xâu ký tự S được viết trên một dòng.
- DT, S, K thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤10000; 1≤K≤1000.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
2
ABCCBC
2
AAAB
```

**output**
```
6
2
```

### DSA03018 - SỐ MAY MẮN

Hoàng yêu thích các số may mắn. Ta biết rằng một số là số may mắn nếu biểu diễn thập phân của nó chỉ chứa các chữ số may mắn là 4 và 7. Ví dụ, các số 47, 744, 4 là số may mắn và 5, 17, 467 không phải. Hoàng muốn tìm số may mắn bé nhất có tổng các chữ số bằng n. Hãy giúp anh ấy

**Input:**
Dòng đầu ghi số bộ test, mỗi bộ test có một dòng chứa số nguyên n (1 ≤ n ≤ 106) — tổng các chữ số của số may mắn cần tìm.

**Output:**
In ra trên 1 dòng số may mắn bé nhất, mà tổng các chữ số bằng n. Nếu không tồn tại số thỏa mãn, in ra -1.

**input**
```
2
11
10
```

**output**
```
47
-1
```

### DSA03019 - PHÂN SỐ ĐƠN VỊ

Một phân số đơn vị nếu tử số của phân số đó là 1. Mọi phân số nguyên dương đều có thể biểu diễn thành tổng các phân số đơn vị. Ví dụ 2/3 = 1/2  + 1/6. Cho phân số nguyên dương P/Q bất kỳ (P < Q), hãy biểu diễn phân số nguyên dương thành tổng phân số đơn vị với số hạng tử là ít nhất.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là bộ đôi tử số P và mẫu số Q của phân số nguyên dương được viết trên một dòng.
- T, P, Q thỏa mãn ràng buộc: 1≤T≤100;  1≤P, Q≤100.

**Output:**
- Đưa ra đáp án tìm được trên 1 dòng, theo dạng “1/a + 1/b + …”

**input**
```
2
2 3
1 3
```

**output**
```
1/2 + 1/6 
1/3
```

### DSA03020 - BIỂU THỨC ĐÚNG

Cho một mảng S gồm 2×N ký tự, trong đó có N ký tự ‘[’ và N ký tự ‘]’. Xâu S được gọi là viết đúng nếu S có dạng S2[S1] trong đó S, S2 là các xâu viết đúng. Nhiệm vụ của bạn là tìm số các phép đổi chỗ ít nhất các ký tự kề nhau của xâu S viết sai để  S trở thành viết đúng. Ví dụ với xâu S =”[]][][” ta có số phép đổi chỗ kề nhau ít nhất là 2.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu S viết sai theo nguyên tắc kể trên.
- T, S thòa mãn ràng buộc: 1≤T≤100; 1≤length(S)≤100000.

**Output:**
- Đưa kết quả trên một dòng.

**input**
```
2
[]][][
[][][]
```

**output**
```
2
0
```

### DSA03021 - TÌM DÃY SỐ

Cho dãy số nguyên A[] gồm có N phần tử. Nhiệm vụ của bạn là tìm dãy số B[] có tổng phần tử nhỏ nhất thỏa mãn tính chất A[i] / B[i] = A[i+1] / B[i+1] với mọi chỉ số i (0 ≤ i ≤ N-2).

Phép chia trong bài toán này là phép chia nguyên (tức là chỉ lấy phần nguyên của kết quả: ví dụ 5/3 = 1).   

**Input:**
- Dòng đầu tiên là số lượng phần tử N (1 ≤ N ≤ 1000).
- Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 2000).

**Output:**
- In ra một số nguyên là tổng các phần tử của dãy số B[] tìm được.

**input**
```
5
18 27 16 22 6
```

**output**
```
25
```

*Giải thích test: Dãy B[] tìm được là 5, 7, 5, 6, 2.*

### DSA03022 - TÍCH LỚN NHẤT

Cho dãy số A gồm N phần tử là các số nguyên. Hãy tính tích lớn nhất của **2 hoặc 3** phần tử trong dãy.

**Input:**
- Dòng đầu tiên ghi số N (3 ≤ N ≤ 10000)
- Dòng thứ 2 ghi N số của dãy A (|A<sub>i</sub>| ≤ 1000)

**Output:**
- Ghi ra kết quả trên một dòng

**input**
```
6
5 10 -2 3 5 2
```

**output**
```
250
```

### DSA03023 - SẮP XẾP VIÊN BI

Cho một dãy N viên bi gồm 3 màu xanh, trắng, đỏ xếp lẫn lộn. Bằng cách đổi chỗ từng cặp viên bi cho nhau có thể xếp lại dãy bi trên sao cho các viên bi xanh đứng trước, sau đó đến các viên bi trắng và cuối cùng là các viên bi đỏ. Tìm số lượng ít nhất các phép đổi chỗ cần thực hiện

**Input:**
- Dòng đầu  tiên ghi N (N≤100)
- Dòng thứ hai ghi xâu ký tự mô tả dãy bi (T-trắng, X-xanh, D-đỏ).

**Output:**
- Một dòng duy nhất ghi số phép đổi chỗ tối thiểu cần thực hiện

**input**
```
9
TTXDDDTDX
```

**output**
```
4
```

### DSA03024 - LỰA CHỌN TỐI ƯU

Bạn được giao cho N công việc, công việc thứ i có thời gian bắt đầu là A[i] và kết thúc tại B[i]. Tại một thời điểm, bạn chỉ có thể làm một công việc.

Bạn hãy lựa chọn các công việc một cách tối ưu sao cho số công việc làm được là nhiều nhất.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm 1 số nguyên N ( 1 ≤ N ≤ 100 000).
- N dòng tiếp theo, mỗi dòng gồm 2 số A[i] và B[i] (0 ≤ A[i] < B[i] ≤ 10<sup>6</sup>).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
1
6
5 9
1 2
3 4
0 6
5 7
8 9
```

**output**
```
4
```

*Giải thích test: Lựa chọn công việc 2, 3, 5, 6.*

### DSA03025 - TRỤC TỌA ĐỘ

Trên trục Ox tính từ vị trí 0, người ta muốn xếp nhiều nhất các đoạn thẳng sao cho không đoạn nào chồng lấn lên nhau. Đoạn thẳng thứ i có vị trí bắt đầu là X1[i] và kết thúc tại X2[i], với X1[i] <= X2[i].

Hãy tính số đoạn thẳng nhiều nhất có thể được lựa chọn để đưa lên trục Ox và không có đoạn nào chồng lấn lên nhau.

**Input:**
- Dòng đầu tiên ghi số bộ test, không quá 10.
- Với mỗi bộ test: dòng đầu ghi số N là số đoạn thẳng (không quá 10<sup>5</sup>)
- Tiếp theo là N dòng, mỗi dòng có 2 số nguyên mô tả đoạn thẳng. Các giá trị tọa độ đều là các số nguyên không âm và không quá 10<sup>6</sup>.

**Output:**
- Với mỗi test, viết trên 1 dòng số lượng đoạn thẳng nhiều nhất có thể được lựa chọn thỏa mãn điều kiện đề bài.

**input**
```
1
10
39 55
37 74
0 1
19 25
65 76
51 52
19 21
5 94
46 65
32 40
```

**output**
```
5
```

### DSA03026 - LỰA CHỌN THAM LAM

Cho hai số nguyên dương N và S. Hãy lựa chọn các chữ số phù hợp để tạo ra số nhỏ nhất và số lớn nhất có N chữ số sao cho tổng chữ số đúng bằng S.

**Input:**

Chỉ có một dòng ghi hai số N và S. (0 < N <= 100; 0 <= S <= 900)

**Output:**

Ghi ra hai số nhỏ nhất và lớn nhất tìm được, cách nhau một khoảng trống.

Nếu không thể tìm được thì ghi ra “-1 -1”


**input**
```
3 20
________________________________________________________________
2 900
________________________________________________________________
3 0
```

**output**
```
299 992
________________________________________________________________
-1 -1
________________________________________________________________
-1 -1
```

### DSA03027 - GIÁ TRỊ LỚN NHẤT

Cho dãy số nguyên A[] có N phần tử.
- Gọi f(i,j) = |a<sub>i</sub>| + |a<sub>i+1</sub>| + … + |a<sub>j</sub>|
- Gọi g(i,j) = a<sub>i</sub> + a<sub>i+1</sub> + … + a<sub>j</sub>

Với tất cả các cặp 1 ≤ i ≤ j ≤ N.

Hãy tính giá trị lớn nhất của f(i,j) + g(i,j).

**Input:**
- Dòng đầu ghi số N (1 ≤ N ≤ 50000)
- Dòng thứ 2 ghi N số nguyên của dãy A[]

**Output:**
- Ghi ra giá trị lớn nhất của f(i,j) + g(i,j)

**input**
```
5
-3 5 -10 8 -2
```

**output**
```
26
```

### DSA03033 - ATM THẾ HỆ MỚI

Tại một cây rút tiền ATM thế hệ mới, Tý muốn rút ra W đồng. Các tờ tiền trong máy ATM có mệnh giá từ 1000, 2000, 3000, 5000, 1000 * 10, 2000 * 10, 3000 * 10, 5000 * 10, …, 1000 * 10<sup>c</sup>, 2000 * 10<sup>c</sup>, 3000 * 10<sup>c</sup>, 5000 * 10<sup>c</sup>.

Chiếc máy ATM đã được tối ưu hóa sao cho số lượng tờ tiền đưa ra cho khách hàng là nhỏ nhất.

Các bạn hãy thử tính xem Tý sẽ nhận được bao nhiêu tờ tiền? Và có bao nhiêu cách thỏa mãn?

**Input:**
- Số đầu tiên là số lượng bộ test T (T ≤ 1000). Mỗi test gồm 2 dòng:
- Dòng thứ nhất chứa số nguyên W.
- Dòng thứ hai chứa số nguyên c.

**Output:**
- Với mỗi test, hãy in ra số lượng tờ tiền nhỏ nhất mà máy ATM sinh ra và số tổ hợp các tờ tiền khác nhau thỏa mãn tổng giá trị của chúng bằng W.
- Nếu không có đáp án, in ra số 0 trên một dòng.

**input**
```
4
2000
1
7000
1
1500
1
110000
1
```

**output**
```
1 1
2 1
0
3 2
```
Subtask 1: 30% số test đầu tiên, c ≤ 5, W ≤ 10<sup>9</sup>.

Subtask 2: 70% số test còn lại, c ≤ 15, W ≤ 10<sup>18</sup>.

*Giải thích test 4: 2 cách tìm được là: 50000+50000+10000 và 50000+30000+30000*

### DSA03034 - DÃY CON CHUNG -- DSA06040 - GIAO CỦA BA DÃY SỐ

Cho dãy số A[], B[] và C[] là dãy không giảm và có lần lượt N, M, K phần tử. Nhiệm vụ của bạn là hãy tìm các phần tử chung của 3 dãy số này.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên N, M và K (1≤ N, M, K ≤ 100 000).
- Dòng tiếp theo gồm N số nguyên A[i], rồi M số nguyên B[i] và K số nguyên C[i]. (0 ≤ A[i], B[i], C[i] ≤ 10<sup>9</sup>).

**Output:**
- Với mỗi test, in ra trên một dòng là đáp án thu được. Nếu không tìm được đáp án, in ra “NO”.

**input**
```
3
6 5 8
1 5 10 20 40 80
5 7 20 80 100
3 4 15 20 30 70 80 120
3 5 4
1 5 5
3 4 5 5 10
5 5 10 20
3 3 3
1 2 3
4 5 6
7 8 9
```

**output**
```
20 80
5 5
NO
```

### DSA03035 - SẮP XẾP ĐƠN GIẢN

Cho một dãy số a[] có n phần tử gồm các số từ 1 đến n theo 1 thứ tự ngẫu nhiên. Nhiệm vụ của bạn là sắp xếp lại dãy số này theo thứ tự tăng dần với điều kiện : ở mỗi bước sắp xếp, bạn chỉ được chọn 1 số ở 1 vị trí bất kì và chuyển số đó lên đầu dãy hoặc về cuối dãy.

Hãy tính số bước tối thiểu cần thực hiện để hoàn thành việc sắp xếp.

**Input:**
- Dòng đầu tiên ghi 1 số n: số lượng phần tử của dãy a (1 ≤ n ≤ 100000)
- Dòng tiếp theo gồm n số từ 1 đến n theo thứ tự ngẫu nhiên

**Output:**
- Một số nguyên duy nhất là số bước tối thiểu cần thực hiện để hoàn thành việc sắp xếp.

**input**
```
5
4 1 2 5 3
```

**output**
```
2
```

## Divide and Conquer

### DSA04001 - LŨY THỪA

Cho số nguyên dương N và K. Hãy tính NK modulo 10<sup>9</sup>+7.

**Input:**

Dòng đầu tiên là số lượng bộ test T (T ≤ 20).

Mỗi test gồm 1 số nguyên N và K (1 ≤ N ≤ 1000, 1 ≤ K ≤ 10<sup>9</sup>).

**Output:**

Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
2 3
4 2
```

**output**
```
8
16
```

### DSA04002 - LŨY THỪA ĐẢO

Cho mảng số N. Ta gọi số đảo của N là R. Hãy tìm lũy thừa R của N. Đưa ra kết quả của bài toán dưới dạng modulo với 10<sup>9</sup> + 7.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm là số N được ghi trên một dòng.
- T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤10<sup>10</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
2
12
```

**output**
```
4
864354781
```

### DSA04003 - ĐẾM DÃY

Cho số nguyên dương n. Hãy cho biết có bao nhiêu dãy số nguyên dương có tổng các phần tử trong dãy bằng n. 

**Dữ liệu vào:** dòng đầu tiên chứa số nguyên T là số bộ dữ liệu, mỗi bộ dữ liệu ghi một số nguyên dương n duy nhất không qua 1018. 

**Kết quả:** Mỗi bộ dữ liệu ghi ra một số nguyên duy nhất là số dư của kết quả tìm được khi chia cho 123456789.

**input**
```
1
3
```

**output**
```
4
```

### DSA04004 - GẤP ĐÔI DÃY SỐ

Một dãy số tự nhiên bắt đầu bởi con số 1 và được thực hiện N-1 phép biến đổi “gấp đôi” dãy số như sau:

Với dãy số A hiện tại, dãy số mới có dạng A, x, A trong đó x là số tự nhiên bé nhất chưa xuất hiện trong A.

Ví dụ với 2 bước biến đổi, ta có [1] - [1 2 1] - [1 2 1 3 1 2 1].

Các bạn hãy xác định số thứ K trong dãy số cuối cùng là bao nhiêu?

**Input:**

Dòng đầu tiên là số lượng bộ test T (T ≤ 20).

Mỗi test gồm số nguyên dương N và K (1 ≤ N ≤ 50, 1 ≤ K ≤ 2N - 1).

**Output:**

Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
3 2
4 8
```

**output**
```
2
4
```

### DSA04005 - DÃY XÂU FIBONACI

Một dãy xâu ký tự G chỉ bao gồm các chữ cái A và B được gọi là dãy xâu Fibonacci nếu thỏa mãn tính chất:    G(1) = A; G(2) = B; G(n) = G(n-2)+G(n-1). Với phép cộng (+) là phép nối hai xâu với nhau.  Bài toán đặt ra là tìm ký tự ở vị trí thứ i (tính từ 1) của xâu Fibonacci thứ n.

**Dữ liệu vào:** Dòng 1 ghi số bộ test. Mỗi bộ test ghi trên một dòng 2 số nguyên N và i (1<N<93). Số i đảm bảo trong phạm vi của xâu G(N) và không quá 18 chữ số. 

**Kết quả:** Ghi ra màn hình kết quả tương ứng với từng bộ test.

**input**
```
2
6 4
8 19
```

**output**
```
A
B
```

### DSA04006 - ĐẾM SỐ BÍT 1

Cho số nguyên dương N. Mỗi bước, bạn sẽ biến đổi N thành [N/2], N mod 2, [N/2]. Sau khi thực hiện một cách triệt để, ta thu được một dãy số chỉ toàn số 0 và 1.

Nhiệm vụ của bạn là hãy đếm các số bằng 1 trong đoạn [L, R] của dãy số cuối cùng.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 3 số nguyên N, L, R (1 ≤ N, L, R < 2<sup>50</sup>, 0 ≤ R-L ≤ 100 000).

**Output:** 
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
7 2 5
10 3 10
```

**output**
```
4
5
```

Giải thích test 1: [7] à [3, 1, 3] à [1, 1, 1, 1, 3] à [1, 1, 1, 1, 1, 1, 1].

Giải thích test 2: Dãy số sau khi biến đổi là [1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1].

### DSA04007 - HỆ CƠ SỐ K

Cho hai số A, B ở hệ cơ số K. Hãy tính tổng hai số đó ở hệ cơ số K.

**Input:**
- Dòng đầu ghi số bộ test T (T<10). Mỗi bộ test ghi 3 số K,A,B.
- 2≤K≤10; A và B nếu biểu diễn trong hệ cơ số 10 đều nhỏ hơn 10<sup>9</sup>

**Output:**
- In ra tổng của A và B trong hệ cơ số K

**input**
```
1
2 1 10
```

**output**
```
11
```

### DSA04008 - SỐ FIBONACCI THỨ N

Dãy số Fibonacci được xác định bằng công thức như sau:

F[0] = 0, F[1] = 1;

F[n] = F[n-1] + F[n-2] với mọi n >= 2.

Các phần tử đầu tiên của dãy số là 0, 1, 1, 2, 3, 5, 8, ...

Nhiệm vụ của bạn là hãy xác định số Fibonaci thứ n. Do đáp số có thể rất lớn, in ra kết quả theo modulo 10<sup>9</sup>+7.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 1000).
- Mỗi test bắt gồm một số nguyên N (1 ≤ N ≤ 10<sup>9</sup>).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
3
2
6
20
```

**output**
```
1
8
6765
```

### DSA04009 - LŨY THỪA MA TRẬN 1

Cho ma trận vuông A kích thước N x N. Nhiệm vụ của bạn là hãy tính ma trận X = A<sup>K</sup> với K là số nguyên cho trước. Đáp số có thể rất lớn, hãy in ra kết quả theo modulo 10<sup>9</sup>+7.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 100).
- Mỗi test bắt gồm một số nguyên N và K (1 ≤ N ≤ 10, 1 ≤ K ≤ 10<sup>9</sup>) là kích thước của ma trận và số mũ.

**Output:**
- Với mỗi test, in ra kết quả của ma trận X.

**input**
```
2
2 5
1 1
1 0
3 1000000000
1 2 3
4 5 6
7 8 9
```

**output**
```
8 5
5 3
597240088 35500972 473761863
781257150 154135232 527013321
965274212 272769492 580264779
```

### DSA04010 - DÃY CON LIÊN TIẾP CÓ TỔNG LỚN NHẤT

Cho mảng A[] gồm N số có cả các số âm và số dương. Nhiệm vụ của bạn là tìm mảng con liên tục có tổng lớn nhất của mảng. Ví dụ với mảng A[]={-2, -5, 6, -2,-3, 1, 5, -6} ta có kết quả là 7 tương ứng với dãy con {6, -2, -3, 1, 5}.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào hai số N tương ứng với số phần tử của mảng; dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤100; -100≤A[i] ≤100.

**Output:**
- Đưa ra tổng con liên tục lớn nhất của mỗi test theo từng dòng.

**input**
```
1
8
-2 -5 6 -2 -3 1 5 -6
```

**output**
```
7
```

### DSA04011 - TÍCH HAI SỐ NHỊ PHÂN

Cho hai xâu nhị phân biểu diễn hai số. Nhiệm vụ của bạn là đưa ra tích của hai số. Ví dụ với xâu S1=”1100” và S2=”1010” ta sẽ có kết quả là 120.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 hai xâu nhị phân S1, S2 được viết trên một dòng.
- T, S1, S2 thỏa mãn ràng buộc: 1≤T≤100;  1≤ length(S1), length(S2)≤30.

**Output:**
- Đưa ra tích của mỗi test theo từng dòng.

**input**
```
2
1100 01
01 01
```

**output**
```
12
1
```

### DSA04012 - TÍCH ĐA THỨC

Cho hai đa thức P và Q được biểu diễn như một mảng bao gồm các hệ số của đa thức. Ví dụ với P(x) = 5 + 0x<sup>1</sup> +10x<sup>2</sup> + 6x<sup>3</sup> được biểu diễn như mảng P[] ={5, 0, 10, 6}. Hãy đưa ra đa thức R = P×Q theo các hệ số của R với cách biểu diễn như trên.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào hai số M, N tương ứng với lũy thừa lớn nhất của đa thức P và Q; dòng tiếp theo đưa vào M số là hệ số của đa thức P; dòng cuối cùng đưa vào M số là hệ số của đa thức Q.
- T, M, N, P[i], Q[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤M, N≤100; 1≤P[i], Q[i]≤100.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4 3
1 0 3 2
2 0 4
5 4
1 9 3 4 7
4 0 2 5
```

**output**
```
2 0 10 4 12 8
4 36 14 39 79 23 34 35
```

### DSA04013 - SẮP XẾP KANGURU

Có N con kanguru trong vườn thú, con thứ i có chiều cao bằng A[i]. Con kanguru có chiều cao X có thể chứa được một con có chiều cao bằng Y trong túi của nó nếu như X >= 2*Y.

Một con đã chứa một con kanguru rồi, thì không thể nhảy vào túi một con kanguru khác.

Bầy Kanguru rất thích chơi trốn tìm, vì vậy chúng thường xuyên nhảy vào túi của nhau. Các bạn hãy tính toán xem trong trường hợp tối ưu, số con kanguru nhìn thấy trong vườn thú ít nhất bằng bao nhiêu?

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên N (1 ≤ N ≤ 100 000).
- Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 100 000).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
8
2 5 7 6 9 8 4 2
8
9 1 6 2 6 5 8 3
```

**output**
```
5
5
```

Giải thích test 1: Nhóm 2 – 5, 2 – 6, 4 – 8, 7, 9.

### DSA04014 - CẶP NGHỊCH THẾ

Cho mảng A[] gồm N phần. Ta gọi cặp nghịch thế của mảng A[] là số các cặp i, j sao cho i<j và A[i]>A[j]. Đối với mảng đã được sắp xếp thì số cặp nghịch thế bằng 0. Mảng đã sắp theo thứ tự giảm dần có số đảo ngược cực đại. Nhiệm vụ của bạn là hãy đưa ra số cặp nghịch thế của mảng A[] gồm N phần tử.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N tương ứng với số phần tử của mảng A[]; phần thứ 2 là N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤10<sup>7</sup>; 1≤A[i]≤10<sup>18</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5
2 4 1 3 5
5
5 4 3 2 1
```

**output**
```
3
10
```

### DSA04015 - TÍNH FLOOR(X)

Cho mảng đã được sắp xếp A[] gồm N phần tử không có hai phần tử giống nhau và số X. Nhiệm vụ của bạn là tìm floor(X). Trong đó, K=floor(X) là phần tử lớn nhất trong mảng A[] nhỏ hơn hoặc bằng X.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số N là số phần tử của mảng A[] và số X; dòng tiếp theo đưa vào N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤10<sup>7</sup>; 1≤ A[i]≤10<sup>18</sup>.

**Output:**
- Đưa ra vị trí của  floor(X) trong mảng A[] hoặc -1 nếu không tồn tại floor(X) của mỗi test theo từng dòng.


**input**
```
3
7 0
1 2 8 10 11 12 19
7 5
1 2 8 10 11 12 19
7 10
1 2 8 10 11 12 19
```

**output**
```
-1
2
4
```

### DSA04016 - PHẦN TỬ THỨ K

Cho hai mảng đã được sắp xếp A[], B[] gồm M, N phần tử theo thứ tự và số K. Nhiệm vụ của bạn là tìm phần tử ở vị trí số K sau khi trộn hai mảng để nhận được một mảng được sắp xếp.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số M, N, K; dòng tiếp theo đưa vào M số của mảng A[];dòng tiếp theo đưa vào N số của mảng B[];các số được viết cách nhau một vài khoảng trống.
- T, M,N, A[i], B[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N, A[i], B[i]≤10<sup>6</sup>; 1≤ K≤N+M.

**Output:**
- Đưa ra giá trị phần tử thứ K của mỗi test theo từng dòng.

**input**
```
1
5 4 5
2 3 6 7 9
1 4 8 10
```

**output**
```
6
```

### DSA04017 - PHẦN TỬ KHÁC NHAU

Cho hai mảng đã được sắp xếp A[] và B[] gồm N và N-1 phần tử. Các phần tử của mảng A[] chỉ khác mảng B[] một phần tử duy nhất. Hãy tìm vị trí của phần tử khác nhau giữa A[] và B[].

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng thứ nhất đưa vào số N; dòng tiếp theo đưa vào N số của mảng A[];dòng tiếp theo đưa vào N-1 số của mảng B[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i], B[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤10<sup>7</sup>; 0≤ A[i]≤10<sup>18</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
7
2 4 6 8 9 10 12
2 4 6 8 10 12
6
3 5 7 9 11 13
3 5 7 11 13
```

**output**
```
5
4
```

### DSA04018 - ĐẾM SỐ 0

Cho mảng A[] gồm N phần tử chỉ bao gồm các số 0 và 1. Các số 0 được đặt trước các số 1. Hãy đếm các số 0 với thời gian log(N).

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số N; dòng tiếp theo đưa vào N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤1000; 0≤ A[i]≤1.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
12
0 0 0 0 0 0 0 0 0 1 1 1 
5
0 0 0 0 0
6
1 1 1 1 1 1
```

**output**
```
9
5
0
```

### DSA04019 - CẶP ĐIỂM GẦN NHẤT

Cho N điểm trên mặt phẳng tọa độ Oxy. Bạn cần tìm khoảng cách ngắn nhất giữa hai điểm trong số N điểm đã cho.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi một số nguyên N (1 ≤ N ≤ 100 000).
- N dòng tiếp theo, mỗi dòng gồm 2 số nguyên X[i], Y[i] (-10<sup>6</sup> ≤ X[i], Y[i] ≤ 10<sup>6</sup>).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng với độ chính xác 6 chữ số sau dấu phẩy.

**input**
```
2
6
2 3
12 30
40 50
5 1
12 10
3 4
3
0 0
3 0
4 0
```

**output**
```
1.414214
1.000000
```

### DSA04020 - TÌM KIẾM NHỊ PHÂN

Cho dãy số A[] gồm có N phần tử đã được sắp xếp tăng dần và số K.

Nhiệm vụ của bạn là kiểm tra xem số K có xuất hiện trong dãy số hay không. Nếu có hãy in ra vị trí trong dãy A[], nếu không in ra “NO”.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test bắt đầu bằng số nguyên N và K (N ≤ 100 000, 0 ≤ K ≤ 10<sup>6</sup>).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10<sup>6</sup>), các phần tử là riêng biệt.

**Output:**
- Với mỗi test in ra trên một dòng đáp án tìm được.

**input**
```
2
5 3
1 2 3 4 5
6 5
0 1 2 3 9 10
```

**output**
```
3
NO
```

### DSA04021 - DÃY XÂU NHỊ PHÂN

Người ta tạo ra một dãy xâu ký tự nhị phân X[] trong đó:

X[1] = “0”

X[2] = “1”

X[i] = X[i-2] + X[i-1] với i>2

Với phép cộng (+) là phép nối hai xâu với nhau. 

Cho hai số tự nhiên N và K (1<N<93; K đảm bảo trong phạm vi của xâu X[N]).

Hãy xác định ký tự thứ K trong xâu X[N] là ký tự ‘0’ hay ký tự ‘1’.

**Input:** Dòng 1 ghi số bộ test. Mỗi bộ test ghi trên một dòng 2 số nguyên N và K.

**Output:** Ghi ra màn hình kết quả tương ứng với từng bộ test.

**input**
```
2
3 1
4 3
```

**output**
```
0
1
```

### DSA04022 - KÝ TỰ THỨ K TRONG XÂU

Xâu ký tự S được tạo ra bằng cách bổ sung dần các ký tự chữ cái Tiếng Anh in hoa như sau.

- Bước 1: Chỉ có chữ cái A
- Bước 2: Thêm chữ cái B vào giữa 2 chữ A => S = "ABA"
- Bước 3: Thêm chữ cái C vào giữa 2 xâu đã có ở bước 2: S = "ABACABA"

Cứ như vậy cho đến bước thứ N (0 < N < 26)

Hãy xác định ký tự thứ K trong bước biến đổi thứ N là chữ cái gì?

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên dương N và K (1 ≤ N ≤ 25, 1 ≤ K ≤ 2N - 1).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
3 2
4 8
```

**output**
```
B
D
```

### DSA04023 - KHOẢNG CÁCH NHỎ HƠN K

Cho mảng A[] gồm n số nguyên dương và số K. Hãy đếm số các cặp phần tử có hiệu nhỏ hơn K. Ví dụ A[] = {1, 10, 4, 2 }, K=3 ta nhận được kết quả là 2 tương ứng với các cặp (1, 2), (4, 2).

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Mỗi bộ test gồm hai dòng: dòng đầu tiên ghi số n và số K; dòng tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
- T, n, k, A[i] thỏa mãn ràng buộc: 1 ≤ T ≤ 100; 1 ≤ n ≤ 10<sup>4</sup>; 1 ≤ k ≤ 10<sup>3</sup>; 1 ≤ A[i] ≤ 10<sup>5</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4 3
1 10 4 2
3 5
2 3 4
```

**output**
```
2
3
```

### DSA04024 - LŨY THỪA MA TRẬN 2

Cho ma trận vuông A kích thước N x N. Nhiệm vụ của bạn là hãy tính ma trận X = AK với K là số nguyên cho trước. Sau đó, tính tổng các phần tử của cột cuối cùng. Đáp số có thể rất lớn, hãy in ra kết quả theo modulo 10<sup>9</sup>+7.

**Input:**

Dòng đầu tiên là số lượng bộ test T (T ≤ 100).

Mỗi test bắt gồm một số nguyên N và K (1 ≤ N ≤ 10, 1 ≤ K ≤ 10<sup>9</sup>) là kích thước của ma trận và số mũ.

**Output:** 

Với mỗi test, in ra kết quả của ma trận X.

**input**
```
2
2 5
1 1
1 0
3 1000000000
1 2 3
4 5 6
7 8 9
```

**output**
```
8
581039956
```

### DSA04025 - DÃY SỐ VÔ HẠN

Dãy số nguyên dương vô hạn A[] được định nghĩa một cách đệ quy như sau:

A[0] = 0

A[1] = 1;

A[i] = A[i-1] + A[i-2] với mọi n ≥ 2.

Cho số nguyên dương N không quá 109. Hãy xác định số thứ N trong dãy A[]. Nếu kết quả quá lớn, hãy in ra theo modulo 10<sup>9</sup>+7.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 1000).
- Mỗi test bắt gồm một số nguyên N (1 ≤ N ≤ 10<sup>9</sup>).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
2
6
```

**output**
```
1
8
```

### DSA04030 - SỐ TRIBONACCI

Dãy số Tribonacci được xây dựng như sau:

T(i) = i với i ≤ 3.

T(i) = T(i-1) + T(i-2) + T(i-3) với i ≥ 4.

Nhiệm vụ của bạn là hãy tính tổng N phần tử đầu tiên của dãy số này.

F(N) = T(1) + T(2) + …+ T(N)

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 100).
- Mỗi test gồm một số nguyên dương N (N ≤ 10<sup>9</sup>).

**Output:**
- Với mỗi test, in ra đáp án tìm được theo modulo 10<sup>15</sup>+7.

**input**
```
5
1
2
3
4
5
```

**output**
```
1
3
6
12
23
```

### DSA04035 - TÍNH LŨY THỪA

Cho hai số nguyên không âm a và b. Hãy tính ab.

Nếu kết quả quá lớn hãy chia dư cho 10<sup>9</sup> + 7.

**Input**

Gồm không quá 20 bộ test, mỗi test ghi trên một dòng hai số a,b; a không quá 9 chữ số, b không quá 18 chữ số.

Input kết thúc khi a = b = 0

**Output**

Với mỗi test ghi ra kết quả tính được trên một dòng.

**input**
```
2 3
2 4
3 2
0 0
```

**output**
```
8
16
9
```

## Dynamic Programming

### DSA05001 - XÂU CON CHUNG DÀI NHẤT

Cho 2 xâu S1 và S2. Hãy tìm xâu con chung dài nhất của 2 xâu này *(các phần tử không nhất thiết phải liên tiếp nhau).*

**Input:** 
Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test gồm hai dòng, mô tả xâu S1 và S2, mỗi xâu có độ dài không quá 1000 và chỉ gồm các chữ cái in hoa.

**Output:** 
Với mỗi test, in ra độ dài dãy con chung dài nhất trên một dòng.

**input**
```
2
AGGTAB
GXTXAYB
AA
BB
```

**output**
```
4
0
```

### DSA05003 - DÃY CON CHUNG DÀI NHẤT CỦA BA XÂU

Cho ba xâu ký tự X, Y, Z. Nhiệm vụ của bạn là tìm độ dài dãy con chung dài nhất có mặt trong cả ba xâu.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào độ dài xâu X, Y, X; dòng tiếp theo đưa vào ba xâu X, Y, Z.
- T, X, Y, Z thỏa mãn ràng buộc: 1 ≤ T ≤ 100;  1 ≤ size(X), size(Y), size(Z) ≤ 100.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5 8 13
geeks geeksfor geeksforgeeks
7 6 5
abcd1e2 bc12ea bd1ea
```

**output**
```
5
3
```

### DSA05004 - DÃY CON TĂNG DÀI NHẤT

Cho một dãy số nguyên gồm N phần tử A[1], A[2], ... A[N]. 

Biết rằng dãy con tăng là 1 dãy A[i1],... A[ik] thỏa mãn i1 < i2 < ... < ik và A[i1] < A[i2] < .. < A[ik].

Hãy cho biết dãy con tăng dài nhất của dãy này có bao nhiêu phần tử? 

**Input:**
Dòng 1 gồm 1 số nguyên là số N (1 ≤ N ≤ 1000). Dòng thứ 2 ghi N số nguyên A[1], A[2], .. A[N] (1 ≤ A[i] ≤ 1000). 

**Output:**
Ghi ra độ dài của dãy con tăng dài nhất.

**input**
```
6
1 2 5 4 6 2
```

**output**
```
4
```

### DSA05005 - SỐ BƯỚC ÍT NHẤT

Cho mảng A[] gồm N số nguyên. Nhiệm vụ của bạn là sắp xếp lại mảng số với số lượng bước là ít nhất. Tại mỗi bước, bạn chỉ được phép chèn phần tử bất kỳ của mảng vào vị trí bất kỳ trong mảng. Ví dụ A[] = {2, 3, 5, 1, 4, 7, 6 }sẽ cho ta số phép chèn ít nhất là 3 bằng cách lấy số 1 chèn trước số 2, lấy số 4 chèn trước số 5, lấy số 6 chèn trước số 7 ta nhận được mảng được sắp.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là một số N; dòng tiếp theo đưa vào N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤1000; 1≤A[i] ≤1000.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
7
2 3 5 1 4 7 6
```

**output**
```
3
```

### DSA05006 - TỔNG LỚN NHẤT CỦA DÃY CON TĂNG DẦN

Cho dãy số A[] gồm N số. Nhiệm vụ của bạn là tìm tổng lớn nhất của dãy con được sắp theo thứ tự tăng dần của dãy A[]. Ví dụ với dãy A[] = {1, 101, 2, 3, 100, 4, 5} ta có kết quả là 106 = 1 + 2 + 3 + 100. Với dãy A[] = {10, 7, 5} ta có kết quả là 10. Với dãy A[] = {1, 2, 3, 5} ta có kết quả là 11.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào N là số phần tử của dãy A[]; dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤10<sup>3</sup>; 0≤A[i] ≤10<sup>3</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
7
1 101 2 3 100 4 5
3
10 7 5
4
1 2 3 5
```

**output**
```
106
10
11
```

### DSA05007 - TỔNG LỚN NHẤT CỦA DÃY CON KHÔNG KỀ NHAU -- DSAKT110 - NHÀ KHÔNG KỀ NHAU

Có N ngôi nhà trên một dãy phố, mỗi ngôi nhà chứa đựng một số lượng tài sản khác nhau. Một tên trộm muốn ăp cắp được nhiều nhất tài sản của dãy phố nhưng không muốn lấy tài sản của hai nhà kề nhau. Hãy cho biết, bằng cách đó tên trộm có thể đánh cắp được nhiều nhất bao nhiêu tài sản.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất là một số N là số lượng ngôi nhà; dòng tiếp theo đưa vào N số là tài sản tương ứng trong mỗi ngôi nhà; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤10<sup>6</sup>; 1≤A[i] ≤10<sup>7</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
6
5 5 10 100 10 5
4
3 2 7 10
```

**output**
```
110
13
```

### DSA05008 - DÃY CON CÓ TỔNG BẰNG S

Cho N  số nguyên dương tạo thành dãy A={A1, A2, ..., AN}. Tìm ra một dãy con của dãy A (không nhất thiết là các phần tử liên tiếp trong dãy) có tổng bằng S cho trước.

**Input:** 
Dòng đầu ghi số bộ test T (T<10).  Mỗi bộ test có hai dòng, dòng đầu tiên ghi hai số nguyên dương N và S (0 < N ≤ 200) và S (0 < S ≤ 40000). Dòng tiếp theo lần lượt ghi N số hạng của dãy A là các số A1, A2, ..., AN (0 < Ai ≤ 200).

**Output:** 
Với mỗi bộ test, nếu bài toán vô nghiệm thì in ra “NO”, ngược lại in ra “YES”

**input**
```
2
5 6
1 2 4 3 5
10 15
2 2 2 2 2 2 2 2 2 2
```

**output**
```
YES
NO
```

### DSA05012 - TỔ HỢP C(n, k)

Cho 2 số nguyên n, k. Bạn hãy tính C(n, k) modulo 10<sup>9</sup>+7.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 2 số nguyên n, k (1 ≤ k ≤ n ≤ 1000).

**Output:**
- Với mỗi test, in ra đáp án trên một dòng.

**input**
```
2
5 2
10 3
```

**output**
```
10
120
```

### DSA05013 - BẬC THANG -- DSA05034 - TỔNG SỐ CÁCH DI CHUYỂN

Một chiếc cầu thang có N bậc. Mỗi bước, bạn được phép bước lên trên tối đa K bước. Hỏi có tất cả bao nhiêu cách bước để đi hết cầu thang? (Tổng số bước đúng bằng N).

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 100).
- Mỗi test gồm hai số nguyên dương N và K(1 ≤ N ≤ 100000, 1 ≤ K ≤ 100).

**Output:**
- Với mỗi test, in ra đáp án tìm được trên một dòng theo modulo 10<sup>9</sup>+7.

**input**
```
2
2 2
4 2
```

**output**
```
2
5
```

### DSA05017 - DÃY SỐ BI-TONIC

Một dãy số được gọi là Bi-tonic nếu nó được chia thành hai dãy đầu tăng dần và dãy tiếp theo giảm dần. Nhiệm vụ của bạn là tìm tổng lớn nhất dãy con Bi-tonic của dãy số A[]. Ví dụ với dãy A[] = {1, 15, 51, 45, 33, 100, 12, 18, 9} ta có kết quả là 194 tương ứng với dãy Bi-tonic {1, 15, 51, 100, 18, 9}.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào N là số phần tử của dãy A[]; dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤100; 0≤A[i] ≤100.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
6
80 60 30 40 20 10
9
1 15 51 45 33 100 12 18 9
```

**output**
```
210
194
```

### DSA05018 - XÂU CON ĐỐI XỨNG DÀI NHẤT

Cho xâu S chỉ bao gồm các ký tự viết thường và dài không quá 1000 ký tự.

Hãy tìm xâu con đối xứng dài nhất của S.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm một xâu S có độ dài không vượt quá 1000, chỉ gồm các kí tự thường.

**Output:** 
- Với mỗi test, in ra đáp án tìm được.

**input**
```
2
abcbadd
aaaaa
```

**output**
```
5
5
```

### DSA05019 - HÌNH VUÔNG LỚN NHẤT

Cho một bảng số N hàng, M cột chỉ gồm 0 và 1. Bạn hãy tìm hình vuông có kích thước lớn nhất, sao cho các số trong hình vuông toàn là số 1.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test bắt đầu bởi 2 số nguyên N, M (1 ≤ N, M ≤ 500).
- N dòng tiếp theo, mỗi dòng gồm M số mô tả một hàng của bảng.

**Output:** 
- Với mỗi test, in ra đáp án là kích thước của hình vuông lớn nhất tìm được trên một dòng.

**input**
```
2
6 5
0 1 1 0 1
1 1 0 1 0
0 1 1 1 0
1 1 1 1 0
1 1 1 1 1
0 0 0 0 0
2 2
0 0
0 0
```

**output**
```
3
0
```

### DSA05020 - ĐƯỜNG ĐI NHỎ NHẤT

Cho bảng A[] kích thước N x M (N hàng, M cột). Bạn được phép đi xuống dưới, đi sang phải và đi xuống ô chéo dưới. Khi đi qua ô (i, j), điểm nhận được bằng A[i][j].

Hãy tìm đường đi từ ô (1, 1) tới ô (N, M) sao cho tổng điểm là nhỏ nhất.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên dương N và M.
- N dòng tiếp theo, mỗi dòng gồm M số nguyên A[i][j] (0 ≤ A[i] ≤ 1000).

**Output:** 
- Với mỗi test, in ra độ dài dãy con tăng dài nhất trên một dòng.

**input**
```
1
3 3
1 2 3
4 8 2
1 5 3
```

**output**
```
8
```

### DSA05022 - KÝ TỰ GIỐNG NHAU

Giả sử bạn cần viết N ký tự giống nhau lên màn hình. Bạn chỉ được phép thực hiện ba thao tác dưới đây với chi phí thời gian khác nhau:

- Thao tác insert: chèn một ký tự với thời gian là X.
- Thao tác delete: loại bỏ ký tự cuối cùng với thời gian là Y.
- Thao tác copying: copy và paste tất cả các ký tự đã viết để số ký tự được nhân đôi với thời gian là Z.

Hãy tìm thời gian ít nhất để có thể đưa ra màn hình N ký tự giống nhau. Ví dụ với N = 9, X =1, Y = 2, Z =1 ta có kết quả là 5 bằng cách thực hiện: insert, insert, copying, copying, insert.


**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào N là số các ký tự giống nhau cần viết lên màn hình; dòng tiếp theo đưa vào bộ ba số X, Y, Z tương ứng với thời gian thực hiện ba thao tác; các số được viết cách nhau một vài khoảng trống.
- T, N, X, Y, Z thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤100; 1≤X, Y, Z ≤100.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
9
1 2 1
10
2 5 4
```

**output**
```
5
14
```


### DSA05023 - TỔNG CÁC XÂU CON

Cho số nguyên dương N được biểu diễn như một xâu ký tự số. Nhiệm vụ của bạn là tìm tổng của tất cả các số tạo bởi các xâu con của N. Ví dụ N=”1234” ta có kết quả là 1670 = 1 + 2 + 3 + 4 + 12 + 23 + 34 + 123 + 234 + 1234.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Mỗi bộ test bắt đầu bởi số N (không quá 500).
- T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N ≤10<sup>12</sup>.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
1234
421
```

**output**
```
1670
491
```

### DSA05025 - CON ẾCH

Một con ếch có thể nhảy 1, 2, 3 bước để có thể lên đến một đỉnh cần đến. Hãy đếm số các cách con ếch có thể nhảy đến đỉnh.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là số n là số bước con ếch có thể lên được đỉnh.
- T, n thỏa mãn ràng buộc: 1≤T≤100;  1≤n ≤50.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
1
5
```

**output**
```
1
13
```

### DSA05026 - XEM PHIM

John có một đàn bò. Một ngày đẹp trời, anh ta quyết định mua xe tải với khả năng chở được C kg (1000 ≤ C ≤ 25000) để đưa những con bò đi xem phim. Cho số con bò là N (20 ≤ N ≤ 100) và khối lượng w[i] của từng con (đều nhỏ hơn C), hãy cho biết khối lượng bò lớn nhất mà John có thể đưa đi xem phim là bao nhiêu.

**Input:** 
- Dòng 1: 2 số nguyên C và N cách nhau bởi dấu cách
- Dòng 2..N+1:   Ghi lần lượt các số nguyên: w[i]

**Output:** 
- Một số nguyên là tổng khối lượng bò lớn nhất mà John có thể mang đi xem phim.

**input**
```
259 5
81
58
42
33
61
```

**output**
```
242
```

### DSA05027 - CÁI TÚI -- DSAKT055 - BÀI TOÁN CÁI TÚI 0-1

Một người có cái túi thể tích V (V<1000). Anh ta có N đồ vật cần mang theo (N≤1000), mỗi đồ vật có thể tích là A[i] (A[i]≤100) và giá trị là C[i] (C[i]≤100). Hãy xác định tổng giá trị lớn nhất của các đồ vật mà người đó có thể mang theo, sao cho tổng thể tích không vượt quá V.

**Input:** 
- Dòng đầu ghi số bộ test T (T<10)
- Mỗi bộ test gồm ba dòng. Dòng đầu ghi 2 số N và V. Dòng tiếp theo ghi N số của mảng A. Sau đó là một dòng ghi N số của mảng C.
- Dữ liệu vào luôn đảm bảo không có đồ vật nào có thể tích lớn hơn V.

**Output:** 
- Với mỗi bộ test, ghi trên một dòng giá trị lớn nhất có thể đạt được.

**input**
```
1
15 10
5 2 1 3 5 2 5 8 9 6 3 1 4 7 8
1 2 3 5 1 2 5 8 7 4 1 2 3 2 1
```

**output**
```
15
```

### DSA05029 - GIẢI MÃ

Một bản tin M đã mã hóa bí mật thành các con số theo ánh xạ như sau: ‘A’->1, ‘B’->2, .., ‘Z’->26. Hãy cho biết có bao nhiêu cách khác nhau để giải mã bản tin M. Ví dụ với bản mã M=”123” nó có thể được giải mã thành ABC (1 2 3), LC (12 3), AW(1 23).

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự số M.
- T, M thỏa mãn ràng buộc: 1≤T≤100;  1≤length(M)≤40.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
123
2563
```

**output**
```
3
2
```

### DSA05031 - TỔNG BÌNH PHƯƠNG

Mọi số nguyên dương N đều có thể phân tích thành tổng các bình phương của các số nhỏ hơn N. Ví dụ số 100 = 10<sup>2</sup> hoặc 100 = 5<sup>2</sup> + 5<sup>2</sup> + 5<sup>2</sup> + 5<sup>2</sup>. Cho số nguyên dương N. Nhiệm vụ của bạn là tìm số lượng ít nhất các số nhỏ hơn N mà có tổng bình phương bằng N.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi test là một số tự nhiên N được viết trên 1 dòng.
- T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤10000.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
100
6
25
```

**output**
```
1
3
1
```

### DSA05036 - TĂNG - GIẢM

Cho hai dãy số thực A[] và B[] đều có N phần tử, các giá trị là số thực và không quá 100.

Hãy tính độ dài dài nhất của dãy các vị trí (không cần liên tiếp) thỏa mãn cả hai điều kiện:

- Nếu xét các vị trí đó trên dãy A[] thì dãy con thu được thỏa mãn tính chất tăng dần (giá trị bằng nhau không được tính vào dãy tăng).
- Nếu xét các vị trí đó trên dãy A[] thì dãy con thu được thỏa mãn tính chất tăng dần (giá trị bằng nhau không được tính vào dãy tăng).

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Mỗi bộ test bắt đầu bởi số N (không quá 500).
- Tiếp theo là N dòng, mỗi dòng ghi 2 giá trị A[i] và B[i]

**Output:** 
- Với mỗi test, ghi ra độ dài tính được trên một dòng.

**input**
```
3
2
1.0 1.0
1.5 0.0
3
1.0 1.0
1.0 1.0
1.0 1.0
6
1.5 9.0
2.0 2.0
2.5 6.0
3.0 5.0
4.0 2.0
10.0 5.5
```

**output**
```
2
1
4
```

### DSA05041 - BIẾN ĐỔI VỀ XÂU ĐỐI XỨNG

Cho xâu ký tự S. Nhiệm vụ của bạn là tìm số phép loại bỏ ít nhất các ký tự trong S để S trở thành xâu đối xứng. Chú ý, phép loại bỏ phải bảo toàn tính trước sau của các ký tự trong S.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test là một xâu ký tự được viết trên một dòng
- T, str thỏa mãn ràng buộc: 1≤T≤100;  1≤length(S)≤100.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
aebcbda
geeksforgeeks
```

**output**
```
2
8
```

### DSA05042 - DÃY CON LIÊN TIẾP TỔNG BẰNG K

Cho dãy số A[] gồm có N phần tử không âm và số K.

Nhiệm vụ của bạn là hãy xác định xem có tìm được 1 dãy con liên tiếp mà tổng các phần tử bằng K hay không?

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên N và K (1≤ N ≤ 100 000, 0 ≤ K ≤ 10<sup>18</sup>).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10<sup>9</sup>).

**Output:** 
- Với mỗi test, in ra trên một dòng là đáp án thu được. Nếu có hãy in ra “YES”. Nếu không tìm được đáp án, in ra “NO”.

**input**
```
3
6 33
1 4 20 3 10 5
7 7
1 4 0 0 3 10 5
2 0
1 4
```

**output**
```
YES
YES
NO
```

### DSAKT053 - SỐ NGUYÊN LỚN

Cho hai số nguyên lớn N và M có không quá 1000 chữ số. Người ta muốn tính xem liệu có thể lấy ra nhiều nhất bao nhiêu chữ số trong N (không cần liên tiếp) và giữ nguyên thứ tự của nó để tạo ra một số X sao cho ta cũng có thể tìm thấy X trong số M theo cách tương tự.

**Input:** 
Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test gồm hai dòng, dòng thứ nhất ghi số N, dòng thứ 2 ghi số M.

**Output:** 
Với mỗi test, hãy in ra số chữ số nhiều nhất có thể của X.

**input**
```
2
144615
4976135
44
88
```

**output**
```
4
0
```

## Sort and Search

### CTDL_005 - XÓA DỮ LIỆU TRONG DSLK ĐƠN

Cho danh sách liên kết đơn lưu giữ các số nguyên được quản lý bởi con trỏ First. Viết chương trình con xóa tất cả các phần tử có giá trị bằng x trong danh sách liên kết đơn; chương trình con trả về số lượng các phần tử đã xóa. Sau khi xóa xong, liệt kê các phần tử còn lại trong danh sách liên kết đơn First.

**input**
```
14
1 1 1 4 5 1 1 1 1 7 1 8 1 9
1
```

**output**
```
4 5 7 8 9
```

### CTDL_006 - LỌC DỮ LIỆU TRÙNG TRONG DSLK ĐƠN

Cho danh sách liên kết đơn lưu giữ các số nguyên được quản lý bởi con trỏ First. Viết chương trình con lọc tất cả các phần tử có giá trị trùng nhau trong danh sách liên kết đơn First, chỉ để lại 1 phần tử đại diện cho nhóm trùng. Sau khi lọc xong, liệt kê các phần tử  trong danh sách liên kết đơn First.

**input**
```
12
1 1 1 4 5 1 4 7 7 8 1 9
```

**output**
```
1 4 5 7 8 9
```

### DSA06001 - SẮP XẾP XEN KẼ

Cho mảng A[] gồm n số nguyên khác nhau. Hãy đưa ra các phần tử của mảng theo khuôn dạng lớn nhất, nhỏ nhất, lớn thứ hai, nhỏ thứ 2, … Ví dụ với A[] = {9, 7, 12, 8, 6, 5} ta đưa ra : 12, 5, 9, 6, 8, 7.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên là số phần tử của mảng n; dòng tiếp theo là n số A [i] của mảng A [];các số được viết cách nhau một vài khoảng trống.
- T, n thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤10<sup>3</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
7
7 1 2 3 4 5 6
8
1 6 9 4 3 7 8 2
```

**output**
```
7 1 6 2 5 3 4
9 1 8 2 7 3 6 4
```

### DSA06002 - SẮP XẾP THEO GIÁ TRỊ TUYỆT ĐỐI

Cho mảng A[] gồm n phần tử và số X. Hãy đưa sắp xếp các phần tử của mảng theo trị tuyệt đối của |X - A[i] |. Ví dụ với A[] = {10, 5, 3, 9, 2} và X = 7 ta đưa ra mảng được sắp xếp theo nguyên tắc kể trên: A[] = {5, 9, 10, 3, 2} vì |7-10|=3, |7-5|=2, |7-3|=4, |7-9|=2, |7-2|=5.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên là số phần tử của mảng n và X; dòng tiếp theo là n số A [i] của mảng A [];các số được viết cách nhau một vài khoảng trống.
- T, n, X thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, X, A[i] ≤10<sup>5</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5 7
10 5 3 9 2
5 6
1 2 3 4 5
```

**output**
```
5 9 10 3 2
5 4 3 2 1
```

### DSA06003 - ĐỔI CHỖ ÍT NHẤT

Cho mảng A[] gồm n phần tử. Hãy tìm số phép đổi chỗ ít nhất giữa các phần tử của mảng để mảng A[] được sắp xếp. Ví dụ với A[] = {4, 3, 2, 1} ta cần thực hiện ít nhất 2 phép đổi chỗ: Swap(A[0], A[3]),  Swap(A[1], A[2]).

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên là số phần tử của mảng n và X; dòng tiếp theo là n số A [i] của mảng A [];các số được viết cách nhau một vài khoảng trống.
- T, n thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤10<sup>3</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4
4 3 2 1
5
1 5 4 3 2
```

**output**
```
2
2
```

### DSA06004 - HỢP VÀ GIAO CỦA HAI DÃY SỐ 1

Cho mảng A[] gồm n phần tử, mảng B[] gồm m phần tử khác nhau. Các phần tử của mảng A[] và B[] đã được sắp xếp. Hãy tìm mảng hợp và giao được sắp giữa A[] và B[]. Ví dụ với A[] = {1, 3, 4, 5, 7}, B[]={2, 3, 5, 6} ta có mảng hợp Union = {1, 2, 3, 4, 5, 6, 7}, mảng giao Intersection = {3, 5}. In ra đáp án theo giá trị phần tử từ nhỏ đến lớn.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m là số phần tử của mảng A[] và B[]; dòng tiếp theo là n số A [i] của mảng A [];dòng tiếp theo là m số B[i] của mảng B[]; các số được viết cách nhau một vài khoảng trống.
- T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m, A[i], B[i] ≤10<sup>5</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
5 3
1 2 3 4 5
1 2 3
```

**output**
```
1 2 3 4 5
1 2 3
```

### DSA06005 - HỢP VÀ GIAO CỦA HAI DÃY SỐ 2

Cho mảng A[] gồm n phần tử, mảng B[] gồm m phần tử khác nhau. Các phần tử của mảng A[] và B[] chưa được sắp xếp. Hãy tìm mảng hợp và giao được sắp giữa A[] và B[]. Ví dụ với A[] = {7, 1, 5, 2, 3, 6}, B[]={3, 8, 6, 20, 7} ta có mảng hợp Union = {1, 2, 3, 5, 6, 7, 8, 20}, mảng giao Intersection = {3, 6}.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m là số phần tử của mảng A[] và B[]; dòng tiếp theo là n số A [i] của mảng A [];dòng tiếp theo là m số B[i] của mảng B[]; các số được viết cách nhau một vài khoảng trống.
- T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m, A[i], B[i] ≤10<sup>5</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
6 5
7 1 5 2 3 6
3 8 6 20 7
```

**output**
```
1 2 3 5 6 7 8 20
2 6
```

### DSA06006 - SẮP XẾP [0 1 2]

Cho mảng A[] gồm n phần tử. Các phần tử của mảng A[] chỉ bao gồm các số 0, 1, 2. Hãy sắp xếp mảng A[] theo thứ tự tăng dần. Ví dụ với A[] = {0, 2, 1, 2, 0} ta kết quả A[] = {0, 0, 1, 2, 2}.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[]; dòng tiếp theo là n số A [i] của mảng A []các số được viết cách nhau một vài khoảng trống.
- T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 0≤ A[i] ≤2; 1≤ n ≤10<sup>6</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5
0 2 1 2 0
3
0 1 0
```

**output**
```
0 0 1 2 2
0 1
```

### DSA06007 - SẮP XẾP DÃY CON LIÊN TỤC

Cho mảng A[] gồm n phần tử. Hãy tìm dãy con liên tục của mảng A[R], .., A[L] sao cho khi sắp xếp lại dãy con ta nhận được một mảng được sắp xếp. Ví dụ với A[] = {10, 12, 20, 30, 25, 40, 32, 31, 35, 50, 60} ta chỉ cần sắp xếp lại dãy con từ A[4],.., A[9]: {30, 25, 40, 32, 31, 35} để có mảng được sắp.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[]; dòng tiếp theo là n số A [i] của mảng A []các số được viết cách nhau một vài khoảng trống.
T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤10<sup>6</sup>; 0≤ A[i] ≤10<sup>7</sup>.
- T, N thỏa mãn ràng buộc: 1≤T≤100;  1≤N≤1010.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
11
10 12 20 30 25 40 32 31 35 50 60
9
0 1 15 25 6 7 30 40 50
```

**output**
```
4 9
3 6
```

### DSA06008 - ĐẾM CẶP

Cho mảng X[] gồm n phần tử và mảng Y[] gồm m phần tử. Hãy đếm số các cặp xy>yx, trong đó x€X[] và y€Y[]. Ví dụ X[] = {2, 1, 6 }, Y[] = {1, 5} ta có kết quả là 3 cặp (2, 1), (2, 5), (6, 1).

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m tương ứng với số phần tử của mảng X[] và Y[]; dòng tiếp theo là n số X[i] của mảng X[]; dòng cuối cùng là m số của mảng Y[]; các số được viết cách nhau một vài khoảng trống.
- T, n, m, X[i], Y[j] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m ≤10<sup>5</sup>; 0≤ X[i], Y[j] ≤10<sup>3</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
3 2
2 1 6
1 5
```

**output**
```
3
```

### DSA06009 - CẶP SỐ TỔNG BẰNG K

Cho mảng A[] gồm n phần tử và số k. Đếm tất cả các cặp phần tử của mảng có tổng bằng k. Ví dụ A[] = {1, 5, 3, 4, 2 }, k = 7 ta có kết quả là 2 cặp (3, 4), (5, 2).

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[] và k; dòng tiếp theo là n số A[i] của mảng A[]các số được viết cách nhau một vài khoảng trống.
- T, n, k, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤100; 0≤ k ≤100, 0≤ A[i] ≤10<sup>3</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5 9 
1 5 4 1 2
3 2
1 1 1
```

**output**
```
1
3
```

### DSA06010 - SẮP XẾP CHỮ SỐ

Cho mảng A[] gồm n phần tử. Nhiệm vụ của bạn là đưa ra mảng đã được sắp xếp bao gồm các chữ số của mỗi phần tử trong A[]. Ví dụ A[] = {110, 111, 112, 113, 114 }ta có kết quả là {0, 1, 2, 3, 4}.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n là số phần tử của mảng A[]; dòng tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
- T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤10<sup>7</sup>; 0≤ A[i] ≤10<sup>16</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
3
131 11 48
4
111 222 333 446
```

**output**
```
1 3 4 8
1 2 3 4 6
```

### DSA06011 - TỔNG GẦN 0 NHẤT

TỔNG GẦN 0 NHẤT

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n là số phần tử của mảng A[]; dòng tiếp theo đưa vào n số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 2≤N ≤10<sup>3</sup>, -10<sup>6</sup>≤A[i] ≤10<sup>6</sup>.

**Output:**
- Đưa ra tổng gần nhất với 0 của cặp phần tử.

**input**
```
2
3
-8 -66 -60
6
-21 -67 -37 -18 4 -65  
```

**output**
```
-68
-14
```

### DSA06012 - PHẦN TỬ LỚN NHẤT

Cho mảng A[] gồm n phần tử, hãy tìm k phần tử lớn nhất của mảng. Các phần tử được đưa ra theo thứ tự giảm dần.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N và K; dòng tiếp theo đưa vào n số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, N, K, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤K < N ≤10<sup>3</sup>, 1≤A[i] ≤10<sup>6</sup>.

**Output:**
- Đưa ra k phần tử lớn nhất trên một dòng.

**input**
```
2
5 3
10 7 9 12 6
6 2
9 7 12 8 6 5
```

**output**
```
12 10 9
12 9
```

### DSA06013 - SỐ LẦN XUẤT HIỆN

Cho mảng A[] gồm n phần tử đã được sắp xếp. Hãy tìm số lần xuất hiện số X trong mảng. Nếu số lần xuất hiện số x trong mảng là 0 hãy đưa ra -1.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào N và X; dòng tiếp theo đưa vào n số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, N, X, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤ N ≤10<sup>3</sup>, 1≤A[i], X ≤106.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
7 2
1 1 2 2 2 2 3
7 4
1 1 2 2 2 2 3
```

**output**
```
4
-1
```

### DSA06014 - TỔNG CẶP SỐ NGUYÊN TỐ

Cho số tự nhiên N. Hãy tìm cặp số nguyên tố đầu tiên có tổng là N. Nếu không tồn tại cặp số nguyên tố có tổng bằng N, hãy đưa ra -1.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm là một số N được ghi trên một dòng.
- T, N thỏa mãn ràng buộc: 1≤T≤100; 1≤ N ≤10<sup>6</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4
8
```

**output**
```
2 2
2 5
```

### DSA06015 - MERGE SORT

Cho mảng A[] gồm N phần tử chưa được sắp xếp. Nhiệm vụ của bạn là sắp xếp các phần tử của mảng A[] theo thứ tự tăng dần bằng thuật toán Merge Sort.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào số N tương ứng với số phần tử của mảng A[]; phần thứ 2 là N số của mảng A[]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤N, A[i]≤10<sup>6</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5
4 1 3 9 7
10
10 9 8 7 6 5 4 3 2 1
```

**output**
```
1 3 4 7 9
1 2 3 4 5 6 7 8 9 10
```

### DSA06016 - TÍCH LỚN NHẤT - NHỎ NHẤT

Cho mảng A[] gồm n phần tử và mảng B[] gồm m phần tử. Nhiệm vụ của bạn là tìm tích giữa phần tử lớn nhất của mảng A[] và phần tử nhỏ nhất của mảng B[]. Ví dụ A[] = {5, 7, 112, 9, 3, 6, 2 }, B[] = {1, 2, 6, -1, 0, 9} ta có kết quả là -9 = 9*(-1).

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m tương ứng với số phần tử của mảng A[] và B[]; dòng tiếp theo là n số A[i] ; dòng cuối cùng là m số B[i]; các số được viết cách nhau một vài khoảng trống.
- T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m ≤10<sup>6</sup>; -10<sup>8</sup>≤ A[i] ≤10<sup>8</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
6 6
5 7 9 3 6 2
1 2 6 -1 0 9
6 6
1 4 2 3 10 2
4 2 6 5 2 9
```

**output**
```
-9
20
```

### DSA06017 - TRỘN HAI DÃY

Cho mảng A[] gồm n phần tử và mảng B[] gồm m phần tử. Nhiệm vụ của bạn là hợp nhất hai mảng A[] và B[] để được một mảng mới đã được sắp xếp. Ví dụ A[] = {5, 7, 112, 9, 3, 6, 2 }, B[] = {1, 2, 6, -1, 0, 9} ta có kết quả là C[] = {-1, 1, 0, 2, 3, 5, 6, 6, 7, .

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm ba dòng: dòng đầu tiên đưa vào n, m tương ứng với số phần tử của mảng A[] và B[]; dòng tiếp theo là n số A[i] ; dòng cuối cùng là m số B[i]; các số được viết cách nhau một vài khoảng trống.
- T, n, m, A[i], B[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, m ≤10<sup>6</sup>; -10<sup>8</sup>≤ A[i] ≤10<sup>8</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
3 3
10 5 15
20 3 2
```

**output**
```
2 3 5 10 15 20
```

### DSA06018 - BỔ SUNG PHẦN TỬ

Cho mảng A[] gồm n số nguyên dương. Gọi L, R là max và min các phần tử của A[]. Nhiệm vụ của bạn là tìm số phần tử cần thiết cần thêm vào mảng để mảng có đầy đủ các số trong khoảng [L, R]. Ví dụ A[] = {5, 7, 9, 3, 6, 2 } ta nhận được kết quả là 2 tương ứng với các số còn thiếu là 4, 8.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n, tương ứng với số phần tử của mảng A[]; dòng tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
- T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n, A[i] ≤10<sup>3</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5
4 5 3 8 6
3
2 1 3
```

**output**
```
1
0
```

### DSA06019 - SẮP XẾP THEO SỐ LẦN XUẤT HIỆN

Cho mảng A[] gồm n số nguyên. Nhiệm vụ của bạn là sắp xếp mảng theo số lần xuất hiện các phần tử của mảng. Số xuất hiện nhiều lần nhất đứng trước. Nếu hai phần tử có số lần xuất hiện như nhau, số nhỏ hơn đứng trước. Ví dụ A[] = {5, 5, 4, 6, 4 }, ta nhận được kết quả là A[] = {4, 4, 5, 5, 6}.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n, tương ứng với số phần tử của mảng A[] và số k; dòng tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
- T, n, A[i] thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ n ≤10<sup>4</sup>; 1≤ k ≤10<sup>3</sup>; 1≤ A[i] ≤10<sup>5</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
5
5 5 4 6 4
5
9 9 9 2 5
```

**output**
```
4 4 5 5 6
9 9 9 2 5
```

### DSA06020 - TÌM KIẾM

Cho mảng A[] gồm n phần tử đã được sắp xếp. Hãy đưa ra 1 nếu X có mặt trong mảng A[], ngược lại đưa ra -1.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n, X là số các phần tử của mảng A[] và số X cần tìm; dòng tiếp theo đưa vào n số A[i] (1≤i≤n) các số được viết cách nhau một vài khoảng trống.
- T, n, A, X thỏa mãn ràng buộc: 1≤T≤100; 1≤N, X, A[i] ≤10<sup>6</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2 
5 16
2 4 7 9 16
7 98
1 22 37 47 54 88 96
```

**output**
```
1
-1
```

### DSA06021 - TÌM KIẾM TRONG DÃY SẮP XẾP VÒNG

Một mảng được sắp được chia thành hai đoạn tăng dần được gọi là mảng sắp xếp vòng. Ví dụ mảng A[] = { 5, 6, 7, 8, 9, 10, 1, 2, 3, 4} là mảng sắp xếp vòng. Cho mảng A[] gồm n phần tử, hãy tìm vị trí của phần tử x trong mảng A[] với thời gian log(n).

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n và x; dòng tiếp theo đưa vào n số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, n, A[i], x  thỏa mãn ràng buộc: 1≤T≤100; 1≤N, x, A[i] ≤10<sup>7</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
10 3
5 6 7 8 9 10 1 2 3 4
10 3
1 2 3 4 5 6 7 8 9 10
```

**output**
```
9
3
```

### DSA06022 - SỐ NHỎ NHẤT VÀ NHỎ THỨ HAI

Cho mảng A[] gồm n phần tử, hãy đưa ra số nhỏ nhất và số nhỏ thứ hai của mảng. Nếu không có số nhỏ thứ hai, hãy đưa ra -1.

**Input:**
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n là số phần tử của mảng A[]; dòng tiếp theo đưa vào n số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N, A[i] ≤10<sup>7</sup>.

**Output:**
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
10
5 6 7 8 9 10 1 2 3 4
5
1 1 1  1  1
```

**output**
```
1 2
-1
```

### DSA06023 - SẮP XẾP ĐỔI CHỖ TRỰC TIẾP

Hãy thực hiện thuật toán sắp xếp đổi chỗ trực tiếp trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán.

**Input:**
Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100).

**Output:**
Ghi ra màn hình từng bước thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một khoảng trống.

**input**
```
4
5 7 3 2
```

**output**
```
Buoc 1: 2 7 5 3
Buoc 2: 2 3 7 5
Buoc 3: 2 3 5 7
```

### DSA06024 - SẮP XẾP CHỌN

Hãy thực hiện thuật toán sắp xếp chọn trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán.

**Input:**
Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100).

**Output:**
Ghi ra màn hình từng bước thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một khoảng trống.

**input**
```
4
5 7 3 2
```

**output**
```
Buoc 1: 2 7 3 5
Buoc 2: 2 3 7 5
Buoc 3: 2 3 5 7
```

### DSA06025 - SẮP XẾP CHÈN

Hãy thực hiện thuật toán sắp xếp chọn trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán.

**Input:**
Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100).

**Output:**
Ghi ra màn hình từng bước thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một khoảng trống.

**input**
```
4
5 7 3 2
```

**output**
```
Buoc 0: 5
Buoc 1: 5 7
Buoc 2: 3 5 7
Buoc 3: 2 3 5 7
```

### DSA06026 - SẮP XẾP NỔI BỌT

Hãy thực hiện thuật toán sắp xếp chọn trên dãy N số nguyên. Ghi ra các bước thực hiện thuật toán.

**Input:**
Dòng 1 ghi số N (không quá 100). Dòng 2 ghi N số nguyên dương (không quá 100).

**Output:**
Ghi ra màn hình từng bước thực hiện thuật toán. Mỗi bước trên một dòng, các số trong dãy cách nhau đúng một khoảng trống.

**input**
```
4
5 7 3 2
```

**output**
```
Buoc 1: 3 2 5 7
Buoc 2: 2 3 5 7
```

### DSA06027 - SẮP XẾP ĐỔI CHỖ TRỰC TIẾP - LIỆT KÊ NGƯỢC

Cho dãy số A[] có n phần tử là các số nguyên dương. Hãy sắp xếp dãy số theo thuật toán sắp xếp đổi chỗ trực tiếp. Nhưng yêu cầu in ra lần lượt các bước chạy của thuật toán theo thứ tự ngược (bước cuối cùng in ra đầu tiên).

**Input:**

Dòng đầu ghi số bộ test (không quá 10). Mỗi test gồm 2 dòng:

- Dòng đầu ghi số n (1 < n < 100)
- Dòng thứ 2 ghi n số của dãy A (các số đều nguyên dương và nhỏ hơn 1000)

**Output:**

Ghi ra lần lượt các bước thuật toán theo thứ tự ngược (xem ví dụ mẫu để hiểu rõ hơn).

**input**
```
1
6
5 8 3 9 1 4
```

**output**
```
Buoc 5: 1 3 4 5 8 9
Buoc 4: 1 3 4 5 9 8
Buoc 3: 1 3 4 9 8 5
Buoc 2: 1 3 8 9 5 4
Buoc 1: 1 8 5 9 3 4
```

### DSA06028 - SẮP XẾP CHỌN - LIỆT KÊ NGƯỢC

Cho dãy số A[] có n phần tử là các số nguyên dương. Hãy sắp xếp dãy số theo thuật toán sắp xếp chọn. Nhưng yêu cầu in ra lần lượt các bước chạy của thuật toán theo thứ tự ngược (bước cuối cùng in ra đầu tiên).

**Input:**
- Dòng đầu ghi số n (1 < n < 100)
- Dòng thứ 2 ghi n số của dãy A (các số đều nguyên dương và nhỏ hơn 100000)

**Output:**
- Ghi ra lần lượt các bước thuật toán theo thứ tự ngược (xem ví dụ mẫu để hiểu rõ hơn).

**input**
```
6
5 8 3 9 1 4
```

**output**
```
Buoc 5: 1 3 4 5 8 9
Buoc 4: 1 3 4 5 9 8
Buoc 3: 1 3 4 9 5 8
Buoc 2: 1 3 8 9 5 4
Buoc 1: 1 8 3 9 5 4
```

### DSA06029 - SẮP XẾP CHÈN - LIỆT KÊ NGƯỢC

Cho dãy số A[] có n phần tử là các số nguyên dương. Hãy sắp xếp dãy số theo thuật toán sắp xếp chèn. Nhưng yêu cầu in ra lần lượt các bước chạy của thuật toán theo thứ tự ngược (bước cuối cùng in ra đầu tiên).

**Input:**
- Dòng đầu ghi số n (1 < n < 100)
- Dòng thứ 2 ghi n số của dãy A (các số đều nguyên dương và nhỏ hơn 100000)

**Output:**
- Ghi ra lần lượt các bước thuật toán theo thứ tự ngược (xem ví dụ mẫu để hiểu rõ hơn).

**input**
```
6
5 8 3 9 1 4
```

**output**
```
Buoc 5: 1 3 4 5 8 9
Buoc 4: 1 3 5 8 9
Buoc 3: 3 5 8 9
Buoc 2: 3 5 8
Buoc 1: 5 8
Buoc 0: 5
```

### DSA06030 - SẮP XẾP NỔI BỌT - LIỆT KÊ NGƯỢC

Cho dãy số A[] có n phần tử là các số nguyên dương. Hãy sắp xếp dãy số theo thuật toán sắp xếp nổi bọt. Nhưng yêu cầu in ra lần lượt các bước chạy của thuật toán theo thứ tự ngược (bước cuối cùng in ra đầu tiên).

*Chú ý: thuật toán sắp xếp nổi bọt có thể kết thúc khi tất cả dãy đã sắp xếp, không còn cặp số cạnh nhau nào sai thứ tự.*

**Input:**

Dòng đầu ghi số bộ test (không quá 10). Mỗi test gồm 2 dòng:

- Dòng đầu ghi số n (1 < n < 100)
- Dòng thứ 2 ghi n số của dãy A (các số đều nguyên dương và nhỏ hơn 1000)

**Output:**

- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
6
4 1 3 9 8 5
```

**output**
```
Buoc 2: 1 3 4 5 8 9
Buoc 1: 1 3 4 8 5 9
```

### DSA06031 - PHẦN TỬ LỚN NHẤT TRONG DÃY CON

Cho dãy số A[] gồm có N phần tử và số nguyên K.

Với mỗi dãy con liên tiếp có độ dài bằng K (từ trái sang phải), bạn hãy in ra phần tử lớn nhất trong dãy con này.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N và K (1≤ N ≤ 100 000, 1 ≤ K ≤ N).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10<sub>9</sub>).

**Output:**
- Với mỗi test, in ra trên một dòng N-K+1 số nguyên là đáp án tìm được.

**input**
```
2
9 3
1 2 3 1 4 5 2 3 6
10 4
8 5 10 7 9 4 15 12 90 13
```

**output**
```
3 3 4 5 5 5 6
10 10 10 15 15 90 90
```

### DSA06032 - BỘ BA SỐ CÓ TỔNG NHỎ HƠN K

Cho dãy số A[] gồm có N phần tử.

Nhiệm vụ của bạn là hãy đếm số bộ ba (i, j, k) mà A[i] + A[j] + A[k] < K cho trước.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên N và K (1≤ N ≤5000, -10<sup>9</sup> ≤ K ≤ 10<sup>9</sup>).
- Dòng tiếp theo gồm N số nguyên A[i] (-10<sup>9</sup> ≤ A[i] ≤ 10<sup>9</sup>).

**Output:**
- Với mỗi test, in ra trên một dòng là đáp án tìm được.

**input**
```
2
4 2
-2 0 1 3
5 12
5 1 3 4 7
```

**output**
```
2
4
```

### DSA06033 - KHOẢNG CÁCH XA NHẤT

Cho dãy số A[] gồm có N phần tử. Bạn cần tìm 2 vị trí i, j sao cho j-i lớn nhất và A[j] > A[i].

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N (1≤ N ≤ 100 000).
- Dòng tiếp theo gồm N số nguyên A[i] (-10^6 ≤ A[i] ≤ 10^6).

**Output:** 
- Với mỗi test, in ra trên một dòng là giá trị của hiệu j-i tìm được.

**input**
```
3
9
34 8 10 3 2 80 30 33 1
6
1 2 3 4 5 6
6
6 5 4 3 2 1
```

**output**
```
6
5
-1
```

### DSA06034 - CẶP SỐ CÓ TỔNG BẰNG K

Cho dãy số A[] gồm có N phần tử.

Nhiệm vụ của bạn là đếm xem có bao nhiêu cặp (i, j) mà A[i] + A[j] = K cho trước.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N và K (1≤ N ≤ 100 000, 0 ≤ K ≤ 10^9).
- Dòng tiếp theo gồm N số nguyên A[i] (-10^9 ≤ A[i] ≤ 10^9).

**Output:**
- Với mỗi test, in ra trên một dòng là đáp án thu được.

**input**
```
4
4 6
1 5 7 -1
5 6
1 5 7 -1 5
4 2
1 1 1 1
13 11
10 12 10 15 -1 7 6 5 4 2 1 1 1
```

**output**
```
2
3
6
9
```

### DSA06035 - DÃY TAM GIÁC DÀI NHẤT

Cho dãy số A[] gồm có N phần tử.

Một dãy con liên tiếp được gọi là dãy tam giác nếu như dãy đó tăng dần rồi lại giảm dần, hay tồn tại i, j, k sao cho A[i] ≤ A[i+1] ≤ … ≤ A[k] >= A[k+1] >= … >= A[j].

Nhiệm vụ của bạn là hãy tìm dãy con liên tiếp là dãy tam giác có độ dài lớn nhất.

Lưu ý: Dãy đơn điệu không giảm hoặc không tăng cũng là dãy tam giác.

Ví dụ A[] = {10, 20, 30, 40} là một dãy tam giác.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N(1≤ N ≤ 100 000).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10^6).

**Output:** 
- Với mỗi test, in ra trên một dòng là độ dài của dãy con tìm được.

**input**
```
2
6
12 4 78 90 45 23
8
20 4 1 2 3 4 2 10
```

**output**
```
5
5
```

### DSA06036 - BỘ BA SỐ BẰNG K

Cho dãy số A[] gồm có N phần tử.

Nhiệm vụ của bạn là hãy kiểm tra tồn tại bộ ba (i, j, k) mà A[i] + A[j] + A[k] = K cho trước hay không.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên N và K (1≤ N ≤5000, 0 ≤ K ≤ 10^9).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10^9).

**Output:** 
- Với mỗi test, in ra trên một dòng là “YES” nếu tìm được bộ ba thỏa mãn, “NO” trong trường hợp ngược lại.

**input**
```
2
6 22
1 4 15 6 10 8
3 4
1 1 1
```

**output**
```
YES
NO
```

### DSA06037 - SẮP XẾP ĐOẠN CON

Cho dãy số nguyên A[] độ dài N. Xác định số lượng chỉ số M (M < N) thỏa mãn: nếu sắp xếp đoạn con (A<sub>1</sub>,…,A<sub>M</sub>) và (A<sub>M+1</sub>, …, A<sub>N</sub>) theo thứ tự tăng dần thì được dãy số A tăng dần.

**Input:** 
- Dòng đầu tiên ghi số bộ test T
- Mỗi bộ test bắt đầu bằng một dòng chứa số N (2 ≤ N ≤ 10<sup>5</sup>)
- Dòng tiếp theo ghi N số của dãy A (|Ai| ≤ 10<sup>9</sup>)

**Output:** 

Với mỗi bộ test:

- Dòng đầu tiên ghi số K là số lượng vị trí M tìm được
- Dòng thứ 2 ghi ra K số theo thứ tự tăng dần lần lượt là các chỉ số thỏa mãn. Nếu K = 0 thì dòng này bỏ trống. 

**input**
```
2
2
2 1
5
2 1 3 5 4
```

**output**
```
0

2
2 3
```

### DSA06038 - CẶP SỐ

Cho dãy số nguyên A có n phần tử.

Hãy đếm xem có bao nhiêu cặp (i,j) thỏa mãn:
- i < j
- A[i] > A[j] và đều là số chẵn
- Tồn tại chỉ số k với i < k < j sao cho A[k] là số lẻ

**Input:** 

Dòng đầu tiên ghi số n (1 ≤ n ≤ 10<sup>5</sup>).

**Output:** 

Dòng thứ 2 ghi n số của dãy A, các giá trị A[i] không vượt quá 10<sup>6</sup>.

**input**
```
5
4 3 2 5 1
```

**output**
```
1
```

### DSA06039 - SỐ ĐẦU TIÊN BỊ LẶP

Cho dãy số A[] gồm có N phần tử. Nhiệm vụ của bạn là hãy tìm số xuất hiện nhiều hơn 1 lần trong dãy số và số thứ tự là nhỏ nhất.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N (1≤ N ≤ 100 000), số lượng phần tử trong dãy số ban đầu.
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10^9).

**Output:** 
- Với mỗi test in ra đáp án của bài toán trên một dòng. Nếu không tìm được đáp án, in ra “NO”.

**input**
```
2
7
10 5 3 4 3 5 6
4
1 2 3 4
```

**output**
```
5
NO
```

### DSA06041 - SỐ XUẤT HIỆN NHIỀU NHẤT

Cho dãy số A[] gồm có N phần tử. Nhiệm vụ của bạn là hãy tìm một số có tần số xuất hiện nhiều nhất, yêu cầu lớn hơn N/2 lần xuất hiện trong dãy số.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N (1≤ N ≤ 100 000), số lượng phần tử trong dãy số ban đầu.
- Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 1 000 000).

**Output:** 
- Với mỗi test in ra đáp án của bài toán trên một dòng. Nếu không tìm được đáp án, in ra “NO”.

**input**
```
2
9
3 3 4 2 4 4 2 4 4
8
3 3 4 2 4 4 2 4
```

**output**
```
4
NO
```

### DSA06043 - ĐIỂM CÂN BẰNG

Cho dãy số A[] gồm có N phần tử nguyên dương. Phần tử thứ i được gọi là điểm cân bằng của dãy số nếu như tổng các số bên trái bằng tổng các số bên phải của nó.

Nhiệm vụ của bạn là điểm cân bằng đầu tiên của dãy A[] cho trước. Nếu không có đáp án, in ra -1.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N (1≤ N ≤ 100 000), số lượng phần tử trong dãy số ban đầu.
- Dòng tiếp theo gồm N số nguyên A[i] (-1000 ≤ A[i] ≤ 1000).

**Output:**
- Với mỗi test, in ra trên một dòng vị trí của điểm cân bằng tìm được.

**input**
```
2
7
-7 1 5 2 -4 3 0
5
1 2 3 4 5
```

**output**
```
4
-1
```

### DSA06044 - SẮP XẾP CHẴN LẺ

Cho dãy số a[] có n phần tử, đánh số từ 1 đến n. Hãy sắp xếp các phần tử ở vị trí lẻ theo thứ tự tăng dần, các phần tử ở vị trí chẵn theo thứ tự giảm dần.

**Input:**
- Dòng đầu tiên ghi số n, không quá 10<sup>5</sup>
- Dòng thứ 2 ghi n số của dãy a[] (a ≤ a[i] ≤ 10<sup>9</sup>)

**Output:**
- Ghi ra dãy số kết quả trên một dòng

**input**
```
4
1 2 3 4
```

**output**
```
1 4 3 2
```

<details><summary>CODE</summary>
<p>
  
  ```
  #include <bits/stdc++.h>
  using namespace std;
  int main() {
      int n, j = 0, k = 0;
      cin >> n;
      int a[n], b[n], c[n];
      for (int i = 0; i < n; i++) cin >> a[i];

      for (int i = 0; i < n; i += 2) b[j++] = a[i];
      sort(b, b + j);
      j = 0;
      for (int i = 0; i < n; i += 2) a[i] = b[j++];
      for (int i = 1; i < n; i += 2) c[k++] = a[i];
      sort(c, c + k); k--;
      for (int i = 1; i < n; i += 2) a[i] = c[k--];
      for (int i = 0; i < n; i++) cout << a[i] << " ";
  }
  ```
                                               
</p>
</details>

### DSA06045 - XÂU TỐT

Xâu đối xứng là xâu mà khi ta đảo ngược thứ tự của xâu thì nhận lại được xâu cũ.

Xâu tốt là xâu mà mỗi ký tự của nó thuộc về ít nhất 1 xâu đối xứng có độ dài lớn hơn 1.

Ví dụ: AABBAA,  AABA,.. là các xâu tốt.

Giá sử cho xâu s chỉ có 2 ký tự A và B. Hãy đếm số xâu con là xâu tốt trong s ( Xâu con là hợp các phần tử liền kề nhau của xâu gốc ).

**Input:**
- Dòng đầu là số ký tự của s ( Không vượt quá 10<sup>5</sup>)
- Dòng thứ 2 là xâu S chỉ gồm các ký tự A và B

**Output:**
- Ghi ra kết quả đếm được

**input**

test 1
```
7
BABBAAB
```
test 2
```
6
BAABBA
```

**output**

test 1
```
13
```
test 2
```
8
```

### DSA06046 - CHÊNH LỆCH NHỎ NHẤT

Cho dãy số A[] gồm có N phần tử. Bạn cần tìm chênh lệch nhỏ nhất giữa hai phần tử bất kì trong dãy số đã cho.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 10).
- Mỗi test gồm số nguyên N (1≤ N ≤ 100 000).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10<sup>9</sup>).

**Output:**
- Với mỗi test, in ra trên một dòng là đáp án tìm được.

**input**
```
3
6
1 5 3 19 18 25
4
30 5 20 9
7
1 19 2 31 38 25 100
```

**output**
```
1
4
1
```

### DSA06047 - BỘ BA SỐ PYTAGO

Cho dãy số A[] gồm có N phần tử. Một bộ 3 số (a, b, c) được gọi là bộ ba số Pytago nếu như a^2 + b^2 = c^2.

Nhiệm vụ của bạn là kiểm tra xem có tồn tại bộ ba số Pytago trong dãy số A[] hay không?

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm số nguyên N và K (1≤ N ≤5000, 0 ≤ K ≤ 10^9).
- Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 10^9).

**Output:** 
- Với mỗi test, in ra trên một dòng “YES” nếu tìm được, và “NO” trong trường hợp ngược lại.

**input**
```
2
5
3 1 4 6 5
3
1 1 1
```

**output**
```
YES
NO
```

### DSA06048 - SỐ LẦN QUAY VÒNG

Ban đầu dãy số A[] gồm N phần tử đã được sắp xếp tăng dần. Các phần tử của dãy A[] có thể giống nhau. Sau đó ta thực hiện quay vòng phải, mỗi lần lấy một ký tự ở cuối dãy đưa lên đầu dãy.

Cho trạng thái dãy số của A[] sau khi đã thực hiện quay vòng K lần. Hãy tìm K.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất đưa vào số M, N, K; dòng tiếp theo đưa vào N số của mảng A[]các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100;  1≤ N≤10<sup>7</sup>; 0≤ A[i]≤10<sup>18</sup>.

**Output:** 
- Đưa ra số lần quay vòng K của mỗi test theo từng dòng.

**input**
```
2
5
5 1 2 3 4
5
1 2 3 4 5
```

**output**
```
1
0
```

### DSA06049 - ĐẾM CẶP

Cho mảng A[] gồm n số nguyên dương và số k. Nhiệm vụ của bạn là đếm số các cặp phần tử có hiệu nhỏ hơn k. Ví dụ A[] = {1, 10, 4, 2 }, k=3 ta nhận được kết quả là 2 tương ứng với hiệu các cặp (1, 2), (4, 2).

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm hai dòng: dòng đầu tiên đưa vào n, tương ứng với số phần tử của mảng A[] và số k; dòng tiếp theo là n số A[i] ; các số được viết cách nhau một vài khoảng trống.
- T, n, k, A[i] thỏa mãn ràng buộc: 1 ≤  T  ≤ 100; 1 ≤  n  ≤ 10<sup>4</sup>; 1 ≤  k ≤ 10<sup>3</sup>; 1 ≤  A[i]  ≤ 10<sup>5</sup>.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
32
4 3
1 10 4 2
3 5
2 3 4
```

**output**
```
2
3
```

## Stack

### DSA07001 - NGĂN XẾP 1

Cho một ngăn xếp các số nguyên. Các thao tác gồm 3 lệnh: push, pop và show. Trong đó thao tác push kèm theo một giá trị cần thêm (không quá 1000). Hãy viết chương trình ghi ra kết quả của các lệnh show.

**Input:** 
Gồm nhiều dòng, mỗi dòng chứa một lệnh push, pop hoặc show. Input đảm bảo số lượng phần tử trong stack khi nhiều nhất cũng không vượt quá 200.

**Output:** 
Ghi ra màn hình các phần tử đang có trong stack theo thứ tự lưu trữ mỗi khi gặp lệnh show. Các số viết cách nhau đúng một khoảng trống. Nếu trong stack không còn gì thì in ra dòng “empty”

**input**
```
push 3
push 5
show
push 7
show
pop
pop
show
```

**output**
```
3 5
3 5 7
3
```

### DSA07002 - NGĂN XẾP 2

Yêu cầu bạn xây dựng một stack với các truy vấn sau đây:

“PUSH x”: Thêm phần tử x vào stack (0 ≤ x ≤ 1000).

“PRINT”: In ra phần tử đầu tiên của stack. Nếu stack rỗng, in ra “NONE”.

“POP”: Xóa phần tử đầu tiên của stack. Nếu stack rỗng, không làm gì cả.

**Input:** 
- Dòng đầu tiên là số lượng truy vấn Q (Q ≤ 100000).
- Mỗi truy vấn có dạng như trên.

**Output:** 
- Với mỗi truy vấn “PRINT”, hãy in ra phần tử đầu tiên của stack. Nếu stack rỗng, in ra “NONE”.

**input**
```
9
PUSH 1
PUSH 2
POP
PRINT
PUSH 3
PRINT
POP
POP
PRINT
```

**output**
```
1
3
NONE
```

### DSA07003 - KIỂM TRA BIỂU THỨC SỐ HỌC

Cho biểu thức số học, hãy cho biết biểu thức số học có dư thừa các cặp ký hiệu ‘(’,’) ‘ hay không?

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤20.

**input**
```
3
((a+b))
(a+(b)/c)
(a+b*(c-d))
```

**output**
```
Yes
Yes
No
```

### DSA07004 - ĐẾM SỐ DẤU NGOẶC ĐỔI CHIỀU

Cho một xâu chỉ gồm các kí tự ‘(‘, ‘) và có độ dài chẵn. Hãy đếm số lượng dấu ngoặc cần phải đổi chiều ít nhất, sao cho xâu mới thu được là một dãy ngoặc đúng.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 1 xâu S có độ dài không vượt quá 100 000, chỉ gồm dấu ( và ).

**Output:** 
- Với mỗi test, in ra đáp án tìm được trên một dòng.

**input**
```
4
))((
((((
(((())
)(())(((
```

**output**
```
2
2
1
3
```

### DSA07005 - BIỂU THỨC TƯƠNG ĐƯƠNG

Cho biểu thức đúng P chỉ bao gồm các phép toán +, -, các toán hạng cùng với các ký tự ‘(’, ‘)’. Hãy bỏ tất cả các ký tự ‘(’, ‘)’ trong P để nhận được biểu thức tương đương. Ví dụ với P = a – (b + c) ta có kết quả P = a – b – c .

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức P được viết trên một dòng.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, P thỏa mãn ràng buộc: 1≤T≤100; 1≤length(P)≤10<sup>3</sup>.

**input**
```
2
a-(b+c)
a-(b-c-(d+e))-f
```

**output**
```
a-b-c
a-b+c+d+e-f
```

### DSA07006 - XÓA DẤU NGOẶC

Cho biểu thức toán học đúng, bạn cần tìm tất cả các biểu thức đúng có thể bằng cách xóa bỏ các cặp dấu ngoặc tương ứng với nhau từ biểu thức ban đầu.

Ví dụ: Cho biểu thức: (2+(2*2)+2) Các biểu thức tìm được:

(2+2*2+2)

2+(2*2)+2

2+2*2+2

Các biểu thức (2+2*2)+2 và 2+(2*2+2) không được chấp nhận vì không xóa đi các cặp dấu ngoặc tương ứng với nhau

**Input:** 
- Một dòng chứa biểu thức gồm các số nguyên không âm, các dấu +, -, *, / và dấu ngoặc đơn.
- Biểu thức không quá 200 kí tự, có chứa ít nhất 1 và không quá 10 cặp dấu ngoặc.

**Output:** 
- In ra tất các các biểu thức khác nhau thỏa mãn đầu bài theo thứ tự từ điển

**input**
```
(1+(2*(3+4)))
```

**output**
```
(1+(2*3+4))
(1+2*(3+4))
(1+2*3+4)
1+(2*(3+4))
1+(2*3+4)
1+2*(3+4)
1+2*3+4
```

### DSA07007 - SO SÁNH BIỂU THỨC

Cho P1, P2 là hai biểu thức đúng chỉ bao gồm các ký tự mở ngoặc ‘(’ hoặc đóng ngoặc ‘)’ và các toán hạng in thường. Nhiệm vụ của bạn là định xem P1 và P2 có giống nhau hay không.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào P1, dòng tiếp theo đưa vào P2.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, P thỏa mãn ràng buộc: 1≤T≤100; 1≤length(P) ≤100.

**input**
```
2
-(a+b+c)
-a-b-c
a-b-(c-d)
a-b-c-d
```

**output**
```
YES
NO
```

### DSA07008 - BIẾN ĐỔI TRUNG TỐ - HẬU TỐ

Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng trung tố về dạng hậu tố.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤10.
- Các phép toán bao gồm +, -, *, /, ^. Phép lũy thừa có ưu tiên cao hơn nhân chia và cộng trừ.

**input**
```
2
(A+(B+C)
((A*B)+C)
```

**output**
```
ABC++
AB*C+
```

### DSA07009 - BIẾN ĐỔI TIỀN TỐ - TRUNG TỐ

Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng tiền tố về dạng trung tố.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤10<sup>6</sup>.

**input**
```
2
*+AB-CD
*-A/BC-/AKL
```

**output**
```
((A+B)*(C-D))
((A-(B/C))*((A/K)-L)
```

### DSA07010 - BIẾN ĐỐI TIỀN TỐ - HẬU TỐ

Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng tiền tố về dạng hậu tố.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤10<sup>6</sup>.

**input**
```
2
*+AB-CD
*-A/BC-/AKL
```

**output**
```
AB+CD-*
ABC/-AK/L-*
```

### DSA07011 - BIẾN ĐỔI HẬU TỐ - TIỀN TỐ

Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng hậu tố về dạng tiền tố.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤10<sup>6</sup>.

**input**
```
2
AB+CD-*
ABC/-AK/L-*
```

**output**
```
*+AB-CD
*-A/BC-/AKL
```

### DSA07012 - BIẾN ĐỔI HẬU TỐ - TRUNG TỐ

Hãy viết chương trình chuyển đổi biểu thức biểu diễn dưới dạng hậu tố về dạng trung tố.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤10<sup>6</sup>.

**input**
```
2
ABC++
AB*C+
```

**output**
```
(A+(B+C)
((A*B)+C)
```

### DSA07013 - TÍNH GIÁ TRỊ BIỂU THỨC HẬU TỐ

Hãy viết chương trình chuyển tính toán giá trị của biểu thức hậu tố.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức hậu tố exp. Các số xuất hiện trong biểu thức là các số đơn có 1 chữ số.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng, chỉ lấy giá trị phần nguyên.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤20.

**input**
```
2
231*+9–
875*+9-
```

**output**
```
-4
34
```

### DSA07014 - TÍNH GIÁ TRỊ BIỂU THỨC TIỀN TỐ

Hãy viết chương trình tính toán giá trị của biểu thức tiền tố.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức tiền tố exp. Các số xuất hiện trong biểu thức là các số đơn có 1 chữ số.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng, chỉ lấy giá trị phần nguyên.

**Ràng buộc:**
- T, exp thỏa mãn ràng buộc: 1≤T≤100; 2≤length(exp)≤20.

**input**
```
2
-+8/632
-+7*45+20
```

**output**
```
8
25
```

### DSA07015 - TÍNH TOÁN GIÁ TRỊ BIỂU THỨC TRUNG TỐ

Cho biểu thức trung tố S với các toán tử +, -, *, / và dấu ngoặc (). Các toán hạng là các số có giá trị không vượt quá 100. Hãy tính giá trị biểu thức S. Phép chia thực hiện với số nguyên, input đảm bảo số bị chia luôn khác 0, đáp số biểu thức có không quá 10 chữ số.

**Input:** 
- Dòng đầu tiên là số lượng bộ test (T ≤ 100).
- Mỗi dòng gồm một xâu S, không quá 100 kí tự. Các toán hạng là các số nguyên không âm.

**Output:** 
- Với mỗi test, in ra đáp án tìm được.

**input**
```
4
6*3+2-(6-4/2)
100+99*22
6*((4*3)+5)
1-2
```

**output**
```
16
2278
102
-1
```

### DSA07016 - BIỂU THỨC TĂNG GIẢM

Cho dãy ký tự S chỉ bao gồm các ký tự I hoặc D. Ký tự I được hiểu là tăng (Increasing) ký tự D được hiểu là giảm (Decreasing). Sử dụng các số từ 1 đến 9, hãy đưa ra số nhỏ nhất được đoán nhận từ S. Chú ý, các số không được phép lặp lại. Dưới đây là một số ví dụ mẫu:
- A[] = “I”       : số tăng nhỏ nhất là 12.
- A[] = “D”       : số giảm nhỏ nhất là 21
- A[] = ”DD”      : số giảm nhỏ nhất là 321
- A[] = “DDIDDIID”: số thỏa mãn 321654798

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test là một xâu S
- T, S thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ length(S) ≤8; .

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
4
I
D
DD
DDIDDIID
```

**output**
```
12
21
321
321654798
```

### DSA07017 - PHẦN TỬ BÊN PHẢI NHỎ HƠN

Cho mảng A[] gồm n phần tử. Hãy đưa ra các phần tử nhỏ hơn tiếp theo của phần tử lớn hơn đầu tiên phần tử hiện tại. Nếu phần tử hiện tại không có phần tử lớn hơn tiếp theo ta xem là -1. Nếu phần tử không có phần tử nhỏ hơn tiếp theo ta cũng xem là -1. Ví dụ với mảng A[] = {5, 1, 9, 2, 5, 1, 7} ta có kết quả là ans = {2, 2, -1, 1, -1, -1, -1} vì:

| Next Greater | Right Smaller |
|--------------|---------------|
| 5 -> 9       | 9 -> 2        |
| 1 -> 9       | 9 -> 2        |
| 9 -> -1      | -1 -> -1      |
| 2 -> 5       | 5 -> 1        |
| 5 -> 7       | 7 -> -1       |
| 1 -> 7       | 7 -> -1       |
| 7 -> -1      | 7 -> -1       |

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test gồm hai dòng: dòng thứ nhất đưa vào n là số phần tử của mảng A[], dòng tiếp theo đưa vào n số A[i].

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:** 
- T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤n, A[i] ≤10<sup>6</sup>.

**input**
```
2
7
5 1 9 2 5 1 7
8
4 8 2 1 9 5 6 3
```

**output**
```
2 2 1 1 -1 -1 -1
2 5 5 5 -1 3 -1 -1
```

### DSA07018 - TỔNG ĐA THỨC

Cho hai đa thức có bậc không quá 10000 (chỉ viết ra các phần tử có hệ số khác 0). Hãy sử dụng danh sách liên kết đơn để viết chương trình tính tổng hai đa thức đó.

**Input:** 
- Dòng đầu ghi số bộ test. Mỗi bộ test có hai dòng, mỗi dòng ghi một đa thức theo mẫu như trong ví dụ. Số phần tử của đa thức không quá 20.
- Chú ý: Bậc của các hạng tử luôn theo thứ tự giảm dần, trong đa thức chỉ có phép cộng và luôn được viết đầy đủ hệ số + số mũ (kể cả mũ 0).

**Output:** 
- Ghi ra một dòng đa thức tổng tính được (theo mẫu như ví dụ)

**input**
```
1
3*x^8 + 7*x^2 + 4*x^0
11*x^6 + 9*x^2 + 2*x^1 + 3*x^0
```

**output**
```
3*x^8 + 11*x^6 + 16*x^2 + 2*x^1 + 7*x^0
```

### DSA07019 - HÌNH CHỮ NHẬT LỚN NHẤT

Cho N cột, mỗi cột có chiều cao bằng H[i]. Bạn hãy tìm hình chữ nhật lớn nhất bị che phủ bởi các cột?

<img width="279" alt="download" src="https://user-images.githubusercontent.com/64203006/164464014-3905aa14-3464-41a9-851e-d2e63816cd8c.png">

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi số nguyên N (N ≤ 100 000).
- Dòng tiếp theo gồm N số nguyên H[i] (1 ≤ H[i] ≤ 10<sup>9</sup>).


**Output:** 
- Với mỗi test, in ra diện tích hình chữ nhật lớn nhất tìm được.

**input**
```
2
7
6 2 5 4 5 1 6
3
2 2 2
```

**output**
```
12
6
```

### DSA07021 - DÃY NGOẶC ĐÚNG DÀI NHẤT

Cho một xâu chỉ gồm các kí tự ‘(‘ và ‘)’. Một dãy ngoặc đúng được định nghĩa như sau:
- Xâu rỗng là 1 dãy ngoặc đúng.
- Nếu A là 1 dãy ngoặc đúng thì (A) là 1 dãy ngoặc đúng.
- Nếu A và B là 2 dãy ngoặc đúng thì AB là 1 dãy ngoặc đúng.

Cho một xâu S. Nhiệm vụ của bạn là hãy tìm dãy ngoặc đúng dài nhất xuất hiện trong xâu đã cho.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm một xâu S có độ dài không vượt quá 10<sup>5</sup> kí tự.

**Output:** 
- Với mỗi test in ra một số nguyên là độ dài dãy ngoặc đúng dài nhất tìm được.

**input**
```
3
((()
)()())
()(()))))
```

**output**
```
2
4
6
```

### DSA07022 - PHẦN TỬ CÓ SỐ LẦN XUẤT HIỆN NHIỀU HƠN BÊN PHẢI

Cho mảng A[]  gồm n phần tử. Nhiệm vụ của bạn là tìm phần tử gần nhất phía bên phải có số lần xuất hiện lớn hơn phần tử hiện tại. Nếu không có phần tử nào có số lần xuất hiện lớn hơn phần tử hiện tại hãy đưa ra -1.

Ví dụ với dãy A[] = {1, 1, 2, 3, 4, 2, 1 }, ta nhận được kết quả ans[] = {-1, -1, 1, 2, 2, 1, -1} vì số lần xuất hiện mỗi phần tử trong mảng là F = {3, 3, 2, 1, 1, 2, 3} vì vậy phần tử A[0] = 1 có số lần xuất hiện là 3 và không có phần tử nào xuất hiện nhiều hơn 3 nên ans[0] = -1, tương tự như vậy với A[2]=2 tồn tại A[6] =1 có số lần xuất hiện là 3 nên ans[2] = 1.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test gồm hai dòng, dòng đầu tiên đưa vào số n là số các phần tử của mảng A[]; dòng tiếp theo đưa vào n số của mảng A[]; các phần tử được viết cách nhau một vài khoảng trống.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:** 
- T, n, A[i] thỏa mãn ràng buộc: 1≤T≤100; 0≤n, A[i]≤10<sup>6</sup>.

**input**
```
1
7
1 1 2 3 4 2 1
```

**output**
```
-1 -1 1 2 2 1 -1
```

### DSA07023 - ĐẢO TỪ

Cho xâu ký tự S. Nhiệm vụ của bạn là đảo ngược các từ trong S. Ví dụ S =  “I like this program very much”, ta nhận được kết quả là “much very program this like I”.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test là một xâu ký tự S.
- T, S thỏa mãn ràng buộc: 1≤ T ≤100; 1≤ Length(S)≤10<sup>3</sup>.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
I like this program very much
much very program this like I
```

**output**
```
much very program this like I
I like this program very much
```

### DSA07024 - GHÉP VÁN GỖ

Trong giấc mơ, Tí thấy mình bị lạc trên hòn đảo với cư dân xa lạ. Không biết làm việc gì, Tí đành phải hái dừa đem bán. Tí muốn làm một tấm biến cho quán hàng cửa mình. Lục tung khắp nơi, Tí kiếm được N miếng gỗ hình chữ nhật, mỗi miếng có chiều dài bằng A[i] và chiều rộng bằng 1. Tí đã ghép N miếng gỗ thành một tấm ván lớn, rồi thực hiện cắt các miếng gỗ để thu được tấm biển.

Tí muốn tấm biển quảng cáo của mình thật đặc biệt, nên Tí đã chọn nhất định nó sẽ là hình vuông. Không có eke, thước, dây, … nên Tí phải dựa vào các miếng gỗ ban đầu để căn nhát cưa. Việc cưa theo chiều dọc rất dễ dàng, nhưng theo chiều ngang, Tí chỉ có thể cưa theo một đường thẳng trùng với một cạnh của miếng gỗ nào đó.

Các bạn hãy giúp Tí tính thử xem tấm biển quảng cáo của Tí có kích thước lớn nhất bằng bao nhiêu (kích thước ở đây là độ dài cạnh hình vuông).

![download](https://user-images.githubusercontent.com/64203006/164464958-3e77cb17-e203-4610-b132-8bf5f78c4079.jpg)

**Input:** 
Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test bắt đầu bởi số nguyên N (N ≤ 100 000). Dòng tiếp theo gồm N số nguyên A[i] (1 ≤ A[i] ≤ 10<sup>9</sup>).

**Output:** 
Với mỗi test, in ra chiều dài cạnh của tấm biển. Nếu Tí không thể tạo thành tấm biển, in ra 0.

**input**
```
4
5 2 4 3 3 1 4
3
2 2 2
2
6 6
6
5 5 5 5 3 1
```

**output**
```
4
2
0
3
```

### DSA07027 - PHẦN TỬ BÊN PHẢI ĐẦU TIÊN LỚN HƠN

Cho dãy số A[] gồm N phần tử. Với mỗi A[i], bạn cần tìm phần tử bên phải đầu tiên lớn hơn nó. Nếu không tồn tại, in ra -1.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 100000).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 10<sup>9</sup>).

**Output:** 
- Với mỗi test, in ra trên một dòng N số R[i], với R[i] là giá trị phần tử đầu tiên lớn hơn A[i].

**input**
```
3
4
4 5 2 25
3
2 2 2
4
4 4 5 5
```

**output**
```
5 25 25 -1
-1 -1 -1
5 5 -1 -1
```

### DSA07028 - NHỊP CHỨNG KHOÁN

Bạn là một nhà đầu tư chứng khoán nổi tiếng. Nhiệm vụ hàng ngày của bạn là tính nhịp tăng giảm của phiên chứng khoán trong N ngày để có thể bắt kịp thị trường. Nhịp chứng khoán của ngày thứ i được định nghĩa là số ngày liên tiếp từ ngày thứ i trở về mà giá chứng khoán bé hơn hoặc bằng với giá chứng khoán của ngày i.

**Input:** 
- Dòng đầu ghi số bộ test (không quá 10). Mỗi test có 2 dòng.
- Dòng đầu tiên gồm 1 số nguyên N (1 ≤ N ≤ 105) là số ngày.
- Dòng tiếp theo gồm N số nguyên A1, A2, …, AN (1 ≤ Ai ≤ 10<sup>6</sup>) là giá chứng khoán của các ngày.

**Output:** 
- In ra N số B1, B2, …, BN trong đó Bi là nhịp chứng khoán của ngày thứ i.

**input**
```
1
7
100 80 60 70 60 75 85
```

**output**
```
1 1 1 2 1 4 6
```

### DSA07029 - GIẢI MÃ XÂU KÝ TỰ

Cho xâu ký tự mã hóa str. Hãy viết chương trình giải mã xâu ký tự str. Xâu ký tự mã hóa được thực hiện theo số lần lặp các xâu con của str như sau:

Xâu đầu vào: “abbbababbbababbbab ”

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T;
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một xâu mã hóa str được viết trên một dòng.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**Ràng buộc:** 
- T, str thỏa mãn ràng buộc: 1≤T≤100; 1≤length(str)≤100.

**input**
```
2
1[b]
3[b2[ca]]
```

**output**
```
b
bcacabcacabcaca
```

### DSA07030 - HÌNH CHỮ NHẬT 0-1

Cho một bảng kích thước NxM, được chia thành lưới ô vuông đơn vị N dòng M cột. Trên các ô của bảng ghi số 0 hoặc 1. Các dòng của bảng được đánh số 1, 2... N theo thứ tự từ trên xuống dưới và các cột của bảng được đánh số 1, 2..., M theo thứ tự từ trái qua phải

Yêu cầu: Hãy tìm một hình chữ nhật gồm các ô của bảng thoả mãn các điều kiện sau:

1. Hình chữ nhật đó chỉ gồm các số 1
2. Cạnh hình chữ nhật song song với cạnh bảng
3. Diện tích hình chữ nhật là lớn nhất có thể

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ M, N ≤ 500).
- N dòng tiếp theo, mỗi dòng gồm M số nguyên 0 hoặc 1.

**Output:** 
- Với mỗi test, in ra diện tích hình chữ nhật lớn nhất tìm được.

**input**
```
1
11 13
0 0 0 0 0 1 0 0 0 0 0 0 0
0 0 0 0 1 1 1 0 0 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 1 1 1 1 1 1 1 1 1 0 0 0
1 1 1 1 1 1 1 1 1 1 1 0 0
0 1 1 1 1 1 1 1 1 1 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 1 1 1 1 1 1 1 0 0 0 0
0 0 0 0 1 1 1 0 0 0 0 1 1
0 0 0 0 0 1 0 0 0 0 0 1 1
```

**output**
```
49
```

### DSA07041 - BIỂU THỨC ĐÚNG DÀI NHẤT

Cho biểu thức P chỉ bao gồm các ký tự mở ngoặc ‘(’ hoặc đóng ngoặc ‘)’. Biểu thức P có thể viết đúng hoặc không đúng. Nhiệm vụ của bạn là tìm tổng độ dài lớn nhất của các biểu thức con viết đúng trong P (các biểu thức đúng không nhất thiết phải liên tiếp nhau).

Chú ý: Độ dài của biểu thức đúng ngắn nhất là 2.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (không quá 100)
- Những dòng tiếp theo mỗi dòng đưa vào một bộ test. Mỗi bộ test là một biểu thức P được viết trên một dòng (độ dài của P không quá 100).

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
4
(()(
()()((
((()()())))
()(())(
```

**output**
```
2
4
10
6
```

### DSA07045 - BIỂU THỨC ĐÚNG DÀI NHẤT

Trong quá trình gõ một dòng văn bản, chúng ta thường sử dụng phím sang trái, sang phải hoặc xóa lùi (backspace). Cho một dãy ký tự mô tả các thao tác gõ phím, trong đó:

- Ký tự ‘-’ mô tả phím backspace (xóa lùi). Ký tự ở phía trước con trỏ (nếu có) sẽ bị xóa.
- Ký tự ‘<’ mô tả phím di chuyển sang trái. Con trỏ sẽ sang trái 1 ký tự nếu có thể.
- Ký tự ‘>’ mô tả phím di chuyển sang phải. Con trỏ sẽ sang phải 1 ký tự nếu có thể.
- Các ký tự khác là các chữ cái Tiếng Anh (in hoa hoặc in thường). Bàn phím để ở chế độ Insert. Tức là nếu con trỏ không ở cuối dòng thì khi chèn các ký tự sẽ đẩy các ký tự khác sang phải một vị trí.

Hãy thử tính toán và viết ra kết quả tương ứng.

**Input:** 

Có một dòng không quá 10<sup>6</sup> ký tự mô tả dãy gõ bàn phím.

**Output:** 

Ghi ra kết quả.

**input**
```
<<PI<T>>Ta-
```

**output**
```
PTIT
```

### DSA07110 - KIỂM TRA DÃY NGOẶC ĐÚNG

Cho một xâu chỉ gồm các kí tự ‘(‘, ‘)’, ‘[‘, ‘]’, ‘{‘, ‘}’. Một dãy ngoặc đúng được định nghĩa như sau:

- Xâu rỗng là 1 dãy ngoặc đúng.
- Nếu A là 1 dãy ngoặc đúng thì (A), [A], {A} là 1 dãy ngoặc đúng.
- Nếu A và B là 2 dãy ngoặc đúng thì AB là 1 dãy ngoặc đúng.

Cho một xâu S. Nhiệm vụ của bạn là xác định xâu S có là dãy ngoặc đúng hay không?

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 1 xâu S có độ dài không vượt quá 100 000.

**Output:** 
- Với mỗi test, in ra “YES” nếu như S là dãy ngoặc đúng, in ra “NO” trong trường hợp ngược lại.

**input**
```
2
[()]{}{[()()]()}
[(])
```

**output**
```
YES
NO
```

## Queue

### DSA08001 - CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 1

Ban đầu cho một queue rỗng. Bạn cần thực hiện các truy vấn sau:

1. Trả về kích thước của queue
2. Kiểm tra xem queue có rỗng không, nếu có in ra “YES”, nếu không in ra “NO”.
3. Cho một số nguyên và đẩy số nguyên này vào cuối queue.
4. Loại bỏ phần tử ở đầu queue nếu queue không rỗng, nếu rỗng không cần thực hiện.
5. Trả về phần tử ở đầu queue, nếu queue rỗng in ra -1.
6. Trả về phần tử ở cuối queue, nếu queue rỗng in ra -1.

**Input:** 
- Dòng đầu tiên chứa số nguyên T là số bộ dữ liệu, mỗi bộ dữ theo dạng sau.
- Dòng đầu tiên chứa số nguyên n - lượng truy vấn (1 ≤ n ≤ 1000)
- N dòng tiếp theo, mỗi dòng sẽ ghi loại truy vấn như trên, với truy vấn loại 3 sẽ có thêm một số nguyên, không quá 10<sup>6</sup>.

**Output:** 
- In ra kết quả của các truy vấn..

**input**
```
1
14
3 1
3 2
3 3
5
6
4
4
4
4
4
3 5
3 6
5
1
```

**output**
```
1
3
5
2
```

### DSA08002 - CẤU TRÚC DỮ LIỆU HÀNG ĐỢI 2

Yêu cầu bạn xây dựng một queue với các truy vấn sau đây:

“PUSH x”: Thêm phần tử x vào cuối của queue (0 ≤ x ≤ 1000).

“PRINTFRONT”: In ra phần tử đầu tiên của queue. Nếu queue rỗng, in ra “NONE”.

“POP”: Xóa phần tử ở đầu của queue. Nếu queue rỗng, không làm gì cả.

**Input:** 
- Dòng đầu tiên là số lượng truy vấn Q (Q ≤ 100000).
- Mỗi truy vấn có dạng như trên.

**Output:** 
- Với mỗi truy vấn “PRINT”, hãy in ra phần tử đầu tiên của queue. Nếu queue rỗng, in ra “NONE”.

**input**
```
9
PUSH 1
PUSH 2
POP
PRINTFRONT
PUSH 3
PRINTFRONT
POP
POP
PRINTFRONT
```

**output**
```
2
2
NONE
```

### DSA08003 - HÀNG ĐỢI HAI ĐẦU (DEQUEUE)

Yêu cầu bạn xây dựng một hàng đợi hai đầu với các truy vấn sau đây:

“PUSHFRONT x”: Thêm phần tử x vào đầu của dequeue (0 ≤ x ≤ 1000).

“PRINTFRONT”: In ra phần tử đầu tiên của dequeue. Nếu dequeue rỗng, in ra “NONE”.

“POPFRONT”: Xóa phần tử đầu của dequeue. Nếu dequeue rỗng, không làm gì cả.

“PUSHBACK x”: Thêm phần tử x vào cuối của dequeue (0 ≤ x ≤ 1000).

“PRINTBACK”: In ra phần tử cuối của dequeue. Nếu dequeue rỗng, in ra “NONE”.

“POPBACK”: Xóa phần tử cuối của dequeue. Nếu dequeue rỗng, không làm gì cả.

**Input:** 
- Dòng đầu tiên là số lượng truy vấn Q (Q ≤ 100000).
- Mỗi truy vấn có dạng như trên.

**Output:** 
- Với mỗi truy vấn “PRINTFRONT” và “PRINTBACK”, hãy in ra kết quả trên một dòng.

**input**
```
10
PUSHBACK 1
PUSHFRONT 2
PUSHBACK 3
PRINTFRONT
POPFRONT
PRINTFRONT
POPFRONT
PRINTBACK
POPFRONT
PRINTBACK
```

**output**
```
2
1
3
NONE
```

### DSA08004 - GIÁ TRỊ NHỎ NHẤT CỦA XÂU

Cho xâu ký tự S[] bao gồm các ký tự in hoa [A, B, …,Z]. Ta định nghĩa giá trị của xâu S[] là tổng bình phương số lần xuất hiện mỗi ký tự trong xâu. Ví dụ với xâu S[] = “AAABBCD” ta có F(S) = 3<sup>2</sup> + 2<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> = 15. Hãy tìm giá trị nhỏ nhất của xâu S[] sau khi loại bỏ K ký tự trong xâu.

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T (T≤100).
- Mỗi test được tổ chức thành 2 dòng. Dòng thứ nhất ghi lại số K. Dòng thứ 2 ghi lại xâu ký tự S[] có độ dài không vượt quá 10^6.

**Output:** 
- Đưa ra giá trị nhỏ nhất của mỗi test theo từng dòng.

**input**
```
2
0
ABCC
1
ABCC
```

**output**
```
6
3
```

### DSA08005 - SỐ NHỊ PHÂN TỪ 1 ĐẾN N

Cho số tự nhiên n. Hãy in ra tất cả các số nhị phân từ 1 đến n.

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T (T≤100).
- Mỗi test là một số tự nhiên n được ghi trên một dòng (n≤10000).

**Output:** 
- Đưa ra kết quả mỗi test trên một dòng.

**input**
```
2
2
5
```

**output**
```
1 10
1 10 11 100 101
```

### DSA08006 - SỐ 0 VÀ SỐ 9

Cho số tự nhiên N. Hãy tìm số nguyên dương X nhỏ nhất được tạo bởi số 9 và số 0 chia hết cho N. Ví dụ với N = 5 ta sẽ tìm ra  X = 90.

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T (T≤100).
- Những dòng kế tiếp mỗi dòng ghi lại một test. Mỗi test là một số tự nhiên N được ghi trên một dòng (N≤100).

**Output:** 
- Đưa ra theo từng dòng số X nhỏ nhất chia hết cho N tìm được .

**input**
```
2
5
7
```

**output**
```
90
9009
```

### DSA08007 - SỐ BDN 1

Ta gọi số nguyên dương K là một số BDN nếu các chữ số trong K chỉ bao gồm các 0 hoặc 1 có nghĩa. Ví dụ số K = 1, 10, 101. Cho số tự nhiên N (N<2<sup>63</sup>). Hãy cho biết có bao nhiêu số BDN nhỏ hơn N. Ví dụ N=100 ta có 4 số BDN bao gồm các số: 1, 10, 11, 100.

**Input:** 
- Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
- T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một số tự nhiên N.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
10
100
200
```

**output**
```
2
4
7
```

### DSA08008 - SỐ BDN 2

Ta gọi số nguyên dương K là một số BDN nếu các chữ số trong K chỉ bao gồm các 0 hoặc 1 có nghĩa. Ví dụ số K =  101 là số BDN, k=102 không phải là số BDN.

Số BDN của N là số P =M*N sao cho P là số BDN. Cho số tự nhiên N (N<1000), hãy tìm số BDN nhỏ nhất của N.

Ví dụ. Với N=2, ta tìm được số BDN của N là P = 5 * 2 = 10. N = 17 ta tìm được số BDN của 17 là P = 653 * 17 = 11101.

**Input:** 
- Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
- T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một số tự nhiên N.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
2
12
17
```

**output**
```
10
11100
11101
```

### DSA08009 - BIẾN ĐỔI S – T

Cho hai số nguyên dương S và T (S, T<10000) và hai thao tác (a), (b) dưới đây:

Thao tác (a): Trừ S đi 1  (S = S-1) ;

Thao tác (b): Nhân S với 2 ( S = S*2);

Hãy dịch chuyển S thành T sao cho số lần thực hiện các thao tác (a), (b) là ít nhất. Ví dụ với    S =2, T=5 thì số các bước ít nhất để dịch chuyển S thành T thông qua 4 thao tác sau:

Thao tác (a): 2*2 = 4;

Thao tác (b): 4-1 = 3;

Thao tác (a): 3*2 = 6;

Thao tác (b): 6-1 = 5;

**Input:** 
- Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
- T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một bộ đôi S và T.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
2 5
3 7
7 4
```

**output**
```
4
4
3
```

### DSA08010 - BIẾN ĐỔI SỐ TỰ NHIÊN

Cho số tự nhiên N (N<10^9) và hai phép biến đổi (a), (b) dưới đây.

- Thao tác (a): Trừ N đi 1 (N=N-1). Ví dụ N=17, thao tác (a) biến đổi N = N-1 =16.
- Thao tác (b): N = max(u,v) nếu u*v =N (u>1, v>1). Ví dụ N=16, thao tác (b) có thể biến đổi N = max(2, 8)=8 hoặc N=max(4, 4)=4.

Chỉ được phép sử dụng hai thao tác (a) hoặc (b), hãy biến đổi N thành 1 sao số các thao tác (a), (b) được thực hiện ít nhất. Ví dụ với N=17, số các phép (a), (b) nhỏ nhất biến đổi N thành 1 là 4 bước như sau:

- Thao tác (a): N = N-1 = 17-1 = 16
- Thao tác (b): 16 = max(4,4) = 4
- Thao tác (b): 4 = max(2,2) = 2
- Thao tác (a): 2 = 2-1 = 1

**Input:** 
- Dòng đầu tiên ghi lại số tự nhiên T là số lượng Test;
- T dòng kế tiếp mỗi dòng ghi lại một bộ Test. Mỗi test là một số N.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
17
50
100
```

**output**
```
4
5
5
```

### DSA08011 - KHOẢNG CÁCH XÂU KÝ TỰ

Cho tập n xâu ký tự S và hai xâu s, t ∈ S. Ta giả thiết các xâu ký tự S[i] ∈ S có độ dài bằng nhau.  Hãy tìm khoảng cách đường đi ngắn nhất từ s đến t. Biết từ một xâu ký tự bất kỳ ta chỉ được phép dịch chuyển đến xâu khác với nó duy nhất 1 ký tự. Ví dụ ta có tập các từ S = { POON, TOON, PLEE, SAME, POIE, PLEA, PLIE, POIN }, s = TOON, t = PLEA ta có độ dài đường đi ngắn nhất là 7 tương ứng với các phép dịch chuyển : TOON -> POON –> POIN –> POIE –> PLIE –> PLEE –> PLEA.

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T (T≤100).
- Mỗi test được tổ chức thành 2 dòng. Dòng thứ nhất ghi lại n là số từ trong S và hai từ s, t.  Dòng thứ 2 đưa vào n xâu xâu ký tự của S; các xâu ký tự được viết cách nhau một vài khoảng trống, có độ dài không vượt quá 10 kí tự.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
1
8 TOON  PLEA
POON TOON PLEE SAME  POIE  PLEA  PLIE  POIN
```

**output**
```
7
```

### DSA08012 - TÌM SỐ K THỎA MÃN ĐIỀU KIỆN

Cho hai số nguyên dương L, R. Hãy đưa ra số các số K trong khoảng [L, R] thỏa mãn điều kiện:

- Tất cả các chữ số của K đều khác nhau.
- Tất cả các chữ số của K đều nhỏ hơn hoặc bằng 5.

Ví dụ với L = 4, R = 13 ta có 5 số thỏa mãn yêu cầu là 4, 5, 10, 12, 13,

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T.
- Dòng tiếp theo đưa vào các bộ test. Mỗi bộ test được là một cặp L, R được viết trên một dòng.
- T, L, R thỏa mãn ràng buộc: 1≤T≤100; 0≤L≤R≤10<sup>5</sup>.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4 13
100 1000
```

**output**
```
5
100
```

### DSA08013 - DI CHUYỂN TRÁNH VẬT CẢN

Cho một bảng kích thước N x N, trong đó có các ô trống ‘.’ và vật cản ‘X’. Các hàng và các cột được đánh số từ 0.

Mỗi bước di chuyển, bạn có thể đi từ ô (x, y) tới ô (u, v) nếu như 2 ô này nằm trên cùng một hàng hoặc một cột, và không có vật cản nào ở giữa.

Cho điểm xuất phát và điểm đích. Bạn hãy tính số bước di chuyển ít nhất?

**Input:** 
- Dòng đầu ghi số bộ test (không quá 10). Mỗi test gồm:
  - Dòng đầu tiên là số nguyên dương N (1 ≤ N ≤ 100).
  - N dòng tiếp theo, mỗi dòng gồm N kí tự mô tả bảng.
  - Cuối cùng là 4 số nguyên a, b, c, d với (a, b) là tọa độ điểm xuất phát, (c, d) là tọa độ đích. Dữ liệu đảm bảo hai vị trí này không phải là ô có vật cản.

**Output:** 
- Với mỗi test, in ra một số nguyên là đáp số của bài toán.

**input**
```
1
3
.X.
.X.
...
0 0 0 2
```

**output**
```
3
```

### DSA08014 - GIEO MẦM

Trên một giá có kích thước R x C (R hàng, C cột), một số hạt mầm đã được tra vào các ô. Một số hạt mầm được bón thêm chất dinh dưỡng, nên đã nảy mầm sớm thành cây non.

Mỗi ngày, các cây non sẽ lan truyền chất dinh dưỡng của nó cho các mầm ở ô xung quanh (trái, trên, phải, dưới), làm cho các hạt mầm này phát triển thành cây non. Tuy nhiên, có thể có một số hạt mầm được gieo ở vị trí lẻ loi, do không nhận được chất dinh dưỡng nên không thể nảy mầm.

Các bạn hãy xác định xem cần ít nhất bao nhiêu ngày để tất cả các hạt đều mầm?

**Input:** 
- Dòng đầu ghi số bộ test (không quá 10). Mỗi bộ test gồm:
  - Dòng đầu tiên gồm 2 số nguyên R và C (1 ≤ R, C ≤ 500).
  - R dòng tiếp theo, mỗi dòng gồm C số nguyên A[i][j].
  - A[i][j] = 0, ô (i, j) là ô trống.
  - A[i][j] = 1, ô (i, j) là hạt chưa nảy mầm.
  - A[i][j] = 2, ô (i, j) là cây non.

**Output:** 
- Với mỗi test in ra thời gian ngắn nhất để tất cả các hạt đều nảy mầm. Nếu có hạt nào chưa nảy mầm, in ra -1.

**input**
```
2
3 5
2 1 0 2 1
1 0 1 2 1
1 0 0 2 1
3 5
2 1 0 2 1
0 0 1 2 1
1 0 0 2 1
```

**output**
```
2
-1
```

### DSA08015 - DI CHUYỂN TRONG KHÔNG GIAN

Cho một hình hộp chữ nhật có kích thước A x B x C, trong đó A là chiều cao, B là chiều rộng và C là chiều dài. Mỗi ô có thể là một ô trống ‘.’ hoặc vật cản ‘#’.

Mỗi bước, bạn được phép di chuyển sang một ô kề bên cạnh (không được đi chéo). Nhiệm vụ của bạn là tìm đường đi ngắn nhất bắt đầu ‘S’ tới vị trí kết thúc ‘E’.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (1 ≤ N ≤ 50).
- Mỗi test bắt đầu bởi 3 số nguyên A, B, C (A, B, C ≤ 30).
- Tiếp theo là A khối, mỗi khối gồm B x C kí tự mô tả một lát cắt của hình hộp chữ nhật. Giữa 2 khối có một dấu xuống dòng.

**Output:** 
- In ra một số nguyên là đường đi ngắn nhất từ S tới E. Nếu không di chuyển được, in ra -1.

**input**
```
2
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###
```

**output**
```
11
-1
```

### DSA08016 - HEXGAME

HEXGAME là một trò chơi xếp hình gồm 10 miếng ghép hình lục giác đều, trên mỗi miếng ghép được điền một số nguyên, có 8 miếng được điền số  từ 1 đến 8 và có hai miếng điền số 0. Các miếng liên kết với nhau tạo thành lưới tổ ong. Ban đầu các miếng ghép ở vị trí như hình vẽ. Tại mỗi bước, chọn một miếng ghép có đúng 6 miếng ghép kề cạnh làm tâm, rồi xoay một nấc 6 miếng ghép kề cạnh đó theo chiều kim đồng hồ. Như vậy chỉ có hai cách chọn tâm, đó là chọn tâm bên trái và chọn tâm bên phải.

![download](https://user-images.githubusercontent.com/64203006/165966213-7f176848-3767-4aa8-800e-06d62a8781ca.png)

Yêu cầu: Cho một trạng thái của trò chơi (nhận được sau một dãy biến đổi từ trạng thái ban đầu), hãy tính số phép biến đổi ít nhất để đưa về trạng thái ban đầu.

**Input:** 
- Dòng đầu ghi số bộ test (không quá 10). Mỗi bộ test gồm:
  - Dòng đầu tiên chứa 3 số ở 3 miếng ghép dòng thứ nhất (thứ tự từ trái qua phải).
  - Dòng thứ hai chứa 4 số ở 4 miếng ghép dòng thứ hai (thứ tự từ trái qua phải).
  - Dòng thứ 3 chứa 3 số ở 3 miếng ghép dòng thứ ba (thứ tự từ trái qua phải).

**Output:** 
- Với mỗi bộ test in ra một số nguyên là số phép biến đổi ít nhất để đưa được về trạng thái ban đầu.

**input**
```
1
1 0 2
8 6 0 3
7 5 4
```

**output**
```
5
```

### DSA08017 - SỐ LỘC PHÁT 1

Một số được gọi là lộc phát nếu chỉ có 2 chữ số 6 và 8. Cho số tự nhiên N. Hãy liệt kê các số lộc phát có không quá N chữ số.

**Input:** 
- Dòng đầu tiên ghi lại số tự nhiên T là số lượng bộ test (T<10);
- T dòng kế tiếp mỗi dòng ghi số N (1<N<15).

**Output:** 
- In ra đáp án theo thứ tự giảm dần.

**input**
```
2
2
3
```

**output**
```
88 86 68 66 8 6
888 886 868 866 688 686 668 666 88 86 68 66 8 6
```

### DSA08018 - SỐ LỘC PHÁT 2

Một số được gọi là lộc phát nếu chỉ có 2 chữ số 6 và 8. Cho số tự nhiên N. Hãy liệt kê các số lộc phát có không quá N chữ số.

**Input:** 
- Dòng đầu tiên ghi lại số tự nhiên T là số lượng bộ test (T<10);
- T dòng kế tiếp mỗi dòng ghi số N (1<N<15).

**Output:** 
- Dòng đầu tiên là số lượng số lộc phát tìm được. Dòng thứ hai in đáp án theo thứ tự tăng dần.

**input**
```
2
2
3
```

**output**
```
6
6 8 66 68 86 88
14
6 8 66 68 86 88 666 668 686 688 866 868 886 888
```

### DSA08019 - SỐ LỘC PHÁT 3

Một số được gọi là lộc phát nếu chỉ có 2 chữ số 6 và 8. Cho số tự nhiên N. Hãy liệt kê các số lộc phát có không quá N chữ số.

**Input:** 
- Dòng đầu tiên ghi lại số tự nhiên T là số lượng bộ test (T<10);
- T dòng kế tiếp mỗi dòng ghi số N (1<N<15).

**Output:** 
- Dòng đầu tiên là số lượng số lộc phát tìm được. Dòng thứ hai in ra đáp án theo thứ tự giảm dần.

**input**
```
2
2
3
```

**output**
```
6
88 86 68 66 8 6
14
888 886 868 866 688 686 668 666 88 86 68 66 8 6
```

### DSA08020 - BIẾN ĐỔI SỐ NGUYÊN TỐ

Cho cặp số S và T là các số nguyên tố có 4 chữ số (Ví dụ S = 1033, T = 8197 là các số nguyên tố có 4 chữ số). Hãy viết chương trình tìm cách dịch chuyển S thành T thỏa mãn đồng thời những điều kiện dưới đây:

1. Mỗi phép dịch chuyển chỉ được phép thay đổi một chữ số của số ở bước trước đó (ví dụ nếu S=1033 thì phép dịch chuyển S thành 1733 là hợp lệ);
2. Số nhận được cũng là một số nguyên tố có 4 chữ số (ví dụ nếu S=1033 thì phép dịch chuyển S thành 1833 là không hợp lệ, và S dịch chuyển thành 1733 là hợp lệ);
3. Số các bước dịch chuyển là ít nhất.

Ví dụ số các phép dịch chuyển ít nhất để S = 1033 thành  T = 8179 là 6 bao gồm các phép dịch chuyển như sau:       

8179 <- 8779 <- 3779 <- 3739 <- 3733 <- 1733 <- 1033.


**Input:** 
- Dòng đầu tiên đưa vào số lượng test T (T≤100)
- Những dòng kế tiếp mỗi dòng đưa vào một test. Mỗi test là một bộ đôi S, T.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
1033 8179
1033 8779
```

**output**
```
6
5
```

### DSA08021 - DI CHUYỂN TRONG MA TRẬN

Cho ma trận A[M][N]. Nhiệm vụ của bạn hãy tìm số bước đi ít nhất dịch chuyển từ vị trí A[1][1] đến vị trí A[M][N]. Biết mỗi bước đi ta chỉ được phép dịch chuyển đến vị trí A[i][j+A[i][j]] hoặc vị trí A[i+A[i][j]][j] bên trong ma trận.

**Input:** 
- Dòng đầu tiên đưa vào số lượng test T.
- Dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất là hai số M, N; phần thứ hai là các phần tử của ma trận A[][]; các số được viết cách nhau một vài khoảng trống.
- T, M, N, A[i][j] thỏa mãn ràng buộc: 1≤T≤100; 1≤M, N, A[i][j]≤10<sup>3</sup>.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng. In ra -1 nếu không tìm được đáp án.

**input**
```
1
3 3
2 1 2
1 1 1
1 1 1
```

**output**
```
2
```

### DSA08022 - BỘI SỐ LỚN NHẤT CỦA 3

Cho dãy số A[] có N phần tử là các chữ số từ 0 đến 9. Nhiệm vụ của bạn là hãy chọn lấy một tổ hợp các phần tử và sắp xếp chúng sao cho thu được số lớn nhất chia hết cho 3.

Nếu không tìm được số nào, in ra -1.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (1 ≤ N ≤ 50).
- Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 100 000).
- Dòng tiếp theo gồm N số nguyên A[i] (0 ≤ A[i] ≤ 9).

**Output:** 
- Với mỗi test, in ra đáp án tìm được trên một dòng.

**input**
```
3
3
8 1 9
5
8 1 7 6 0
2
5 2
5
2 2 1 1 1
```

**output**
```
981
8760
-1
2211
```

### DSA08025 - QUÂN MÃ

Cho một quân mã trên bàn cờ vua tại vị trí ST. Nhiệm vụ của bạn là hãy tìm số bước di chuyển ít nhất để đưa quân mã tới vị trí EN.

![download](https://user-images.githubusercontent.com/64203006/165969742-543ef438-3a51-416f-a1b6-ea64dc9830b5.png)


**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 2 xâu dạng “xy” và “uv”, trong đó x, y là kí tự trong “abcdefgh” còn y, v là số thuộc 1, 2, 3, 4, 5, 6, 7, 8.

**Output:** 
- Với mỗi test, in ra đáp án tìm được trên một dòng.

**input**
```
8
e2 e4
a1 b2
b2 c3
a1 h8
a1 h7
h8 a1
b1 c3
f6 f6
```

**output**
```
2
4
2
6
5
6
1
0
```

### DSA08029 - QUAY HÌNH VUÔNG

Có một chiếc bảng hình chữ nhật với 6 miếng ghép, trên mỗi miếng ghép được điền một số nguyên trong khoảng từ 1 đến 6. Tại mỗi bước, chọn một hình vuông (bên trái hoặc bên phải), rồi quay theo chiều kim đồng hồ.

![download](https://user-images.githubusercontent.com/64203006/165971824-6a62601a-f4ea-4e81-ab54-978c348bc794.png)

Yêu cầu: Cho một trạng thái của bảng, hãy tính số phép biến đổi ít nhất để đưa bảng đến trạng thái đích.

**Input:** 
- Dòng đầu ghi số bộ test (không quá 10). Mỗi bộ test gồm hai dòng:
  - Dòng đầu tiên chứa 6 số là trạng thái bảng ban đầu (thứ tự từ trái qua phải, dòng 1 tới dòng 2).
  - Dòng thứ hai chứa 6 số là trạng thái bảng đích (thứ tự từ trái qua phải, dòng 1 tới dòng 2).

**Output:** 
- Với mỗi test, in ra một số nguyên là đáp số của bài toán.

**input**
```
1
1 2 3 4 5 6
4 1 2 6 5 3
```

**output**
```
2
```

### DSA08045 - HÀNG RÀO

Trên cánh đồng có N hàng rào. Mỗi hàng rào được miêu tả bằng một đoạn thẳng đứng hoặc ngang trong mặt phẳng hai chiều. Nếu hai hàng rào gặp nhau, chúng chỉ có thể gặp nhau ở đầu mút của đoạn thẳng. Mỗi hàng rào chỉ giao với hai hàng rào khác tại các kiểu đầu mút của đoạn thẳng.

Có M chú bò đang ăn cỏ trên cánh đồng. Mỗi chú bò được thể hiện bằng một điểm trên mặt phẳng tọa độ hai chiều. Input đảm bảo không có chú bò nào nằm trên đoạn thẳng đại diện cho các hàng rào, và không có hai chú bò có cùng tọa độ. Các chú bò có thể di chuyển tự do trong vùng bao quanh bởi các hàng rào và tạo thành bầy đàn.

Các bạn hãy tìm xem đàn bò nào có số lượng nhiều nhất?

**Input:** 
- Dòng đầu ghi số bộ test (không quá 10). Mỗi bộ test như sau:
  - Dòng đầu tiên là 2 số N, M (1 <= N, M <= 500).
  - N dòng tiếp theo, mỗi dòng gồm 4 số nguyên Ax, Ay, Bx, By mô tả tọa độ của một hàng rào.
  - M dòng tiếp theo, mỗi dòng gồm 2 số nguyên Cx, Cy mô tả tọa độ của một chú bò.
  - Các tọa độ có giá trị trong khoảng từ 0 tới 10^6.

**Output:** 
- In ra số lượng lớn nhất có thể của một đàn bò.

**input**
```
1
7 3
0 0 10 0
10 0 10 5
12 5 10 5
10 5 1 5
12 5 12 7
0 7 12 7
0 7 0 0
3 4
6 6
17 3
```

**output**
```
2
```

## Graph

###	DSA09001 - CHUYỂN DANH SÁCH CẠNH SANG DANH SÁCH KỀ

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết chương trình thực hiện chuyển đổi biểu diễn đồ thị dưới dạng danh sách kề.

**Input:**
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:**
- Đưa ra danh sách kề của các đỉnh tương ứng theo khuôn dạng của ví dụ dưới đây. Các đỉnh trong danh sách in ra theo thứ tự tăng dần.

**input**
```
1
6 9
1 2
1 3 
2 3
2 5
3 4
3 5
4 5
4 6
5 6
```

**output**
```
1: 2 3
2: 1 3 5
3: 1 2 4 5
4: 3 5 6
5: 2 3 4 6
6: 4 5
```

###	DSA09002 - CHUYỂN TỪ DANH SÁCH KỀ SANG DANH SÁCH CẠNH

Cho đơn đồ thị G vô hướng liên thông được mô tả bởi danh sách kề. Hãy in ra danh sách cạnh tương ứng của G.

**Input:**
- Dòng đầu tiên ghi số N là số đỉnh (1<N<50)
- N dòng tiếp theo mỗi dòng ghi 1 danh sách kề lần lượt theo thứ tự từ đỉnh 1 đến đỉnh N

**Output:**
- Ghi ra lần lượt từng cạnh của đồ thị theo thứ tự tăng dần.

**input**
```
3
2 3
1 3
1 2
```

**output**
```
1 2
1 3
2 3
```

###	DSA09003 - BIỂU DIỄN ĐỒ THỊ CÓ HƯỚNG.

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết chương trình thực hiện chuyển đổi biểu diễn đồ thị dưới dạng danh sách kề.

**Input:**
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:**
- Đưa ra danh sách kề của các đỉnh tương ứng theo khuôn dạng của ví dụ dưới đây. Các đỉnh trong danh sách in ra theo thứ tự tăng dần.

**input**
```
1
6 9
1 2
2 5
3 1
3 2
3 5
4 3
5 4
5 6
6 4
```

**output**
```
1: 2
2: 5
3: 1 2 5
4: 3
5: 4 6
6: 4
```

###	DSA09004 - DFS TRÊN ĐỒ THỊ VÔ HƯỚNG

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều sâu bắt đầu tại đỉnh u∈V (DFS(u)=?)

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra danh sách các đỉnh được duyệt theo thuật toán DFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây.

**input**
```
1
6 9 5
1 2
1 3
2 3
2 4
3 4
3 5
4 5
4 6
5 6
```

**output**
```
5 3 1 2 4 6
```

###	DSA09005 - BFS TRÊN ĐỒ THỊ VÔ HƯỚNG

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều sâu bắt đầu tại đỉnh u∈V (BFS(u)=?)

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra danh sách các đỉnh được duyệt theo thuật toán BFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây.

**input**
```
1
6 9 1
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
```

**output**
```
1 2 3 5 4 6
```

###	DSA09006 - ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ VÔ HƯỚNG

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh s∈V đến đỉnh t∈V trên đồ thị bằng thuật toán DFS.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán DFS của mỗi test theo khuôn dạng của ví dụ dưới đây. Nếu không có đáp án, in ra -1.

**input**
```
1
6 9 1 6
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
```

**output**
```
1 2 3 4 5 6
```

###	DSA09007 - ĐƯỜNG ĐI THEO BFS VỚI ĐỒ THỊ VÔ HƯỚNG

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh s∈V đến đỉnh t∈V trên đồ thị bằng thuật toán BFS.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán BFS của mỗi test theo khuôn dạng của ví dụ dưới đây. Nếu không có đáp án, in ra -1.

**input**
```
1
6 9 1 6
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
```

**output**
```
1 2 5 6
```

###	DSA09008 - ĐẾM SỐ THÀNH PHẦN LIÊN THÔNG

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm số thành phần liên thông của đồ thị.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra số thành phần liên thông của đồ thị.

**input**
```
1
5 6 
1 2 1 3 2 3 3 4 3 5 4 5
```

**output**
```
1
```

###	DSA09009 - TÌM SỐ THÀNH PHẦN LIÊN THÔNG VỚI BFS

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm số thành phần liên thông của đồ thị bằng thuật toán BFS.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra số thành phần liên thông của đồ thị bằng thuật toán BFS.

**input**
```
1
6 6 
1 2 1 3 2 3 3 4 3 5 4 5
```

**output**
```
2
```

###	DSA09010 - KIỂM TRA TÍNH LIÊN THÔNG MẠNH

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có liên thông mạnh hay không?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra “YES”, hoặc “NO” theo từng dòng tương ứng với test là liên thông mạnh hoặc không liên thông mạnh.

**input**
```
1
6 9 
1 2 2 4 3 1 3 2 3 5 4 3 5 4 5 6 6 3
```

**output**
```
YES
```

### DSA09011 - SỐ LƯỢNG HÒN ĐẢO

Cho một bản đồ kích thước N x M được mô tả bằng ma trận A[][].A[i][j] = 1 có nghĩa vị trí (i, j) là nổi trên biển. 2 vị trí (i, j) và (x, y) được coi là liền nhau nếu như nó có chung đỉnh hoặc chung cạnh. Một hòn đảo là một tập hợp các điểm (i, j) mà A[i][j] = 1 và có thể di chuyển giữa hai điểm bất kì trong đó.

Nhiệm vụ của bạn là hãy đếm số lượng đảo xuất hiện trên bản đồ.

**Input:**
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi 2 số nguyên N và M (1 ≤ N, M ≤ 500).
- N dòng tiếp theo, mỗi dòng gồm M số nguyên A[i][j].

**Output:**
- Với mỗi test, in ra số lượng hòn đảo tìm được.

**input**
```
1
5 5
1 1 0 0 0
0 1 0 0 1
1 0 0 1 1
0 0 0 0 0
1 0 1 0 1
```

**output**
```
5
```

###	DSA09012 - LIỆT KÊ ĐỈNH TRỤ

Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy đưa ra tất cả các đỉnh trụ của đồ thị?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra danh sách các đỉnh trụ của mỗi test  theo từng dòng.

**input**
```
1
5 5
1 2 1 3 2 3 2 5 3 4
```

**output**
```
2 3
```

###	DSA09013 - LIỆT KÊ CẠNH CẦU

Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy đưa ra tất cả các cạnh cầu của đồ thị?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra danh sách các cạch cầu của mỗi test theo từng dòng. In ra đáp án theo thứ tự từ điển, theo dạng “a b …” với a < b.

**input**
```
1
5 5
1 2 
1 3
2 3
2 5
3 4
```

###	DSA09014 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ VÔ HƯỚNG

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có tồn tại chu trình hay không?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.

**input**
```
1
6  9
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
```

**output**
```
YES
```

###	DSA09015 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có tồn tại chu trình hay không?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.

**input**
```
1
6 9  
1 2 2 4 3 1 3 2 3 5 4 3 5 4 5 6 6 4
```

**output**
```
YES
```

###	DSA09016 - KIỂM TRA CHU TRÌNH TRÊN ĐỒ THỊ CÓ HƯỚNG VỚI DFS

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng thuật toán DFS, hãy kiểm tra xem đồ thị có tồn tại chu trình hay không?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E| +1 dòng: dòng đầu tiên đưa vào ba số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị, và u là đỉnh xuất phát; |E| dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.

**input**
```
1
6 9  
1 2 2 4 3 1 3 2 3 5 4 3 5 4 5 6 6 4
```

**output**
```
YES
```

###	DSA09017 - KIỂM TRA ĐỒ THỊ CÓ PHẢI LÀ CÂY HAY KHÔNG

Một đồ thị N đỉnh là một cây, nếu như nó có đúng N-1 cạnh và giữa 2 đỉnh bất kì, chỉ tồn tại duy nhất 1 đường đi giữa chúng.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 1000).
- N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối giữa đỉnh u và v.

**Output:** 
- Với mỗi test, in ra “YES” nếu đồ thị đã cho là một cây, in ra “NO” trong trường hợp ngược lại.

**input**
```
2
4
1 2
1 3
2 4
4
1 2
1 3
2 3
```

**output**
```
YES
NO
```

###	DSA09020 - CHUYỂN DANH SÁCH KỀ SANG MA TRẬN KỀ

Cho đơn đồ thị vô hướng có n đỉnh dưới dạng danh sách kề.

Hãy biểu diễn đồ thị bằng ma trận kề.

**Input:** 
Dòng đầu tiên chứa số nguyên n – số đỉnh của đồ thị (1 ≤  n ≤  1000). n dòng tiếp theo, dòng thứ i chứa các số nguyên là các đỉnh kề với đỉnh i.  

**Output:** 
Ma trận kề của đồ thị.

**input**
```
3
2 3
1 3
1 2
```

**output**
```
0 1 1
1 0 1
1 1 0
```

###	DSA09021 - CHUYỂN MA TRẬN KỀ SANG DANH SÁCH KỀ

Ma trận kề A của một đồ thị vô hướng là một ma trận chỉ có các số 0 hoặc 1 trong đó A[i][j] = 1 có ý nghĩa là đỉnh i kề với đỉnh j (chỉ số tính từ 1).

Danh sách kề thì liệt kê các đỉnh kề với đỉnh đó theo thứ tự tăng dần.

Hãy chuyển biểu diễn đồ thị từ dạng ma trận kề sang dạng danh sách kề.

**Input:** 
Dòng đầu tiên chứa số nguyên n – số đỉnh của đồ thị (1 < n ≤ 1000). n dòng tiếp theo, mỗi dòng có n số nguyên có giá trị 0 và 1 mô tả ma trận kề của đồ thị. 

**Output:** 
Gồm n dòng, dòng thứ i chứa các số nguyên là đỉnh có nối với đỉnh i và được sắp xếp tăng dần. Dữ liệu đảm bảo mỗi đỉnh có kết nối với ít nhất 1 đỉnh khác.

**input**
```
3
0 1 1
1 0 1
1 1 0
```

**output**
```
2 3
1 3
1 2
```

###	DSA09022 - DFS TRÊN ĐỒ THỊ CÓ HƯỚNG

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều sâu bắt đầu tại đỉnh u∈V (DFS(u)=?)

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào ba số |V|, |E|, u∈V tương ứng với số đỉnh, số cạnh và đỉnh bắt đầu duyệt; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra danh sách các đỉnh được duyệt theo thuật toán DFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây.

**input**
```
1
6 9 5
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 3
```

**output**
```
5 4 3 1 2 6
```

###	DSA09024 - BFS TRÊN ĐỒ THỊ CÓ HƯỚNG

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy viết thuật toán duyệt theo chiều sâu bắt đầu tại đỉnh u∈V (BFS(u)=?)

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào ba số |V|, |E|, u∈V tương ứng với số đỉnh, số cạnh và đỉnh bắt đầu duyệt; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra danh sách các đỉnh được duyệt theo thuật toán BFS(u) của mỗi test theo khuôn dạng của ví dụ dưới đây.

**input**
```
1
6 9 1
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 4
```

**output**
```
1 2 5 4 6 3
```

###	DSA09025 - ĐƯỜNG ĐI THEO DFS VỚI ĐỒ THỊ CÓ HƯỚNG

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh s∈V đến đỉnh t∈V trên đồ thị bằng thuật toán DFS.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào ba số |V|, |E|, u∈V tương ứng với số đỉnh, số cạnh và đỉnh bắt đầu duyệt; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán DFS của mỗi test theo khuôn dạng của ví dụ dưới đây. Nếu không có đáp án, in ra -1.

**input**
```
1
6 9 1 6
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 4
```

**output**
```
1 2 5 6
```

###	DSA09026 - ĐƯỜNG ĐI THEO BFS VỚI ĐỒ THỊ CÓ HƯỚNG

Cho đồ thị có hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy tìm đường đi từ đỉnh s∈V đến đỉnh t∈V trên đồ thị bằng thuật toán BFS.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào ba số |V|, |E|, u∈V tương ứng với số đỉnh, số cạnh và đỉnh bắt đầu duyệt; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤200; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra đường đi từ đỉnh s đến đỉnh t của mỗi test theo thuật toán BFS của mỗi test theo khuôn dạng của ví dụ dưới đây. Nếu không có đáp án, in ra -1.

**input**
```
1
6 9 1 6
1 2 2 5 3 1 3 2 3 5 4 3 5 4 5 6 6 4
```

**output**
```
1 2 5 6
``` 

###	DSA09027 - KIỂM TRA ĐƯỜNG ĐI

Cho đồ thị vô hướng có N đỉnh và M cạnh. Có Q truy vấn, mỗi truy vấn yêu cầu trả lời câu hỏi giữa 2 đỉnh x và y có tồn tại đường đi tới nhau hay không?

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test gồm 2 số nguyên N, M (1 ≤ N, M ≤ 1000).
- M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối giữa đỉnh u và v.
- Dòng tiếp là số lượng truy vấn Q (1 ≤ Q ≤ 1000).
- Q dòng tiếp theo, mỗi dòng gồm 2 số nguyên x và y.

**Output:** 
- Với mỗi truy vấn, in ra “YES” nếu có đường đi từ x tới y, in ra “NO” nếu ngược lại.

**input**
```
1
6 5
1 2
2 3
3 4
1 4
5 6
2
1 5
2 4
```

**output**
```
NO
YES
``` 

###	DSA09028 - TÔ MÀU ĐỒ THỊ

Một trong những bài toán kinh điển của lý thuyết đồ thị là bài toán Tô màu đồ thị. Bài toán được phát biểu như sau: Cho đồ thị vô hướng G =<V, E> được biểu diễn dưới dạng danh sách cạnh và số M. Nhiệm vụ của bạn là kiểm tra xem đồ thị có thể tô màu các đỉnh bằng nhiều nhất M màu sao cho hai đỉnh kề nhau đều có màu khác nhau hay không?

![mcolor](https://user-images.githubusercontent.com/64203006/168848471-8c83421f-919a-46d1-ad94-39610c19d5d9.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào ba số V, E, M tương ứng với số đỉnh, số cạnh và số màu; phần thứ hai đưa vào các cạnh của đồ thị.
- T, V, E, M thỏa mãn ràng buộc: 1≤T ≤100; 1≤V≤10; 1≤ E ≤N(N-1), 1≤V≤N.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
4 5 3
1 2
2 3
3 4
4 1
1 3
3 3 2
1 2
2 3
1 3
```

**output**
```
YES
NO
``` 

###	DSA09029 - ĐƯỜNG ĐI HAMILTON

Đường đi đơn trên đồ thị có hướng hoặc vô hướng đi qua tất cả các đỉnh của đồ thị mỗi đỉnh đúng một lần được gọi là đường đi Hamilton. Cho đồ thị vô hướng G = <V, E>, hãy kiểm tra xem đồ thị có đường đi Hamilton hay không?

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào hai số V, E tương ứng với số đỉnh, số cạnh của đồ thị; phần thứ hai đưa vào các cạnh của đồ thị.
- T, V, E thỏa mãn ràng buộc: 1≤T ≤100; 1≤V≤10; 1≤ E ≤15.

**Output:** 
- Đưa ra 1 hoặc 0 tương ứng với test có hoặc không có đường đi Hamilton theo từng dòng.

**input**
```
2
4 4
1 2 2 3 3 4 2 4
4 3
1 2 2 3 2 4
```

**output**
```
1
0
``` 

###	DSA09030 - ĐỒ THỊ HAI PHÍA

Đồ thị hai phía là một đồ thị đặc biệt, trong đó tập các đỉnh có thể được chia thành hai tập không giao nhau thỏa mãn điều kiện không có cạnh nối hai đỉnh bất kỳ thuộc cùng một tập. Cho đồ thị N đỉnh và M cạnh, bạn hãy kiểm tra đồ thị đã cho có phải là một đồ thị hai phía hay không?

![download](https://user-images.githubusercontent.com/64203006/168848951-c7396d42-f9cd-47c2-ad13-531dd3d21585.png)

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤  20).
- Mỗi test bắt đầu bởi số nguyên N và M (1 ≤  N, M ≤  1000).
- M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối giữa đỉnh u và v.

**Output:** 
- Với mỗi test, in ra “YES” nếu đồ thị đã cho là một đồ thị hai phía, in ra “NO” trong trường hợp ngược lại.

**input**
```
2
5 4
1 5
1 3
2 3
4 5
3 3
1 2
1 3
2 3
```

**output**
```
YES
NO
``` 

###	DSA09031 - CHÚ CỪU XA CÁCH

Trên cánh đồng kích thước N x N có K chú cừu. Người nông dân sợ các chú cừu đi lạc nên đã làm một số rào chắn giữa các khu vực. Các chú cừu chỉ có thể di chuyển lên trên, xuống dưới, sang trái, sang phải khu vực bên cạnh, và không thể vượt qua được hàng rào.

Hai chú cừu A và B được gọi là ‘xa cách’ nếu như chúng không thể di chuyển tới vị trí của nhau. Các bạn hãy xác định xem số cặp chú cừu xa cách bằng nhau nhiêu?


**Input:** 
Dòng đầu tiên gồm 3 số nguyên dương N, K và M (1 ≤  N ≤  100, K ≤  100, M ≤  N^2).  M dòng tiếp theo, mỗi dòng gồm 4 số nguyên u, v, x, y cho biết có rào chắn ở giữa hai khu vực (u, v) và (x, y) (2 ô này cạnh nhau). K dòng cuối, mỗi dòng chứa 2 số nguyên là tọa độ của mỗi chú cừu.

**Output:** 
In ra số cặp chú cừu bị xa cách tìm được.

![download](https://user-images.githubusercontent.com/64203006/168849278-f062cf88-46e5-453e-be0a-d7d1fd4847fa.png)

**input**
```
3 3 3
2 2 2 3
3 3 3 2
3 3 2 3
3 3
2 2
2 3
```

**output**
```
2
``` 

*Giải thích test: Cặp (3, 1) và (2, 1).*

###	DSA09032 - KẾT BẠN

Trường học X có N sinh viên, trong đó có M cặp là bạn bè của nhau. Bạn của bạn cũng là bạn, tức là nếu A là bạn của B, B là bạn của C thì A và C cũng là bạn bè của nhau.

Các bạn hãy xác định xem số lượng sinh viên nhiều nhất trong một nhóm bạn là bao nhiêu?

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi 2 số nguyên N và M (N, M ≤ 100 000).
- M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v (u #v) cho biết sinh viên u là bạn của sinh viên v.

**Output:** 
- Với mỗi test, in ra đáp án tìm được trên một dòng.

**input**
```
2
3 2
1 2
2 3
10 12
1 2
3 1
3 4
5 4
3 5
4 6
5 2
2 1
7 1
1 2
9 10
8 9
```

**output**
```
3
7
``` 

###	DSA09033 - MẠNG XÃ HỘI

Tý đang xây dựng một mạng xã hội và mời các bạn của mình dùng thử. Bạn của bạn cũng là bạn. Vì vậy, Tý muốn mạng xã hội của mình là hoàn hảo, tức với mọi bộ ba X, Y, Z, nếu X kết bạn với Y, Y kết bạn với Z thì X và Z cũng phải là bạn bè của nhau trên mạng xã hội.

Các bạn hãy xác định xem mạng xã hội hiện tại của Tý có là hoàn hảo hay không? Nếu có hãy in ra “YES”, “NO” trong trường hợp ngược lại.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi 2 số nguyên N và M (N, M ≤ 100 000).
- M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v (u #v) cho biết sinh viên u là bạn của sinh viên v.

**Output:** 
- Với mỗi test, in ra đáp án tìm được trên một dòng.

**input**
```
3
4 3
1 3
3 4
1 4
4 4
3 1
2 3
3 4
1 2
10 4
4 3
5 10
8 9
1 2
```

**output**
```
YES
NO
YES
``` 

###	DSA09034 - ĐẾM SỐ AO

Sau khi thi trượt môn Cấu trúc dữ liệu và giải thuật, một số sinh viên D19 CNTT - PTIT quyết định bỏ học, đầu tư thuê đất để trồng rau. Mảnh đất thuê là một hình chữ nhật N x M (1≤ N≤ 100; 1≤ M≤ 100) ô đất hình vuông. Nhưng chỉ sau đó vài ngày, trận lụt khủng khiếp đã diễn ra làm một số ô đất bị ngập. Mảnh đất bỗng biến thành các cái ao. Và sinh viên D19 lại dự định chuyển sang nuôi cá. Các bạn ấy muốn biết mảnh đất được chia thành bao nhiêu cái ao để có thể tính toán nuôi cá cho hợp lý. Hãy giúp các bạn ấy nhé. *Chú ý: Ao là gồm một số ô đất bị ngập có chung đỉnh. Dễ nhận thấy là một ô đất có thể có tối đa 8 ô chung đỉnh.*


Các bạn hãy xác định xem mạng xã hội hiện tại của Tý có là hoàn hảo hay không? Nếu có hãy in ra “YES”, “NO” trong trường hợp ngược lại.

**Input:** 
Dòng1: 2 số nguyên cách nhau bởi dấu cách: N và M. Dòng 2..N+1: M kí tự liên tiếp nhau mỗi dòng đại diện cho 1 hàng các ô đất.  Mỗi kí tự là 'W' hoặc '.' tương ứng với ô đất đã bị ngập và ô đất vẫn còn nguyên.

**Output:** 
Một dòng chứa 1 số nguyên duy nhất là số ao tạo thành.

**input**
```
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
```

**output**
```
3
``` 

###	DSA09037 - HỌP MẶT

Có K người (1 ≤ K ≤ 100) đứng tại vị trí nào đó trong N địa điểm cho trước (1 ≤ N ≤ 1,000) được đánh số từ 1..N. Các điểm được nối với nhau bởi M đoạn đường một chiều (1 ≤ M ≤ 10,000) (không có đoạn đường nào nối một điểm với chính nó).

Mọi người muốn cùng tụ họp tại một địa điểm nào đó. Tuy nhiên, với các đường đi cho trước, chỉ có một số địa điểm nào đó có thể được chọn là điểm họp mặt. Cho trước K, N, M và vị trí ban đầu của K người cùng với M đường đi một chiều, hãy xác định xem có bao nhiêu điểm có thể được chọn làm điểm họp mặt. 

**Input:** 
- Dòng 1: Ghi 3 số: K, N, và M 
- Dòng 2 đến K+1: dòng i+1 chứa một số nguyên trong khoảng (1..N) cho biết địa điểm mà người thứ i đang đứng. 
- Dòng K+2 đến M+K+1: Mỗi dòng ghi một cặp số A và B mô tả một đoạn đường đi một chiều từ A đến B (cả hai trong khoảng 1..N và A != B).

**Output:** 
- Số địa điểm có thể được chọn là điểm họp mặt.

**input**
```
2 4 4
2
3
1 2
1 4
2 3
3 4
```

**output**
```
2
``` 

*Giải thích Ví dụ: có thể họp mặt tại điểm 3 và điểm 4.*

###	DSA09049 - LAN TRUYỀN DINH DƯỠNG

Cho một cây có N đỉnh và gốc tại đỉnh 1. Mỗi nút lá có chức năng tổng hợp chất dinh dưỡng, đồng thời lan truyền năng lượng cũng như các chất dinh dưỡng cho nút cha của nó để thực hiện quá trình tổng hợp.

Quá trình lan truyền năng lượng sẽ làm tăng giá trị dinh dưỡng lên 1. Tức là nếu một nút tổng hợp được giá trị dinh dưỡng bằng V, sẽ giúp cho nút cha của nó sẽ tổng hợp được giá trị dinh dưỡng bằng V+1. Nếu một nút cha có nhiều nút con, giá trị dinh dưỡng của nó bằng tổng của giá trị dinh dưỡng của các nút con gửi lên.

Biết rằng mỗi nút lá ban đầu tổng hợp được chất dinh dưỡng có giá trị 1. Nhiệm vụ của bạn là hãy xác định xem mỗi nút của cây tổng hợp được bao nhiêu giá trị dinh dưỡng?

**Input:** 
- Dòng đầu tiên là số lượng đỉnh N (N <= 200 000).
- Dòng tiếp theo gồm N-1 số nguyên, a[2], a[3], …, a[N] lần lượt là cha của các nút 2, 3, …, N.

**Output:** 
- In ra N số nguyên, số nguyên thứ i cho biết giá trị dinh dưỡng mà nút i tổng hợp được.

***Test1***

**input**
```
3
1 1
```

**output**
```
5 1 1
``` 

***Test2***

**input**
```
5
1 2 2 4
```

**output**
```
13 8 1 3 1
``` 

###	DSA10003 - KIỂM TRA CHU TRÌNH SỬ DỤNG DISJOIN SET

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Sử dụng **Disjoin Set**, hãy kiểm tra xem đồ thị có tồn tại chu trình hay không?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.

**input**
```
1
6 9
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
```

**output**
```
YES
``` 

###	DSA10004 - ĐƯỜNG ĐI VÀ CHU TRÌNH EULER VỚI ĐỒ THỊ VÔ HƯỚNG

Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có đường đi Euler hay chu trình Euler hay không?

Đường đi Euler bắt đầu tại một đỉnh, và kết thúc tại một đỉnh khác.

Chu trình Euler bắt đầu tại một đỉnh, và kết thúc chu trình tại chính đỉnh đó.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra 1, 2, 0 kết quả mỗi test theo từng dòng tương ứng với đồ thị có đường đi Euler, chu trình Euler và trường hợp không tồn tại.

**input**
```
2
6 10  
1 2 1 3 2 3 2 4 2 5 3 4 3 5 4 5 4 6 5 6
6 9  
1 2 1 3 2 3 2 4 2 5 3 4 3 5 4 5 4 6
```

**output**
```
2
1
``` 

###	DSA10005 - CHU TRÌNH EULER TRONG ĐỒ THỊ CÓ HƯỚNG

Cho đồ thị có hướng liên thông yếu G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có chu trình Euler hay không?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh,  số cạnh của đồ thị; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra 1, 0 kết quả mỗi test theo từng dòng tương ứng với đồ thị có chu trình Euler và trường hợp không tồn tại đáp án.

**input**
```
2
6  10  
1 2 2 4 2 5 3 1 3 2 4 3 4 5 5 3 5 6 6 4
3 3
1 2 2 3 1 3
```

**output**
```
1
0
``` 

###	TN05009 - CHU TRÌNH THEO DFS

Cho đồ thị vô hướng G= được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có chu trình từ đỉnh 1 hay không, nếu có, hãy in ra chu trình đầu tiên tìm thấy theo DFS.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số N, M  tương ứng với số đỉnh, số cạnh.
- Dòng tiếp theo đưa vào các bộ đôi u, v tương ứng với một cạnh của đồ thị.
- T, N, M thỏa mãn ràng buộc: 1≤T≤100; 1≤ N ≤10<sup>3</sup>; 1≤ M ≤ N*(N-1)/2;

**Output:** 
- Đưa ra chu trình đầu tiên tìm thấy theo DFS từ đỉnh 1.
- Nếu không có chu trình từ đỉnh 1, ghi ra NO

**input**
```
1
6 9
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
```

**output**
```
1 2 3 1
``` 

## Graph (Advanced)

###	DSA09018 - LIỆT KÊ ĐỈNH TRỤ

Cho đồ thị vô hướng liên thông G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy đưa ra tất cả các đỉnh trụ của đồ thị?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh và số cạnh; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra danh sách các đỉnh trụ của mỗi test  theo từng dòng.

**input**
```
1
5 5
1 2 1 3 2 3 2 5 3 4
```

**output**
```
2 3
``` 

###	DSA09018 - KIỂM TRA CHU TRÌNH

Cho đồ thị vô hướng G=<V, E> được biểu diễn dưới dạng danh sách cạnh. Hãy kiểm tra xem đồ thị có tồn tại chu trình hay không?

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh và số cạnh; Dòng tiếp theo đưa vào các bộ đôi u∈V, v∈V tương ứng với một cạnh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra YES hoặc “NO” kết quả test theo từng dòng tương ứng với đồ thị tồn tại hoặc không tồn tại chu trình.

**input**
```
1
6 9
1 2 1 3 2 3 2 5 3 4 3 5 4 5 4 6 5 6
```

**output**
```
YES
``` 

###	DSA10001 - TÌM ĐƯỜNG

Cho một bảng S[][] kích thước N x M, bao gồm các ô trống, các vật cản. Ban đầu bạn ở vị trí S. Nhiệm vụ của bạn là hãy di chuyển tới vị trí T, sao cho số lần đổi hướng không quá hai lần.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ N, M ≤ 500).
- N dòng tiếp theo, mỗi dòng gồm M kí tự mô tả bảng S. Trong đó: ‘.’ là một ô trống, ‘*’ là vật cản, ‘S’ là vị trí xuất phát và ‘T’ là vị trí đích. (Chỉ có một vị trí S và T duy nhất).

**Output:** 
- Với mỗi test, in ra “YES” nếu tìm được đường đi, ra in “NO” trong trường hợp ngược lại.

**input**
```
2
5 5
..S..
****.
T....
****.
.....
5 5
S....
****.
.....
.****
..T..
```

**output**
```
YES
NO
``` 

###	DSA10006 - CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN DFS

Cho đồ thị vô hướng G=(V, E). Hãy xây dựng một cây khung của đồ thị G với đỉnh u ∈ V là gốc của cây bằng thuật toán DFS.

**Input:** 

Dòng đầu tiên gồm một số nguyên T (1 ≤ T ≤ 20) là số lượng bộ test.

Tiếp theo là T bộ test, mỗi bộ test có dạng sau:

- Dòng đầu tiên gồm 3 số nguyên N=|V|, M=|E|, u (1 ≤ N ≤ 10<sup>3</sup>, 1 ≤ M ≤ 10<sup>5, 1 ≤ u ≤ N).
- Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ N, M ≤ 500).
- M dòng tiếp theo, mỗi dòng gồm 2 số nguyên a, b (1 ≤ a, b ≤ N, a ≠ b) tương ứng cạnh nối hai chiều từ a tới b.
- Dữ liệu đảm bảo giữa hai đỉnh chỉ tồn tại nhiều nhất một cạnh nối.

**Output:** 

Với mỗi bộ test, nếu tồn tại cây khung thì in ra N – 1 cạnh của cây khung với gốc là đỉnh u trên N – 1 dòng theo thứ tự duyệt của thuật toán DFS. Ngược lại nếu không tồn tại cây khung thì in ra -1.


**input**
```
2
4 4 2
1 2
1 3
2 4
3 4
4 2 2
1 2
3 4
```

**output**
```
2 1
1 3
3 4
-1
``` 

###	DSA10007 - CÂY KHUNG CỦA ĐỒ THỊ THEO THUẬT TOÁN BFS

Cho đồ thị vô hướng G=(V, E). Hãy xây dựng một cây khung của đồ thị G với đỉnh u ∈ V là gốc của cây bằng thuật toán BFS.

**Input:** 

Dòng đầu tiên gồm một số nguyên T (1 ≤ T ≤ 20) là số lượng bộ test.

Tiếp theo là T bộ test, mỗi bộ test có dạng sau:

- Dòng đầu tiên gồm 3 số nguyên N=|V|, M=|E|, u (1 ≤ N ≤ 10<sup>3</sup>, 1 ≤ M ≤ 10<sup>5, 1 ≤ u ≤ N).
- Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ N, M ≤ 500).
- M dòng tiếp theo, mỗi dòng gồm 2 số nguyên a, b (1 ≤ a, b ≤ N, a ≠ b) tương ứng cạnh nối hai chiều từ a tới b.
- Dữ liệu đảm bảo giữa hai đỉnh chỉ tồn tại nhiều nhất một cạnh nối.

**Output:** 

Với mỗi bộ test, nếu tồn tại cây khung thì in ra N – 1 cạnh của cây khung với gốc là đỉnh u trên N – 1 dòng theo thứ tự duyệt của thuật toán BFS. Ngược lại nếu không tồn tại cây khung thì in ra -1.


**input**
```
2
4 4 2
1 2
1 3
2 4
3 4
4 2 2
1 2
3 4
```

**output**
```
2 1
2 4
1 3
-1
``` 

###	DSA10008 - DIJKSTRA

Cho đồ thị có trọng số không âm G=<V, E> được biểu diễn dưới dạng danh sách cạnh trọng số. Hãy viết chương trình tìm đường đi ngắn nhất từ đỉnh u∈V đến tất cả các đỉnh còn lại trên đồ thị.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E|+1 dòng: dòng đầu tiên đưa vào hai ba số |V|, |E| tương ứng với số đỉnh và u∈V là đỉnh bắt đầu; |E| dòng tiếp theo mỗi dòng đưa vào bộ ba u∈V, v∈V, w tương ứng với một cạnh cùng với trọng số canh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra kết quả của mỗi test theo từng dòng. Kết quả mỗi test là trọng số đường đi ngắn nhất từ đỉnh u đến các đỉnh còn lại của đồ thị theo thứ tự tăng dần các đỉnh.


**input**
```
1
9 12 1
1 2 4
1 8 8
2 3 8
2 8 11
3 4 7
3 6 4
3 9 2
4 5 9
4 6 14
5 6 10
6 7 2
6 9 6
```

**output**
```
0 4 12 19 26 16 18 8 14 
``` 

###	DSA10009 - FLOYD

Cho đơn đồ thị vô hướng liên thông G = (V, E) gồm N đỉnh và M cạnh, các đỉnh được đánh số từ 1 tới N và các cạnh được đánh số từ 1 tới M.

Có Q truy vấn, mỗi truy vấn yêu cầu bạn tìm đường đi ngắn nhất giữa đỉnh X[i] tới Y[i].

**Input:** 
- Dòng đầu tiên hai số nguyên N và M (1 ≤ N ≤ 100, 1 ≤ M ≤ N*(N-1)/2).
- M dòng tiếp theo, mỗi dòng gồm 3 số nguyên u, v, c cho biết có cạnh nối giữa đỉnh u và v có độ dài bằng c (1 ≤ c ≤ 1000).
- Tiếp theo là số lượng truy vấn Q (1 ≤ Q ≤ 100 000).
- Q dòng tiếp theo, mỗi dòng gồm 2 số nguyên X[i], Y[i].

**Output:** 
- Với mỗi truy vấn, in ra đáp án là độ dài đường đi ngắn nhất tìm được.


**input**
```
5 6
1 2 6
1 3 7
2 4 8
3 4 9
3 5 1
4 5 2
3
1 5
2 5
4 3
```

**output**
```
8
10
3
``` 

###	DSA10011 - DI CHUYỂN TRÊN BẢNG SỐ

Cho một bảng số kích thước N x M. Chi phí khi đi qua ô (i,j) bằng A[i][j]. Nhiệm vụ của bạn là hãy tìm một đường đi từ ô (1, 1) tới ô (N, M) sao cho chi phí là nhỏ nhất. Tại mỗi ô, bạn được phép đi sang trái, sang phải, đi lên trên và xuống dưới.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ N, M ≤ 500).
- N dòng tiếp theo, mỗi dòng gồm M số nguyên A[i][j] (0 ≤ A[i][j] ≤ 9).

**Output:** 
- Với mỗi test, in ra một số nguyên là chi phí nhỏ nhất cho đường đi tìm được.


**input**
```
3
4
5
0 3 1 2 9
7 3 4 9 9
1 7 5 5 3
2 3 4 2 5
1
6
0 1 2 3 4 5
5 5
1 1 1 9 9
9 9 1 9 9
1 1 1 9 9
1 9 9 9 9
1 1 1 1 1
```

**output**
```
24
15
13
``` 

###	DSA10012 - ĐƯỜNG ĐI TRUNG BÌNH

Cho một đồ thị có hướng gồm N đỉnh và M cạnh. Nhiệm vụ của bạn là hãy tính khoảng cách trung bình ngắn nhất giữa hai node bất kì nếu như chúng liên thông với nhau. Input đảm bảo rằng trong một nhóm liên thông, nếu như u đi tới được v thì v cũng đi tới được v với mọi cặp u, v.

![download](https://user-images.githubusercontent.com/64203006/168857532-7c2d984e-5752-4ecb-b0dc-ea000eb75ed8.png)

**Input:** 
Dòng đầu tiên là số lượng bộ test T (T ≤ 20). Mỗi test bắt đầu bởi hai số nguyên N và M (1 ≤ N ≤ 100, M ≤ N*(N-1)/2). M dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết có cạnh nối đơn hướng từ u tới v.

**Output:** 
Với mỗi test, in ra đáp án tìm được với độ chính xác 2 chữ số sau dấu phảy.


**input**
```
2
4 5
1 2
2 4
1 3
3 1
4 3
7 5
1 2
1 4
4 2
2 7
7 1
```

**output**
```
1.83
1.75
``` 

Giải thích test 1: Ta có

d(1, 2) = 1, d(1, 3) = 1, d(1, 4) = 2; d (2, 1) = 3, d(2, 3) = 2, d(2, 4) = 1;

d(3, 1) = 1, d(3, 2) = 2, d(3, 4) = 3; d(4, 1) = 2, d(4, 2) = 3, d(4, 3) = 1.

Trung bình bằng 22/12 = 1.83

###	DSA10015 - KRUSKAL

Cho đồ thị vô hướng có trọng số G=<V, E, W>. Nhiệm vụ của bạn là hãy xây dựng một cây khung nhỏ nhất của đồ thị bằng thuật toán Kruskal.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng kế tiếp đưa vào các bộ test. Mỗi bộ test gồm hai phần: phần thứ nhất đưa vào hai số V, E tương ứng với số đỉnh và số cạnh của đồ thị; phần thứ 2 đưa vào E cạnh của đồ thị, mỗi cạnh là một bộ 3: đỉnh đầu, đỉnh cuối và trọng số của cạnh.
- T, S, D thỏa mãn ràng buộc: 1≤T≤100;  1≤V≤100; 1≤E, W≤10000.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
3 3
1 2 5
2 3 3
1 3 1
2 1
1 2 5
```

**output**
```
4
5
``` 

###	DSA10016 - NỐI ĐIỂM

Cho N điểm trên mặt phẳng Oxy. Để vẽ được đoạn thẳng nối A và B sẽ tốn chi phí tương đương với khoảng cách từ A tới B.

Nhiệm vụ của bạn là nối các điểm với nhau, sao cho N điểm đã cho tạo thành 1 thành phần liên thông duy nhất và chi phí để thực hiện là nhỏ nhất có thể.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T (T ≤ 20).
- Mỗi test bắt đầu bởi số nguyên N (1 ≤ N ≤ 100).
- N dòng tiếp theo, mỗi dòng gồm 2 số thực x[i], y[i] là tọa độ của điểm thứ i (|x[i]|, |y[i]| ≤ 100).

**Output:** 
- Với mỗi test, in ra chi phí nhỏ nhất tìm được với độ chính xác 6 chữ số thập phân sau dấu phẩy.

**input**
```
1
3
1.0 1.0
2.0 2.0
2.0 4.0
```

**output**
```
3.414214
``` 

###	DSA10017 - CHU TRÌNH ÂM

Cho đồ thị có trọng số G=<V, E> được biểu diễn dưới dạng danh sách cạnh trọng số âm hoặc dương. Hãy viết chương trình xác định xem đồ thị có chu trình âm hay không.

**Input:** 
- Dòng đầu tiên đưa vào T là số lượng bộ test.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm |E|+1 dòng: dòng đầu tiên đưa vào hai số |V|, |E| tương ứng với số đỉnh và số cạnh của đồ thị; |E| dòng tiếp theo mỗi dòng đưa vào bộ ba u∈V, v∈V, w tương ứng với một cạnh cùng với trọng số canh của đồ thị.
- T, |V|, |E| thỏa mãn ràng buộc: 1≤T≤100; 1≤|V|≤10<sup>3</sup>; 1≤|E|≤|V|(|V|-1)/2;

**Output:** 
- Đưa ra 1 hoặc 0 theo từng dòng của mỗi test tương ứng với đồ thị có hoặc không có chu trình âm.

**input**
```
2
3 3
1 2 -1
2 3 4
3 1 -2
3 3
1 2 -1
2 3 2
3 1 -2
```

**output**
```
0
1
``` 

## Tree

###	DSA11001 - CÂY BIỂU THỨC 1

Cây biểu thức là một cây nhị phân trong đó mỗi node trung gian là một phép toán, mỗi node lá là một toán hạng. Ví dụ với biểu thức P = 3 + ((5+9)*2) sẽ được biểu diễn như cây dưới đây.

![download](https://user-images.githubusercontent.com/64203006/169007933-244975f7-9522-4d52-b552-8e4ae66351b3.png)

Đối với cây biểu thức, duyệt theo thứ tự trước ta sẽ được biểu thức tiền tố, duyệt theo thứ tự sau ta sẽ được biểu thức hậu tố, duyệt theo thứ tự giữa ta được biểu thức trung tố. Chú ý, cây biểu thức luôn là cây nhị phân đầy (mỗi node trung gian đều có hai node con).

Cho biểu thức hậu tố P, hãy sử dụng cây biểu thức để đưa ra biểu thức trung tố tương ứng với biểu thức P.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test là một biểu thức hậu tố P.
- T, P thỏa mãn ràng buộc : 1≤T≤100; 1≤lengh(P)≤100.

**Output:** 
- Đưa ra biểu thức trung tố tương ứng với P.

**input**
```
2
ab+ef*g*-
wlrb+-*
```

**output**
```
a + b - e * f * g
w * l - r + b
``` 

###	DSA11002 - CÂY BIỂU THỨC 2

Cho một cây biểu thức là một cây nhị phân đầy đủ bao gồm các phép toán +, -, \*. / và một số toán hạng có giá trị nguyên. Nhiệm vụ của bạn là hãy tính toán giá trị biểu thức được biểu diễn trên cây nhị phân đầy đủ. Ví dụ với cây dưới đây là biểu diễn của biểu thức P = ( (5\*4) + (100-20)) sẽ cho ta giá trị là 100.

![download](https://user-images.githubusercontent.com/64203006/169007933-244975f7-9522-4d52-b552-8e4ae66351b3.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test là gồm hai dòng: dòng thứ nhất đưa vào N là số lượng node của cây; dòng thứ hai đưa vào nội dung các node của cây; các node được viết cách nhau một vài khoảng trống. Các số có giá trị nguyên không vượt quá 1000.
- T, N, P thỏa mãn ràng buộc : 1≤T≤100; 1≤N, lenght(P)≤100.

**Output:** 
- Đưa ra giá trị của cây biểu thức.

**input**
```
2
7
+ * - 5 4 100 20
3
- 4 7 
```

**output**
```
100
-3
```

###	DSA11003 - DUYỆT CÂY 1

Cho phép duyệt cây nhị phân Inorder và Preorder, hãy đưa ra kết quả phép duyệt Postorder của cây nhị phân. Ví dụ với cây nhị phân có các phép duyệt cây nhị phân của cây dưới đây:

```
         1
      /    \    
     2       3
   /   \      \
  4     5      6
```

Inorder: 4 2 5 1 3 6

Preorder: 1 2 4 5 3 6

Postorder: 4 5 2 6 3 1 

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng node; dòng tiếp theo đưa vào N số theo phép duyệt Inorder; dòng cuối cùng đưa vào N số là kết quả của phép duyệt Preorder; các số được viết cách nhau một vài khoảng trống.
- T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤1000; 1≤ giá trị node ≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
1
6
4 2 5 1 3 6
1 2 4 5 3 6
```

**output**
```
4 5 2 6 3 1
```

###	DSA11004 - DUYỆT CÂY THEO MỨC

Cho cây nhị phân, nhiệm vụ của bạn là duyệt cây theo Level-order. Phép duyệt level-order trên cây là phép thăm node theo từng mức của cây. Ví dụ với cây dưới đây sẽ cho ta kết quả của phép duyệt level-order: 20  8  22  4  12  10  14.

![download](https://user-images.githubusercontent.com/64203006/169009802-2135ce8f-a90a-438f-b2ba-1880ca41afd1.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt level-order theo từng dòng.

**input**
```
2
2
1 2 R 1 3 L
4
10 20 L 10 30 R 20 40 L 20 60 R
```

**output**
```
1 3 2
10 20 30 40 60
```

###	DSA11005 - DUYỆT CÂY 2

Cho hai mảng là phép duyệt Inorder và Level-order, nhiệm vụ của bạn là xây dựng cây nhị phân và đưa ra kết quả phép duyệt Postorder. Level-order là phép duyệt theo từng mức của cây. Ví dụ như cây dưới đây ta có phép Inorder và Level-order như dưới đây:

Inorder : 4 8 10 12 14 20 22

Level order: 20 8 22 4 12 10 14

![download](https://user-images.githubusercontent.com/64203006/169010113-4e97345a-8ab4-4a80-a119-1dcee7b563f1.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng node; dòng tiếp theo đưa vào N số là phép duyệt Inorder; dòng cuối cùng đưa vào N số là phép duyệt Level-order; các số được viết cách nhau một vài khoảng trống.
- T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤A[i]≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
2
3
1 0 2 
0 1 2 
7
3 1 4 0 5 2 6 
0 1 2 3 4 5 6 
```

**output**
```
1 2 0
3 4 1 5 6 2 0
```

###	DSA11006 - DUYỆT CÂY KIỂU XOẮN ỐC

Cho cây nhị phân, nhiệm vụ của bạn là duyệt cây theo xoắn ốc (spiral-order). Phép. Ví dụ với cây dưới đây sẽ cho ta kết quả của phép duyệt spiral-order: 1 2 3  4 5 6 7.

![download](https://user-images.githubusercontent.com/64203006/169011045-205133d5-c04a-4345-a8dc-5fadfc4474d1.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
2
2
1 2 R 1 3 L
4
10 20 L 10 30 R 20 40 L 20 60 R
```

**output**
```
1 3 2
10 0 30 60 40
```

###	DSA11008 - KIỂM TRA NODE LÁ

Cho cây nhị phân, nhiệm vụ của bạn là kiểm tra xem tất cả các node lá của cây có cùng một mức hay không? Ví dụ với cây dưới đây sẽ cho ta kết quả là Yes.

![download](https://user-images.githubusercontent.com/64203006/169011286-ce6cfa9d-491f-476f-93a1-ce33d1250eff.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
2
2
1 2 R 1 3 L
4
10 20 L 10 30 R 20 40 L 20 60 R
```

**output**
```
1
0
```

###	DSA11010 - CÂY NHỊ PHÂN HOÀN HẢO

Cho cây nhị phân, nhiệm vụ của bạn là kiểm tra xem cây nhị phân có phải là một cây hoàn hảo hay không (perfect tree)? Một cây nhị phân được gọi là cây hoàn hảo nếu tất cả các node trung gian của nó đều có hai node con và tất cả các node lá đều có cùng một mức.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
3
6
10 20 L 10 30 R 20 40 L 20 50 R 30 60 L 30 70 R
2
18 15 L 18 30 R
5
1 2 L 2 4 R 1 3 R 3 5 L 3 6 R
```

**output**
```
Yes
Yes
No
```

###	DSA11011 - CÂY NHỊ PHÂN ĐỦ

Cho cây nhị phân, nhiệm vụ của bạn là kiểm tra xem cây nhị phân có phải là một cây đủ hay không (full binary tree)? Một cây nhị phân được gọi là cây đủ nếu tất cả các node trung gian của nó đều có hai node con.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
2
4
1 2 L 1 3 R 2 4 L 2 5 R
3
1 2 L 1 3 R 2 4 L
```

**output**
```
1
0
```

###	DSA11012 - CÂY NHỊ PHÂN BẰNG NHAU

Cho hai cây nhị phân, nhiệm vụ của bạn là kiểm tra xem cây nhị phân có giống nhau hay không?

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái của mỗi cây; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
2
2
1 2 L 1 3 R
2
1 2 L 1 3 R
2
1 2 L 1 3 R
2
1 3 L 1 2 R
```

**output**
```
1
0
```

###	DSA11014 - TỔNG NODE LÁ BÊN PHẢI

Cho cây nhị phân, nhiệm vụ của bạn là tính tổng của tất cả các node lá bên phải trên cây? Ví dụ với cây dưới đây ta có kết quả là 2.

![download](https://user-images.githubusercontent.com/64203006/169011952-af885f76-dac8-4383-bfbf-52c99259c2f7.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
2
2
1 2 L 1 3 R
5
10 20 L 10 30 R 20 40 L 20 60 R 30 90 L
```

**output**
```
3
60
```

###	DSA11015 - TỔNG LỚN NHẤT

Cho cây nhị phân có giá trị mỗi node là một số, nhiệm vụ của bạn là tìm tổng lớn nhất từ một node lá này sang một node lá khác? Ví dụ với cây dưới đây ta có tổng lớn nhất là 27.

![download](https://user-images.githubusercontent.com/64203006/169012115-bb74c4be-9cd3-42aa-be5c-81d3eec5adfd.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
1
12
-15 5 L -15 6 R 5 -8 L 5 1 R -8 2 L -8 -3 R 6 3 L 6 9 R 9 0 R 0 4 L 0 -1 R -1 10 L
```

**output**
```
27
```

###	DSA11016 - BIẾN ĐỔI SANG CÂY NHỊ PHÂN TÌM KIẾM

Cho cây nhị phân, nhiệm vụ của bạn là dịch chuyển cây nhị phân thành cây nhị phân tìm kiếm. Phép dịch chuyển phải bảo toàn được cấu trúc cây nhị phân ban đầu. Ví dụ dưới đây sẽ minh họa phép dịch chuyển:

![download](https://user-images.githubusercontent.com/64203006/169010358-f97283fb-99b4-492f-9295-ec971388af20.png)

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 3 dòng: dòng đầu tiên đưa vào số N là số lượng cạnh của cây; dòng tiếp theo đưa vào N bộ ba (u, v, x), trong đó u là node cha, v là node con, x= R nếu v là con phải, x=L nếu v là con trái; u, v, x được viết cách nhau một vài khoảng trống.
- T, N, u, v, thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤u, v≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng là phép duyệt Inorder của cây tìm kiếm.

**input**
```
2
2
1 2 R 1 3 L
4
10 20 L 10 30 R 20 40 L 20 60 R
```

**output**
```
1 2 3
10 20 30 40 60
```

###	DSA11017 - DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 1

Cho mảng A[] gồm N node là biểu diễn phép duyệt theo thứ tự giữa (Preorder) của cây nhị phân tìm kiếm. Nhiệm vụ của bạn là đưa ra phép duyệt theo thứ tự sau của cây nhị phân tìm kiếm.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng node; dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤A[i]≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả phép duyệt Postorder theo từng dòng.

**input**
```
2
5
40 30 35 80 100
8
40 30 32 35 80 90 100 120
```

**output**
```
35 30 100 80 40
35 32 30 120 100 90 80 40
```

###	DSA11018 - XÂY DỰNG LẠI CÂY NHỊ PHÂN TÌM KIẾM

Cho một mảng là phép duyệt level-order của cây nhị phân tìm kiếm. Nhiệm vụ của bạn là xây dựng lại cây nhị phân tìm kiếm bảo toàn được cấu trúc cây nhị phân ban đầu.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm dòng: dòng đầu tiên đưa vào số N là số lượng node của cây tìm kiếm; dòng tiếp theo đưa vào phép duyệt level-order của cây tìm kiếm; các số được viết cách nhau một vài khoảng trống.
- T, N, node thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤node≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng là phép duyệt trước (preOrder) của cây tìm kiếm.

**input**
```
2
9
7 4 12 3 6 8 1 5 10
6
1 3 4 6 7 8
```

**output**
```
7 4 3 1 6 5 12 8 10
1 3 4 6 7 8
```

###	DSA11019 - DUYỆT CÂY NHỊ PHÂN TÌM KIẾM 2

Cho một mảng A[] gồm N phần tử biểu diễn phép duyệt preorder của cây nhị phân tìm kiếm. Nhiệm vụ của bạn là đưa ra phép duyệt postorder của cây nhị phân tìm kiếm.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng node của cây tìm kiếm; dòng tiếp theo đưa vào phép duyệt preorder của cây tìm kiếm; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤A[i]≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng là phép duyệt postorder của cây tìm kiếm.

**input**
```
2
5
40 30 35 80 100
8
40 30 32 35 80 90 100 120
```

**output**
```
35 30 100 80 40
35 32 30 120 100 90 80 40
```

###	DSA11020 - KIỂM TRA CÂY NHỊ PHÂN TÌM KIẾM

Cho một mảng A[] gồm N phần tử. Nhiệm vụ của bạn là đưa ra 1 nếu mảng A[] biểu diễn phép duyệt inorder của cây nhị phân tìm kiếm, ngược lại đưa ra 0.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T.
- Những dòng tiếp theo đưa vào các bộ test. Mỗi bộ test gồm 2 dòng: dòng đầu tiên đưa vào số N là số lượng node của cây tìm kiếm; dòng tiếp theo đưa vào N số A[i]; các số được viết cách nhau một vài khoảng trống.
- T, N, A[i] thỏa mãn ràng buộc: 1≤T≤100; 1≤N≤10<sup>3</sup>; 1≤A[i]≤10<sup>4</sup>;

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
3
5
10 20 30 40 50
6
90 80 100 70 40 30
3
1 1 2
```

**output**
```
1
0
0
```

###	DSA11021 - NODE LÁ CỦA CÂY NHỊ PHÂN TÌM KIẾM

Cho dãy số gồm N số là phép duyệt theo thứ tự trước (Preorder) của một cây nhị phân tìm kiếm. Hãy in ra tất cả các node lá của cây ?

Ví dụ với dãy A[] = {30, 20, 15, 25, 23, 28, 40, 35, 33, 38, 45} là phép duyệt cây theo thứ tự trước sẽ cho ta kết quả: 15, 23, 28, 33, 38, 45.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là N số là phép duyệt theo thứ tự trước của cây BST.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
6
10 5 1 7 40 50
11
30 20 15 25 23 28 40 35 33 38 45
```

**output**
```
1 7 50
15 23 28 33 38 45
```

###	DSA11022 - NODE TRUNG GIAN CỦA CÂY NHỊ PHÂN TÌM KIẾM

Cho dãy số gồm N số là phép duyệt theo thứ tự trước (Preorder) của một cây nhị phân tìm kiếm. Hãy đưa ra số các node trung gian của cây ?

Ví dụ với dãy A[] = {30, 20, 15, 25, 23, 28, 40, 35, 33, 38, 45} là phép duyệt cây theo thứ tự trước sẽ cho ta kết quả là 5 bao gồm các node: 30, 20, 25, 40, 35.                     

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là N số là phép duyệt theo thứ tự trước của cây BST.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
6
10 5 1 7 40 50
11
30 20 15 25 23 28 40 35 33 38 45
```

**output**
```
3
5
```

###	DSA11023 - ĐỘ SÂU CÂY NHỊ PHÂN TÌM KIẾM

Cho dãy số gồm N số là phép duyệt theo thứ tự trước (Preorder) của một cây nhị phân tìm kiếm. Hãy tìm độ sâu của cây ?

Ví dụ với dãy A[] = {30, 20, 15, 25, 23, 28, 40, 35, 33, 38, 45} là phép duyệt cây theo thứ tự trước sẽ cho ta kết quả là 3.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là N số là phép duyệt theo thứ tự trước của cây BST.

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
6
10 5 1 7 40 50
11
30 20 15 25 23 28 40 35 33 38 45
```

**output**
```
2
3
```

###	DSA11024 - CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 1

Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đưa ra nội dung node gốc của cây tìm kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có cây nhị phân tìm kiếm cân bằng với node gốc là 33.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤10<sup>6</sup>). Dòng tiếp theo là N số của mảng A[].

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
11
40 28 45 38 33 15 25 20 23 35 30
10
1 2 3 4 5 6 7 8 9 10
```

**output**
```
30
5
```

###	DSA11025 - CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG 2

Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đưa ra phép duyệt theo thứ tự trước (preorder) của cây tìm kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có phép duyệt theo thứ tự trước của cây nhị phân tìm kiếm cân bằng với node gốc là 33 : 33, 25, 20, 15, 23, 28, 30, 40, 38, 35, 45.

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤10<sup>6</sup>). Dòng tiếp theo là N số của mảng A[].

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
11
40 28 45 38 33 15 25 20 23 35 30
10
1 2 3 4 5 6 7 8 9 10
```

**output**
```
30 23 15 20 25 28 38 33 35 40 45
5 2 1 3 4 8 6 7 9 10
```

###	DSA11026 - DUYỆT SAU CÂY TÌM KIẾM CÂN BẰNG

Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đưa ra phép duyệt theo thứ tự sau (post-order) của cây tìm kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có phép duyệt theo thứ tự trước của cây nhị phân tìm kiếm cân bằng với node gốc là 33 : 15, 23, 20, 30, 28, 25, 35, 38, 45, 40, 33.  

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤10<sup>6</sup>). Dòng tiếp theo là N số của mảng A[].

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
11
40 28 45 38 33 15 25 20 23 35 30
10
1 2 3 4 5 6 7 8 9 10
```

**output**
```
20 15 28 25 23 35 33 45 40 38 30
1 4 3 2 7 6 10 9 8 5
```

###	DSA11027 - ĐẾM SỐ NODE LÁ CÂY NHỊ PHÂN TÌM KIẾM CÂN BẰNG

Hãy xây dựng một cây nhị phân tìm kiếm cân bằng từ dãy số A[] =(a0, a1, .., an-1}. Đếm số node lá của cây nhị phân tìm kiếm cân bằng.  Ví dụ với dãy A[]={40, 28, 45, 38, 33, 15, 25, 20, 23, 35, 30} ta sẽ có phép duyệt theo thứ tự trước của cây nhị phân tìm kiếm cân bằng với số node lá là 5 : 15, 23, 30, 35 45.  

**Input:** 
- Dòng đầu tiên đưa vào số lượng bộ test T (T≤100).
- Những dòng kế tiếp đưa vào T bộ test. Mỗi bộ test gồm 2 dòng: dòng thứ nhất là số tự nhiên N (N≤1000). Dòng tiếp theo là N số của mảng A[].

**Output:** 
- Đưa ra kết quả mỗi test theo từng dòng.

**input**
```
2
11
40 28 45 38 33 15 25 20 23 35 30
10
1 2 3 4 5 6 7 8 9 10
```

**output**
```
5
4
```

###	DSA11028 - ĐỘ CAO CỦA CÂY

Cho một cây có N node, gốc tại  1. Độ cao của một node u được tính bằng khoảng cách từ u tới node gốc. Độ cao của node gốc bằng 0. Nhiệm vụ của bạn là hãy tìm node xa node gốc nhất và in ra độ cao của node này.

**Input:** 
- Dòng đầu tiên là số lượng bộ test T( T≤ 20).
- Mỗi test bắt đầu bằng số nguyên N (1 ≤ N ≤ 100 000).
- N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết node u nối với node v.

**Output:** 
- Với mỗi test, in ra một số nguyên là độ cao của cây.

**input**
```
2
5
1 2
1 3
2 4
2 5
4
1 2
2 3
3 4
```

**output**
```
2
3
```

###	DSA11029 - ĐƯỜNG ĐI TỚI NODE LÁ

Cho một cây có N node, gốc tại 1. Với mỗi node lá, bạn hãy in ra đường đi từ node gốc tới nó.

![download](https://user-images.githubusercontent.com/64203006/169013925-4ff88c1c-5188-4149-9402-efc1d0db2b4b.png)

**Input:** 
- Dòng đầu tiên là số lượng bộ test T( T≤ 20).
- Mỗi test bắt đầu bằng số nguyên N (1 ≤ N ≤ 1000).
- N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết node u nối với node v.

**Output:** 
- Với mỗi test, in ra K dòng, trong đó K là số lượng node lá. Mỗi dòng là đường đi từ node gốc tới node lá X. Node lá nào có nhãn nhỏ hơn, in ra trước.

**input**
```
2
5
1 2
1 3
2 4
2 5
4
1 2
2 3
3 4
```

**output**
```
1 3
1 2 4
1 2 5
1 2 3 4
```

###	DSA11030 - KHOẢNG CÁCH GIỮA HAI NODE

Cho một cây có N node, gốc tại 1. Có Q truy vấn, mỗi truy vấn yêu cầu bạn tìm khoảng cách giữa hai node u và v.

![download](https://user-images.githubusercontent.com/64203006/169014221-3c74e339-ba32-445a-8570-8893ee77ce3a.png)

**Input:** 
- Dòng đầu tiên là số lượng bộ test T( T≤ 20).
- Mỗi test bắt đầu bằng số nguyên N (1 ≤ N ≤ 1000). N-1 dòng tiếp theo, mỗi dòng gồm 2 số nguyên u, v cho biết node u nối với node v.
- Dòng tiếp theo là số lượng truy vấn Q (1 ≤ Q ≤ 1000). Q dòng tiếp theo, mỗi dòng gồm 2 số nguyên u và v.

**Output:** 
- Với mỗi test, in ra Q dòng là đáp án với mỗi truy vấn.

**input**
```
1
8
1 2
1 3
2 4
2 5
3 6
3 7
6 8
5
4 5
4 6
3 4
2 4
8 5
```

**output**
```
2
4
3
1
5
```

###	DSAKT060 - TRUY VẤN ĐỐI XỨNG

Cho số nguyên S gồm N chữ số. Có Q truy vấn, mỗi truy vấn thuộc một trong hai loại sau:

q L R: yêu cầu xác định xâu con S[L, L+1, …, R] có phải là một xâu đối xứng hay không?

c U x: thay đổi kí tự thứ U thành chữ số x.

**Input:** 
- Dòng đầu tiên chứa số nguyên S gồm N kí tự (N  <= 10^5).
- Tiếp theo là số lượng truy vấn Q (Q <= 10^5)
- Q dòng tiếp theo, mỗi dòng gồm một loại truy vấn.

**Output:** 
- Với mỗi truy vấn loại 1, nếu xâu con là một số đối xứng, hãy in ra “YES”, ngược lại in ra “NO”.

**input**
```
12345
5
q 1 5
q 5 5
c 4 3
q 3 5
q 3 4
```

**output**
```
NO
YES
NO
YES
```

